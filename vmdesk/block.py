











import bpy

bpytypes = bpy.types

# <<< 1mp (bpytypes
ShapeKey = bpytypes.ShapeKey
ParticleSystem = bpytypes.ParticleSystem
# >>>

escape_identifier = bpy.utils.escape_identifier

from .  import util

# <<< 1mp (util.txt
txt = util.txt
Text = txt.Text
# >>>

# <<< 1mp (util.types
types = util.types
inher_different = types.inher_different
BlRna = types.BlRna
RnaButton = types.RnaButton
NameValue = types.NameValue
LocalHistory = types.LocalHistory
HistoryValue = types.HistoryValue
Name = types.Name
Dictlist = types.Dictlist
RnaInt = types.RnaInt
RnaFloat = types.RnaFloat
RnaFloatVector = types.RnaFloatVector
RnaBool = types.RnaBool
RnaString = types.RnaString
RnaPointer = types.RnaPointer
PpOverrideCreate = types.PpOverrideCreate
PpOverrideClear = types.PpOverrideClear
# >>>

# <<< 1mp (util.deco
deco = util.deco
successResult = deco.successResult
catch = deco.catch
catchBug = deco.catchBug
assign = deco.assign
# >>>

# <<< 1mp (util.const
const = util.const
FLO_0000 = const.FLO_0000
RANGE_3 = const.RANGE_3
RANGE_4 = const.RANGE_4
FLOAT_min = const.FLOAT_min
FLOAT_max = const.FLOAT_max
TUP_XYZ = const.TUP_XYZ
# >>>

# <<< 1mp (util.com
com = util.com
NS = com.NS
N1 = com.N1
value_to_display = com.value_to_display
is_value = com.is_value
bin_search = com.bin_search
bin_search_fc_anim = com.bin_search_fc_anim
rs_format_float6_vec = com.rs_format_float6_vec
# >>>

bpyopsobject = bpy.ops.object
grease_pencil_time_modifier_segment_add = bpyopsobject.grease_pencil_time_modifier_segment_add
grease_pencil_time_modifier_segment_remove = bpyopsobject.grease_pencil_time_modifier_segment_remove
grease_pencil_time_modifier_segment_move = bpyopsobject.grease_pencil_time_modifier_segment_move
grease_pencil_dash_modifier_segment_add = bpyopsobject.grease_pencil_dash_modifier_segment_add
grease_pencil_dash_modifier_segment_remove = bpyopsobject.grease_pencil_dash_modifier_segment_remove
grease_pencil_dash_modifier_segment_move = bpyopsobject.grease_pencil_dash_modifier_segment_move

data_type_enum_items = bpy.types.Attribute.bl_rna.properties["data_type"].enum_items


# //* 0block_unreg_timer_hold_safe
# *//
# //* 0block_reg_timer_hold_safe
# *//
# //* 0block_unreg_timer_button_safe
# *//
# //* 0block_reg_timer_button_safe
# *//

def timer_hold():
    Admin.REDRAW()
    _timer_button_fn()
    # <<< 1copy (0block_reg_timer_button_safe,, $$)
    if timer_isreg(timer_button) == False:
        timer_reg(timer_button)

    # >>>

    #|
def timer_button():
    Admin.REDRAW()
    _timer_button_fn()
    return P.button_repeat_interval
    #|
def unreg_all_timer():
    if timer_isreg(timer_hold): timer_unreg(timer_hold)
    if timer_isreg(timer_button): timer_unreg(timer_button)

def poll_hard_disable(w): return not w.is_dark()
@ successResult
def append_rm_item_operator(items, rna):
    if hasattr(rna, "data"):
        if hasattr(rna.data, "operator"):
            operator_id = rna.data.operator
            keymap_category = rna.data.keymap_category
            keymaps = bpy.context.window_manager.keyconfigs.user.keymaps
            if keymap_category not in keymaps or keymaps[keymap_category].keymap_items.find_from_operator(operator_id) == None:
                items.append(("Assign Operator Shortcut", lambda: DropDownAddOpsShortcut(None, MOUSE, operator_id, keymap_category)))
            else:
                def remove_shortcut():
                    try:
                        keymaps = bpy.context.window_manager.keyconfigs.user.keymaps
                        if keymap_category in keymaps:
                            cat = keymaps[keymap_category].keymap_items
                            kmi = cat.find_from_operator(operator_id)
                            if kmi:
                                cat.remove(kmi)
                                report("Removed successfully. Requires manual saving of preferences")
                    except: pass

                items.append(("Edit Operator Shortcut", lambda: DropDownEditOpsShortcut(None, MOUSE, operator_id, keymap_category)))
                items.append(("Remove Operator Shortcut", remove_shortcut))
    #|
def append_rm_item_rotation_unit(self, items, rna):
    if hasattr(self, "evt_area_format") and hasattr(rna, "subtype") and rna.subtype == "EULER":
        items.append(("ui_format_toggle", self.evt_area_format))
    #|
@ catch
def append_rm_item_preview(self, items, rna):
    v = self.get()
    if isinstance(v, bpytypes.Material) or isinstance(v, bpytypes.Image) or isinstance(v, bpytypes.Texture):
        pass
    else: return
    if hasattr(self, "evt_area_preview"): items.append(("dd_preview", self.evt_area_preview))
    #|


#_c4#_c4#_c4#_c4
def C_evt_head(self, poll_library=True, evtkill=True):
    if evtkill:
        kill_evt_except()
    if hasattr(self, "poll") and self.poll(self) == False:
        return None, None
    pp = self.r_pp()
    self.pp = pp
    if not pp:
        return None, None
    ob = self.r_object()
    if not ob:
        return None, None
    if poll_library:
        if hasattr(ob, "is_editable") and not ob.is_editable:
            report(r_library_or_override_message(ob))
            return None, ob
    return pp, ob
    #|
def C_if_animatable(self, is_report=False):
    if hasattr(self.rna, "is_animatable") and not self.rna.is_animatable:
        if is_report:
            report("This property cannot be animated")
        return False
    return True
    #|

def C_r_dp(self, full=False):
    return f'{self.r_datapath_head(full)}{self.rna.identifier}'
    #|
def C_r_dp_gn(self, full=False):
    return f'{self.r_datapath_head(full)}["{escape_identifier(self.rna.identifier)}"]'
    #|
def C_evt_remove_from_keying_set(self, index=None):

    pp, ob = C_evt_head(self, poll_library=True)
    if pp is None: return
    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            index = "all"

    success, s = r_remove_from_keying_set(ob, self.r_dp(False), index=index)
    if s:
        DropDownOk(None, MOUSE, input_text=s)
    #|
def C_evt_add_to_keying_set(self, index=None):

    pp, ob = C_evt_head(self, poll_library=True)
    if pp is None: return
    if C_if_animatable(self, is_report=True) is False: return
    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            index = "all"

    success, s = r_add_to_keying_set(ob, self.r_dp(False), index=index)
    if s:
        DropDownOk(None, MOUSE, input_text=s)
    #|
def C_evt_copy_full_data_path(self, index=None):

    pp, ob = C_evt_head(self, poll_library=False)
    if pp is None: return
    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            bpy.context.window_manager.clipboard = self.r_dp(True)
            report("Full Data Path is copied to the clipboard")
            return

    bpy.context.window_manager.clipboard = f'{self.r_dp(True)}[{index}]'
    report("Full Data Path is copied to the clipboard")
    #|
def C_evt_copy_data_path(self, index=None):

    pp, ob = C_evt_head(self, poll_library=False)
    if pp is None: return
    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            bpy.context.window_manager.clipboard = self.r_dp(False)
            report("Data Path is copied to the clipboard")
            return

    bpy.context.window_manager.clipboard = f'{self.r_dp(False)}[{index}]'
    report("Data Path is copied to the clipboard")
    #|
def C_evt_paste_full_data_path_as_driver(self, index=None):

    pp, ob = C_evt_head(self, poll_library=True)
    if pp is None: return
    if C_if_animatable(self, is_report=True) is False: return
    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            fcs_index = set()
            if hasattr(self.w, "r_fcurve"):
                fcs_index = {r  for r, e in enumerate(self.w.r_fcurve()) if e}

            index = -1
            for r, e in enumerate(self.w.r_driver()):
                if r in fcs_index: continue
                if not e:
                    index = r
                    break

            if index == -1: index = len(self.get()) - 1

    if hasattr(self.w, "r_fcurve"):
        if self.w.r_fcurve()[index]:
            report("Unable to add driver when keyframe already exists")
            return

    success, ex = paste_full_data_path_as_driver_safe(
        bpy.context.window_manager.clipboard,
        self.w.r_driver()[index],
        self.r_datapath_head(),
        ob,
        self.rna,
        pp,
        index=index)

    if success is False: DropDownOk(None, MOUSE, input_text=f'Failed to add Driver.\n{ex}')
    #|
def C_evt_delete_driver(self, index=None):

    pp, ob = C_evt_head(self, poll_library=True)
    if pp is None: return
    if C_if_animatable(self, is_report=True) is False: return

    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            index = 0
            for r, e in enumerate(self.w.r_driver()):
                if e:
                    index = r
                    break

    dr = self.w.r_driver()[index]
    if dr: ob.animation_data.drivers.remove(dr)
    else:
        report("Driver not found")
        return

    array = self.get()
    for i, e in enumerate(array): array[i] = e
    update_scene_push("Delete Driver")

    # if type(ob) != bpy.types.Object: return
    # if r_md_driver_remove(ob, pp.name, self.rna.identifier, index=index): pass
    # else:
    #     report("Driver not found")
    #     return

    # array = self.get()
    # for i, e in enumerate(array): array[i] = e
    # update_scene_push("Delete Reference Driver")
    #|
def C_evt_delete_driver_all(self):

    pp, ob = C_evt_head(self, poll_library=True)
    if pp is None: return
    if C_if_animatable(self, is_report=True) is False: return
    has_driver = False
    for dr in self.w.r_driver():
        if dr:
            has_driver = True
            ob.animation_data.drivers.remove(dr)

    if has_driver == False:
        report("Driver not found")
        return

    array = self.get()
    for i, e in enumerate(array): array[i] = e
    update_scene_push("Delete Driver(s)")
    #|
def C_evt_add_driver(self, index=None, exp="var", replace=False, use_editor=False):

    pp, ob = C_evt_head(self, poll_library=True)
    if pp is None: return
    if C_if_animatable(self, is_report=True) is False: return
    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            index = 0
            for r, e in enumerate(self.w.r_driver()):
                if not e:
                    index = r
                    break

    if self.rna.identifier == "name":
        report('Cannot add driver on "Name" attribute')
        return
    if hasattr(self.w, "r_fcurve"):
        if self.w.r_fcurve()[index]:
            report("Unable to add driver when keyframe already exists")
            return
    if self.w.r_driver()[index]:
        if not replace:
            if use_editor:
                open_driver_editor_from(ob, self.r_dp(False), index=index)
            return

        ob.animation_data.drivers.remove(self.w.r_driver()[index])

    success, ex = add_new_driver(ob, self.rna, pp, index=index, exp=exp)

    if success is False:
        DropDownOk(None, MOUSE, input_text=f'Failed to add Driver.\n{ex}')
    elif use_editor and P.is_open_driver_editor:
        open_driver_editor_from(ob, self.r_dp(False), index=index)
    #|
def C_evt_clear_keyframe(self, index=None, evtkill=True):

    pp, ob = C_evt_head(self, poll_library=True, evtkill=evtkill)
    if pp is None: return
    if C_if_animatable(self, is_report=True) is False: return
    if not hasattr(self.w, "r_fcurve"): return

    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            for fc in self.w.r_fcurve():
                if fc: clear_keyframe(ob, fc, update_push=False)

            update_scene_push("Clear Keyframe(s)")
            return

    fc = self.w.r_fcurve()[index]
    if not fc:
        report("Keyframe not found")
        return

    success, ex = clear_keyframe(ob, fc)

    if success is False: DropDownOk(None, MOUSE, input_text=f'Failed to Clear Keyframe.\n{ex}')
    #|
def C_evt_delete_keyframe(self, index=None, evtkill=True):

    pp, ob = C_evt_head(self, poll_library=True, evtkill=evtkill)
    if pp is None: return
    if C_if_animatable(self, is_report=True) is False: return
    if not hasattr(self.w, "r_fcurve"): return

    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            for r, fc in enumerate(self.w.r_fcurve()):
                if fc: del_keyframe(ob, self.rna, pp, index=r, update_push=False)

            update_scene_push("Delete Keyframe(s)")
            return

    if not self.w.r_fcurve()[index]:
        report("Keyframe not found")
        return

    success, ex = del_keyframe(ob, self.rna, pp, index=index)

    if success is False: DropDownOk(None, MOUSE, input_text=f'Failed to Delete Keyframe.\n{ex}')
    #|
def C_evt_insert_keyframe(self, index=None, evtkill=True):

    pp, ob = C_evt_head(self, poll_library=True, evtkill=evtkill)
    if pp is None: return
    if C_if_animatable(self, is_report=True) is False: return
    if index == None:
        if hasattr(self, "active_index"):
            index = 0  if self.active_index == None else self.active_index
        else:
            is_success = False
            drs_index = set()
            if hasattr(self.w, "r_driver"):
                drs_index = {r  for r, e in enumerate(self.w.r_fcurve()) if e}
            for r in range(len(self.get())):
                if r not in drs_index:
                    success, ex = add_new_keyframe(ob, self.rna, pp, index=r, update_push=False)
                    if success: is_success = True

            if is_success is True: update_scene_push("Delete Keyframe(s)")
            return

    if hasattr(self.w, "r_driver") and self.w.r_driver()[index]:
        report("Unable to Insert Keyframe when Driver already exists")
        return

    success, ex = add_new_keyframe(ob, self.rna, pp, index=index)

    if success is False: DropDownOk(None, MOUSE, input_text=f'Failed to add Keyframe.\n{ex}')
    #|
def C_evt_area_format_gn(self):

    kill_evt_except()
    if self.unit == "ROTATION":
        if self.text_format.__name__.find("deg") == -1:
            self.text_format = UnitSystem.rs_format_deg
            self.rna.vmd_is_radian = False
        else:
            self.text_format = UnitSystem.format_float
            self.rna.vmd_is_radian = True

        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return

        for e, v in zip(self.blf_value, self.get()):
            e.unclip_text = v
            e.text = self.text_format(v)
        Admin.REDRAW()
    #|



#_c4#_c4#_c4#_c4

class StructPush:
    __slots__ = ()

    def evt_undo_push(self, undo_push, oldvalue):
        if isinstance(undo_push, tuple):
            oldvalue = undo_push[0]
            undo_push = True

        if undo_push:
            newvalue = self.get()
            if oldvalue == newvalue: return

            if hasattr(newvalue, "foreach_get"):
                newvalue = tuple(newvalue)

            ed_undo_push(message=f'{self.rna.name} :  {newvalue.name  if hasattr(newvalue, "name") else newvalue}')
        #|
    #|
    #|
class StructPushIndex:
    __slots__ = ()

    def evt_undo_push(self, undo_push, oldvalue, index):
        if isinstance(undo_push, tuple):
            oldvalue = undo_push[0]
            undo_push = True

        if undo_push:
            newvalue = self.get(index)
            if oldvalue == newvalue: return

            rna = self.rna[index]  if hasattr(self.rna, "__len__") else self.rna
            ed_undo_push(message=f'{rna.name} :  {newvalue.name  if hasattr(newvalue, "name") else newvalue}')
        #|
    #|
    #|
class StructUndoPushPref:
    __slots__ = ()

    def evt_undo_push(self, undo_push, oldvalue):
        if isinstance(undo_push, tuple):
            oldvalue = undo_push[0]
            undo_push = True

        if undo_push:
            newvalue = getattr(self.pp, self.rna.identifier)
            if oldvalue == newvalue: return

            PREF_HISTORY.push_context = HistoryValue(oldvalue, newvalue,
                lambda v: self.set(v, refresh=True, undo_push=False),
                self.rna.name)
            PREF_HISTORY.push()
        #|
    #|
    #|
class StructUndoPushPrefVector:
    __slots__ = ()

    def evt_undo_push(self, undo_push, oldvalue):
        if isinstance(undo_push, tuple):
            oldvalue = list(undo_push)
            undo_push = True

        if undo_push:
            newvalue = [e  for e in getattr(self.pp, self.rna.identifier)]
            if oldvalue == newvalue: return
            PREF_HISTORY.push_context = HistoryValue(oldvalue, newvalue,
                lambda v: self.set(v, (0, len(newvalue)), refresh=True, undo_push=False),
                self.rna.name)
            PREF_HISTORY.push()
        #|
    #|
    #|
class StructUndoPushPrefColor:
    __slots__ = ()

    def evt_undo_push(self, undo_push, oldvalue):
        if isinstance(undo_push, tuple):
            oldvalue = list(undo_push)
            undo_push = True

        if undo_push:
            newvalue = [e  for e in getattr(self.pp, self.rna.identifier)]
            if oldvalue == newvalue: return
            def set_value(v):
                self.set(v, (0, len(newvalue)), refresh=True, undo_push=False)
                Admin.REDRAW()
                #|
            PREF_HISTORY.push_context = HistoryValue(oldvalue, newvalue,
                set_value,
                self.rna.name)
            PREF_HISTORY.push()
        #|
    #|
    #|
class StructButtonGetSetVector:
    __slots__ = ()

    def get(self, index=None):
        if index == None: return getattr(self.pp, self.rna.identifier)
        elif isinstance(index, int): return getattr(self.pp, self.rna.identifier)[index]
        else: return getattr(self.pp, self.rna.identifier)[index[0] : index[1]]
        #|
    def set(self, v, index, refresh=True, undo_push=True):
        array = getattr(self.pp, self.rna.identifier)
        oldvalue = [e  for e in array]
        if isinstance(index, int): array[index] = v
        else:
            l = list(array)
            l[index[0] : index[1]] = v
            array[:] = l
            # crash when array is EULER
            # array[index[0] : index[1]] = v
        if refresh: update_data()

        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
        #|
    def evt_undo_push(self, undo_push, oldvalue): pass
    #|
    #|
class StructPreview:
    __slots__ = ()

    def evt_area_preview(self):

        kill_evt_except()
        mat = self.get()
        if mat:
            preview_datablock(mat)
        #|
    #|
    #|

#_c4#_c4#_c4#_c4
class Title:
    __slots__ = 'blf_title', 'w'

    def __init__(self, title):
        self.blf_title = BlfClipColor(unclip_text=title, color=COL_block_fg)
        #|

    def init_bat(self, LL, RR, TT):
        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        e.x = LL + SIZE_border[3]

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, e.x, RR - D_SIZE['font_main_dx'])
        return TT - D_SIZE['widget_full_h']
        #|
    def set_text(self, s):
        e = self.blf_title
        e.unclip_text = s
        e.text = s
        #|
    def r_height(self, width): return D_SIZE['widget_full_h']

    def is_dark(self): return self.blf_title.color == COL_block_fg_ignore
    def dark(self):
        self.blf_title.color = COL_block_fg_ignore
        #|
    def light(self):
        self.blf_title.color = COL_block_fg
        #|

    def inside(self, mouse): return False
    def inside_evt(self): pass
    def outside_evt(self): pass

    def modal(self): return False

    def dxy(self, dx, dy):
        self.blf_title.x += dx
        self.blf_title.y += dy
        #|
    def draw_box(self): pass
    def draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def get(self): pass
    def set(self, v, refresh=True, undo_push=True): pass

    def upd_data(self): pass
    #|
    #|
class TitleR(Title):
    __slots__ = ()

    def init_bat(self, LL, RR, TT):
        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        R0 = RR - D_SIZE['font_main_title_offset']

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])
        return TT - D_SIZE['widget_full_h']
        #|
    #|
    #|
class ButtonSep:
    __slots__ = 'w', 'factor', 'box_button'

    def __init__(self, factor=1):
        self.factor = factor
        self.box_button = GpuBox()
        #|

    def init_bat(self, L, R, T):
        B = T - round(SIZE_button[2] * self.factor)
        self.box_button.LRBT(L, R, B, T)
        return B
    def r_height(self, width): return round(SIZE_button[2] * self.factor)

    def inside(self, mouse): return False
    def inside_evt(self): pass
    def outside_evt(self): pass
    def dark(self): pass
    def light(self): pass

    def modal(self): return False

    def dxy(self, dx, dy):
        self.box_button.dxy(dx, dy)
        #|
    def draw_box(self): pass
    def draw_blf(self): pass

    def get(self): pass
    def set(self, v, refresh=True, undo_push=True): pass

    def upd_data(self): pass
    #|
    #|
class ButtonFold:
    __slots__ = (
        'w',
        'box_button',
        'is_trigger_enable')

    def __init__(self, w):
        self.w = w
        #|

    def r_height(self, width): return SIZE_widget[0]

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        self.is_trigger_enable = True

        if self.w.is_fold:
            if isinstance(self.box_button, GpuImg_fold):
                self.box_button = GpuImg_fold_focus(*self.box_button.r_LRBT())
                self.box_button.upd()
                Admin.REDRAW()
        else:
            if isinstance(self.box_button, GpuImg_unfold):
                self.box_button = GpuImg_unfold_focus(*self.box_button.r_LRBT())
                self.box_button.upd()
                Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.w.is_fold:
            if isinstance(self.box_button, GpuImg_fold_focus):
                self.box_button = GpuImg_fold(*self.box_button.r_LRBT())
                self.box_button.upd()
                Admin.REDRAW()
        else:
            if isinstance(self.box_button, GpuImg_unfold_focus):
                self.box_button = GpuImg_unfold(*self.box_button.r_LRBT())
                self.box_button.upd()
                Admin.REDRAW()
        #|

    def modal(self):
        if EVT_TYPE[1] == 'RELEASE': self.is_trigger_enable = True

        if self.is_trigger_enable is True:
            if TRIGGER['ui_fold_recursive_toggle']():
                self.is_trigger_enable = False
                if is_first_press('ui_fold_recursive_toggle') == False:
                    self.evt_fold_toggle(override=_last_bool_state[0], recursive=True)
                else:
                    self.evt_fold_toggle(recursive=True)
                return True

            if TRIGGER['ui_fold_toggle']():
                self.is_trigger_enable = False
                if is_first_press('ui_fold_toggle') == False:
                    self.evt_fold_toggle(override=_last_bool_state[0])
                else:
                    self.evt_fold_toggle()
                return True

        return False
        #|

    def evt_fold_toggle(self, override=None, recursive=False):
        if override == None:
            self.w.evt_fold_toggle(kill_evt=False, recursive=recursive)
        elif override == True:
            self.w.evt_fold(kill_evt=False, recursive=recursive)
        else:
            self.w.evt_unfold(kill_evt=False, recursive=recursive)

        if self.inside(MOUSE):
            if self.w.is_fold:
                if isinstance(self.box_button, GpuImg_fold):
                    self.box_button = GpuImg_fold_focus(*self.box_button.r_LRBT())
                    self.box_button.upd()
                    Admin.REDRAW()
            else:
                if isinstance(self.box_button, GpuImg_unfold):
                    self.box_button = GpuImg_unfold_focus(*self.box_button.r_LRBT())
                    self.box_button.upd()
                    Admin.REDRAW()
        else:
            if self.w.is_fold:
                if isinstance(self.box_button, GpuImg_fold_focus):
                    self.box_button = GpuImg_fold(*self.box_button.r_LRBT())
                    self.box_button.upd()
                    Admin.REDRAW()
            else:
                if isinstance(self.box_button, GpuImg_unfold_focus):
                    self.box_button = GpuImg_unfold(*self.box_button.r_LRBT())
                    self.box_button.upd()
                    Admin.REDRAW()
        #|
    #|
    #|
class ButtonBool:
    __slots__ = (
        'w',
        'rna',
        'pp',
        'r_pp',
        'r_object',
        'r_datapath_head',
        'box_button',
        'is_trigger_enable',
        'set_callback',
        'poll')

    def __init__(self, w, rna, pp):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuCheckbox(value=False if self.pp is None else self.get())
        #|

    def init_bat(self, L, R, T):
        B = T - D_SIZE['widget_bool_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        return B
        #|
    def r_height(self, width): return D_SIZE['widget_full_h']
    def r_default_value(self): return self.rna.default

    def is_dark(self): return self.box_button.is_dark()
    def dark(self): self.box_button.dark()
    def light(self): self.box_button.light()

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        Admin.REDRAW()
        if self.is_dark() is False: self.box_button.color = COL_box_val_bool_fo
        self.is_trigger_enable = True
        #|
    def outside_evt(self):
        Admin.REDRAW()
        if self.is_dark() is False: self.box_button.color = COL_box_val_bool
        #|

    def modal(self):
        allow_trigger = self.is_trigger_enable
        if not allow_trigger:
            if EVT_TYPE[1] == 'RELEASE': self.is_trigger_enable = True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if allow_trigger:
            if TRIGGER['click']():
                if self.pp is None: return True
                self.is_trigger_enable = False
                if is_first_press('click') == False:
                    self.set(_last_bool_state[0])
                else:
                    boo = not self.get()
                    self.set(boo)
                    _last_bool_state[0] = boo
                Admin.REDRAW()
                return True
        return False
        #|

    def to_modal_rm(self):


        DropDownRMKeymap(self, MOUSE, [
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ], override_name={
            "dd_paste": "Paste",
            "dd_copy": "Copy",
        }, title=self.rna.name)
        #|

    @ catch
    def evt_area_cut(self, is_report=True):
        self.evt_area_copy(is_report)
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        kill_evt_except()
        bpy.context.window_manager.clipboard = f'{self.get()}'
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        Admin.REDRAW()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        s = s.strip()
        if s in {'True', 'true', '1', '1.0'}:
            self.set(True)
            return
        elif s in {'False', 'false', '0', '0.0'}:
            self.set(False)
            return

        try:
            v = calc_vec(s)[0]
            self.set(bool(v))
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_reset_single(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_reset_all(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_detail(self):

        kill_evt_except()
        Detail(Detail.r_rna_info(self.rna))
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        #|
    def draw_blf(self): pass

    def get(self):
        return getattr(self.pp, self.rna.identifier)
        #|
    def set(self, v, refresh=True, undo_push=True):
        oldvalue = getattr(self.pp, self.rna.identifier)
        setattr(self.pp, self.rna.identifier, v)
        if refresh: update_data()

        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
        #|
    def evt_undo_push(self, undo_push, oldvalue): pass

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        self.box_button.value = getattr(self.pp, self.rna.identifier)
        #|
    #|
    #|
class ButtonBoolXYZ(                # StructButtonGetSetVector  ButtonBool                      
    StructButtonGetSetVector, ButtonBool):
    __slots__ = 'blf_value', 'active_index', 'old_value'

    def __init__(self, w, rna, pp):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp

        self.box_button = [GpuButtonBool(), GpuButtonBool(), GpuButtonBool()]
        self.blf_value = [
            BlfColor("X", color=COL_box_button_fg),
            BlfColor("Y", color=COL_box_button_fg),
            BlfColor("Z", color=COL_box_button_fg)]

        self.old_value = None
        #|

    def init_bat(self, L, R, T):
        # <<< 1copy (0block_ButtonBoolArrayX_init_bat,, $$)
        blfSize(FONT0, D_SIZE['font_main'])
        box_button = self.box_button
        blf_value = self.blf_value
        widget_rim = SIZE_border[3]
        full_h = D_SIZE['widget_full_h']
        width = (R - L) // len(box_button)

        B = T - full_h
        y = B + widget_rim + D_SIZE['font_main_dy']

        for r in range(len(box_button) - 1):
            R0 = L + width
            box_button[r].LRBT_upd(L, R0, B, T, widget_rim)
            e = blf_value[r]
            e.y = y
            e.x = floor((R0 + L - blfDimen(FONT0, e.text)[0]) / 2)
            L = R0

        box_button[-1].LRBT_upd(L, R, B, T, widget_rim)
        e = blf_value[-1]
        e.y = y
        e.x = floor((R + L - blfDimen(FONT0, e.text)[0]) / 2)

        self.upd_data()
        return B
        # >>>
        #|
    def r_height(self, width): return D_SIZE['widget_full_h']
    def r_default_array(self): return self.rna.default_array

    def is_dark(self): return self.box_button[0].is_dark()
    def dark(self):
        for e in self.box_button: e.dark()
        for e in self.blf_value: e.color = COL_box_button_fg_ignore
        #|
    def light(self):
        for e in self.box_button: e.light()
        for e in self.blf_value: e.color = COL_box_button_fg
        #|

    def r_focus_index(self, mouse):
        for r, e in enumerate(self.box_button):
            if e.inbox(mouse): return r
        return None
        #|
    def fn(self, i):

        Admin.REDRAW()
        if is_first_press('click') == False:
            self.set(_last_bool_state[0], i)
        else:
            boo = not self.get(i)
            self.set(boo, i)
            _last_bool_state[0] = boo
        #|

    def focus_button(self, i):
        if self.box_button[i].state == 0:
            self.box_button[i].set_state_off_focus()
        #|
    def unfocus_button(self, i):
        if self.box_button[i].state == 1:
            self.box_button[i].set_state_off()
        #|
    def turnon_button(self, i):
        if self.box_button[i].state in {0, 1}:
            self.box_button[i].set_state_on()
        #|
    def turnoff_button(self, i):
        if self.box_button[i].state == 2:
            self.box_button[i].set_state_off()
        #|

    def inside(self, mouse):
        box_button = self.box_button
        if mouse[0] < box_button[0].L: return False
        if mouse[0] > box_button[-1].R: return False
        if mouse[1] > box_button[0].T: return False
        if mouse[1] < box_button[-1].B: return False
        return True
        #|
    def inside_evt(self):
        self.active_index = self.r_focus_index(MOUSE)
        if self.active_index != None:
            self.focus_button(self.active_index)
            Admin.REDRAW()
        self.is_trigger_enable = True
        #|
    def outside_evt(self):
        if hasattr(self, "active_index"):
            if self.active_index != None:
                self.unfocus_button(self.active_index)
                Admin.REDRAW()
        #|

    def modal(self):
        allow_trigger = self.is_trigger_enable
        if not allow_trigger:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                self.is_trigger_enable = True

        i = self.r_focus_index(MOUSE)
        if i != self.active_index:

            if self.active_index != None:
                self.unfocus_button(self.active_index)
                Admin.REDRAW()

            self.active_index = i
            self.is_trigger_enable = True

            if i != None:
                self.focus_button(i)
                Admin.REDRAW()

        if i == None: return False

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if allow_trigger:
            if TRIGGER['click']():
                self.is_trigger_enable = False
                self.fn(i)
                return True
        return False
        #|

    def to_modal_rm(self):


        DropDownRMKeymap(self, MOUSE, [
            ("dd_cut", self.evt_area_cut),
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_all", self.evt_area_reset_all),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ], override_name={
            "dd_cut": "Copy Array",
            "dd_paste": "Paste",
            "dd_copy": "Copy",
        }, title=self.rna.name)
        #|

    @ catch
    def evt_area_cut(self, is_report=True):

        kill_evt_except()
        s = ""
        for e in self.get(): s += f'{value_to_display(e)}, '

        bpy.context.window_manager.clipboard = s[: -2]
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        if self.active_index == None:
            self.evt_area_cut(is_report)
            return

        kill_evt_except()
        bpy.context.window_manager.clipboard = value_to_display(self.get()[self.active_index])
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            Admin.REDRAW()
            if s.strip().startswith("#"):
                self.set(s, 0  if self.active_index == None else self.active_index)
                return

            array = calc_vec(s)
            ll = len(array)
            if ll == 1 and self.active_index != None:
                self.set(array[0], self.active_index)
            else:
                if ll > self.rna.array_length: array = array[: self.rna.array_length]
                self.set([int(round_dec(v))  for v in array], (0, ll))
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_reset_single(self):

        kill_evt_except()
        Admin.REDRAW()
        if self.active_index == None:
            self.set(self.r_default_array(), (0, self.rna.array_length))
        else:
            i = self.active_index
            self.set(self.r_default_array()[i], i)
        #|
    @ catch
    def evt_area_reset_all(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_array(), (0, self.rna.array_length))
        #|

    def dxy(self, dx, dy):
        for e in self.box_button: e.dxy_upd(dx, dy)
        for e in self.blf_value:
            e.x += dx
            e.y += dy
        #|
    def draw_box(self):
        for e in self.box_button: e.bind_draw()
        #|
    def draw_blf(self):
        blfSize(FONT0, D_SIZE['font_main'])
        for e in self.blf_value:
            blfColor(FONT0, *e.color)
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.old_value == [e for e in self.get()]: return

        v = [e for e in self.get()]

        for r, e in enumerate(v):
            self.turnon_button(r)  if e else self.turnoff_button(r)

        self.old_value = v
        #|
    #|
    #|
class ButtonInt:
    __slots__ = (
        'w',
        'rna',
        'pp',
        'r_pp',
        'r_object',
        'r_datapath_head',
        'box_button',
        'box_media',
        'blf_subtype',
        'blf_value',
        'text_format',
        'draw_box',
        'draw_blf',
        'dxy',
        'to_modal_drag_callfront',
        'end_modal_drag_callback',
        'set_callback',
        'poll')

    # /* 0block_ButtonInt_init
    def __init__(self, w, rna, pp, subtype_override=None):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_val, COL_box_val_rim)
        self.text_format = D_format["INT"]

        if self.pp is None:
            self.blf_value = BlfClipColor("", None, 0, 0, COL_box_val_fg)
        else:
            v = self.get()
            self.blf_value = BlfClipColor(self.text_format(v), v, 0, 0, COL_box_val_fg)

        if subtype_override is None:
            if rna.subtype == "PIXEL":
                self.draw_blf = self.i_draw_blf_subtype
                self.dxy = self.i_dxy_subtype
                self.blf_subtype = BlfColor("px", 0, 0, COL_box_button_fg_info)
            else:
                self.draw_blf = self.i_draw_blf
                self.dxy = self.i_dxy
        else:
            self.draw_blf = self.i_draw_blf_subtype
            self.dxy = self.i_dxy_subtype
            self.blf_subtype = BlfColor(subtype_override[0], 0, 0, COL_box_button_fg_info)

        self.draw_box = self.i_draw_box
    # */

    def init_bat(self, L, R, T):
        widget_rim = SIZE_border[3]
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, widget_rim)
        self.blf_value.x = L + widget_rim
        self.blf_value.y = B + widget_rim + D_SIZE['font_main_dy']

        # /* 0block_ButtonInt_init_subtype
        if hasattr(self, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            self.blf_subtype.y = T - SIZE_border[3] - D_SIZE['font_label_dT']
            self.blf_subtype.x = L - D_SIZE['font_label_dx'] - ceil(blfDimen(FONT0, self.blf_subtype.text)[0])
        # */
        return B
        #|
    def r_height(self, width): return D_SIZE['widget_full_h']
    def r_default_value(self): return self.rna.default

    def is_dark(self): return self.blf_value.color == COL_box_val_fg_ignore
    def dark(self):
        if self.box_button.color == COL_box_val:
            self.box_button.color = COL_box_val_ignore
            self.box_button.color_rim = COL_box_val_rim_ignore
            self.blf_value.color = COL_box_val_fg_ignore
            Admin.REDRAW()
        #|
    def light(self):
        if self.box_button.color == COL_box_val_ignore:
            self.box_button.color = COL_box_val
            self.box_button.color_rim = COL_box_val_rim
            self.blf_value.color = COL_box_val_fg
            Admin.REDRAW()
        #|

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        _valboxdata[0] = 0
        if self.is_dark(): pass
        else:
            self.box_button.color = COL_box_val_fo
            Admin.REDRAW()
        #|
    def outside_evt(self):
        self.draw_box = self.i_draw_box
        Admin.REDRAW()
        if self.is_dark(): pass
        else:
            self.box_button.color = COL_box_val
        #|

    def modal(self):
        if MOUSE[0] < self.box_button.inner[0] + SIZE_widget[0]:
            if _valboxdata[0] == 0:

                Admin.REDRAW()
                self.draw_box = self.i_draw_box_media
                self.box_media = GpuImg_valuebox_left()
                e = self.box_button.inner
                self.box_media.LRBT_upd(e[0], e[0] + SIZE_widget[0], e[2], e[3])
                _valboxdata[0] = 1
        elif MOUSE[0] >= self.box_button.inner[1] - SIZE_widget[0]:
            if _valboxdata[0] == 0:

                Admin.REDRAW()
                self.draw_box = self.i_draw_box_media
                self.box_media = GpuImg_valuebox_right()
                e = self.box_button.inner
                self.box_media.LRBT_upd(e[1] - SIZE_widget[0], e[1], e[2], e[3])
                _valboxdata[0] = 2
        else:
            if _valboxdata[0] != 0:
                Admin.REDRAW()
                self.draw_box = self.i_draw_box
                _valboxdata[0] = 0

        # /* 0block_ButtonInt_modal_trigger
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['valbox_drag']():
            self.to_modal_drag()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            if _valboxdata[0] == 0: self.to_modal_drag_pre()
            elif _valboxdata[0] == 1: self.to_modal_media_left()
            else: self.to_modal_media_right()
            return True
        # */
        return False
        #|

    def to_modal_drag_pre(self, override=None):

        _blf_value = self.blf_value

        end_trigger = r_end_trigger('valbox_drag'  if override == "POST" else 'click')
        mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")
        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
        _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
        _xy = [0]
        _valbox_drag_fac = P.valbox_drag_fac_int
        _value_data = {'confirm': True}
        _set = self.set
        _th_drag = P.th_drag

        if isinstance(_blf_value, list):
            if hasattr(_blf_value[0], "unclip_text") and is_value(_blf_value[0].unclip_text): pass
            else: return

            _value_data["values"] = [(e.unclip_text, e.text)  for e in _blf_value]

            if self.is_dark() is False: self.box_active.color = COL_box_val_active
            if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()
        elif hasattr(_blf_value, "unclip_text") and is_value(_blf_value.unclip_text):
            _value_data["values"] = [(_blf_value.unclip_text, _blf_value.text)]

            if self.is_dark() is False: self.box_button.color = COL_box_val_active
            if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()
        else: return

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                _value_data["confirm"] = None
                w_head.fin()
                self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            if abs(_xy[0]) >= _th_drag:
                _xy[0] = 0
                _REDRAW()

                w_head.modal = modal_drag

            mouseloop()

        def modal_drag():
            _REDRAW()

            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = False
                w_head.fin()
                return
            if end_trigger():
                w_head.fin()
                return

            dx, dy = r_dxy_mouse()
            if _TRIGGER_drag_fast(): dx *= 10
            elif _TRIGGER_drag_slow(): dx *= 0.1

            _xy[0] += dx * _valbox_drag_fac
            travel = _xy[0]
            if travel >= 1:
                dx = floor(travel)
                _xy[0] -= dx
            elif travel <= -1:
                dx = ceil(travel)
                _xy[0] -= dx
            else:
                mouseloop()
                return

            # /* 0block_ButtonInt_modal_drag_set
            _set(_blf_value.unclip_text + dx, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # */
            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
            mouseloop_end()
            kill_evt_except()
            if self.is_dark():
                self.box_button.color = COL_box_val_ignore
            else:
                self.box_button.color = COL_box_val_fo  if self.box_button.inbox(MOUSE) else COL_box_val

            if _value_data["confirm"] is None: pass
            elif _value_data["confirm"] == True:
                _set(_blf_value.unclip_text, undo_push=_value_data["values"][0])
            else:
                o = _value_data["values"][0]
                _blf_value.unclip_text = o[0]
                _blf_value.text = o[1]

            if hasattr(self, "end_modal_drag_callback"): self.end_modal_drag_callback()

            MODAL_DRAG_STATE[0] = -1

        if override == "POST":
            w_head = Head(self, modal_drag, end_modal_release)
        elif override == "MEDIA":
            def modal_media():
                _REDRAW()
                if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc() or end_trigger():
                    w_head.fin()
                    return

                dx, dy = r_dxy_mouse()
                _xy[0] += dx
                if abs(_xy[0]) >= P.th_drag:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                    _xy[0] = 0
                    Admin.REDRAW()
                    self.draw_box = self.i_draw_box
                    _valboxdata[0] = 0
                    w_head.modal = modal_drag

                mouseloop()

            w_head = Head(self, modal_media, end_modal_release)
        else:
            w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    def to_modal_drag(self):

        self.to_modal_drag_pre(override="POST")
        #|
    def to_modal_media_left(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0block_ButtonInt_modal_drag_set,, ${'+ dx':'- 1'}$)
            _set(_blf_value.unclip_text - 1, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    def to_modal_media_right(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0block_ButtonInt_modal_drag_set,, ${'+ dx':'+ 1'}$)
            _set(_blf_value.unclip_text + 1, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    def to_dropdown(self):

        o = self.blf_value
        DropDownVal(self, self.box_button.r_LRBT(), o.text, o.unclip_text, self.rna)
        #|

    def to_modal_rm(self):

        items = [
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ]

        if hasattr(self.rna, "subtype") and self.rna.subtype == "ANGLE":
            items.append(("ui_format_toggle", self.evt_area_format))
        append_rm_item_operator(items, self.rna)

        DropDownRMKeymap(self, MOUSE, items, title=self.rna.name)
        #|

    @ catch
    def evt_area_cut(self, is_report=True):
        self.evt_area_copy(is_report)
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        kill_evt_except()
        bpy.context.window_manager.clipboard = value_to_display(self.blf_value.unclip_text)
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            if s.strip().startswith("#"):
                self.set(s)
            else:
                v = calc_vec(s)[0]
                self.set(int(round_dec(v)))
            Admin.REDRAW()
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_reset_single(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_reset_all(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_detail(self):

        kill_evt_except()
        Detail(Detail.r_rna_info(self.rna))
        #|
    def evt_area_format(self): pass

    def i_dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        if self.draw_box == self.i_draw_box_media: self.box_media.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def i_dxy_subtype(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        if self.draw_box == self.i_draw_box_media: self.box_media.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_subtype.x += dx
        self.blf_subtype.y += dy
        #|
    def i_draw_box(self):
        self.box_button.bind_draw()
        #|
    def i_draw_box_media(self):
        self.box_button.bind_draw()
        self.box_media.bind_draw()
        #|
    def i_draw_blf(self):
        e = self.blf_value
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|
    def i_draw_blf_subtype(self):
        e = self.blf_value
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        e = self.blf_subtype
        blfSize(FONT0, D_SIZE['font_label'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def get(self):
        return getattr(self.pp, self.rna.identifier)
        #|
    def set(self, v, refresh=True, undo_push=True):
        oldvalue = getattr(self.pp, self.rna.identifier)
        setattr(self.pp, self.rna.identifier, v)
        if refresh: update_data()

        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
        #|
    def evt_undo_push(self, undo_push, oldvalue): pass

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return


        v = getattr(self.pp, self.rna.identifier)
        self.blf_value.unclip_text = v
        self.blf_value.text = self.text_format(v)
        #|
    #|
    #|
class ButtonFloat(                  # ButtonFloat                                               
    ButtonInt):
    __slots__ = ()

    # <<< 1copy (0block_ButtonInt_init,, ${'"INT"':'rna.unit'}$)
    def __init__(self, w, rna, pp, subtype_override=None):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_val, COL_box_val_rim)
        self.text_format = D_format[rna.unit]

        if self.pp is None:
            self.blf_value = BlfClipColor("", None, 0, 0, COL_box_val_fg)
        else:
            v = self.get()
            self.blf_value = BlfClipColor(self.text_format(v), v, 0, 0, COL_box_val_fg)

        if subtype_override is None:
            if rna.subtype == "PIXEL":
                self.draw_blf = self.i_draw_blf_subtype
                self.dxy = self.i_dxy_subtype
                self.blf_subtype = BlfColor("px", 0, 0, COL_box_button_fg_info)
            else:
                self.draw_blf = self.i_draw_blf
                self.dxy = self.i_dxy
        else:
            self.draw_blf = self.i_draw_blf_subtype
            self.dxy = self.i_dxy_subtype
            self.blf_subtype = BlfColor(subtype_override[0], 0, 0, COL_box_button_fg_info)

        self.draw_box = self.i_draw_box
    # >>>

    def to_modal_drag_pre(self, override=None):

        _blf_value = self.blf_value

        end_trigger = r_end_trigger('valbox_drag'  if override == "POST" else 'click')
        mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")
        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
        _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
        _xy = [0]
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _value_data = {'confirm': True}
        _set = self.set
        _th_drag = P.th_drag

        if isinstance(_blf_value, list):
            if hasattr(_blf_value[0], "unclip_text") and is_value(_blf_value[0].unclip_text): pass
            else: return

            _value_data["values"] = [(e.unclip_text, e.text)  for e in _blf_value]

            if self.is_dark() is False: self.box_active.color = COL_box_val_active
            if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()
        elif hasattr(_blf_value, "unclip_text") and is_value(_blf_value.unclip_text):
            _value_data["values"] = [(_blf_value.unclip_text, _blf_value.text)]

            if self.is_dark() is False: self.box_button.color = COL_box_val_active
            if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()
        else: return

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                _value_data["confirm"] = None
                w_head.fin()
                self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            if abs(_xy[0]) >= _th_drag:
                _xy[0] = 0
                _REDRAW()

                w_head.modal = modal_drag

            mouseloop()

        def modal_drag():
            _REDRAW()

            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = False
                w_head.fin()
                return
            if end_trigger():
                w_head.fin()
                return

            dx, dy = r_dxy_mouse()
            if _TRIGGER_drag_fast(): dx *= _valbox_drag_fac * 10
            elif _TRIGGER_drag_slow(): dx *= _valbox_drag_fac * 0.1
            else: dx *= _valbox_drag_fac

            # /* 0block_ButtonFloat_modal_drag_set
            try: v_float = _blf_value.unclip_text + dx
            except:
                mouseloop()
                return

            _set(v_float, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # */
            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
            mouseloop_end()
            kill_evt_except()
            if self.is_dark():
                self.box_button.color = COL_box_val_ignore
            else:
                self.box_button.color = COL_box_val_fo  if self.box_button.inbox(MOUSE) else COL_box_val

            if _value_data["confirm"] is None: pass
            elif _value_data["confirm"] == True:
                _set(_blf_value.unclip_text, undo_push=_value_data["values"][0])
            else:
                o = _value_data["values"][0]
                _blf_value.unclip_text = o[0]
                _blf_value.text = o[1]

            if hasattr(self, "end_modal_drag_callback"): self.end_modal_drag_callback()

            MODAL_DRAG_STATE[0] = -1

        if override == "POST":
            w_head = Head(self, modal_drag, end_modal_release)
        elif override == "MEDIA":
            def modal_media():
                _REDRAW()
                if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc() or end_trigger():
                    w_head.fin()
                    return

                dx, dy = r_dxy_mouse()
                _xy[0] += dx
                if abs(_xy[0]) >= P.th_drag:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                    _xy[0] = 0
                    Admin.REDRAW()
                    self.draw_box = self.i_draw_box
                    _valboxdata[0] = 0
                    w_head.modal = modal_drag

                mouseloop()

            w_head = Head(self, modal_media, end_modal_release)
        else:
            w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    def to_modal_media_left(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0block_ButtonFloat_modal_drag_set,, ${'+ dx':'- _valbox_drag_fac', 'mouseloop()':''}$)
            try: v_float = _blf_value.unclip_text - _valbox_drag_fac
            except:
                
                return

            _set(v_float, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    def to_modal_media_right(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0block_ButtonInt_modal_drag_set,, ${'+ dx':'+ _valbox_drag_fac', 'mouseloop()':''}$)
            _set(_blf_value.unclip_text + _valbox_drag_fac, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    @ catch
    def evt_area_copy(self, is_report=True):

        kill_evt_except()
        bpy.context.window_manager.clipboard = value_to_display(
            self.blf_value.unclip_text / r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format))
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            if s.strip().startswith("#"):
                self.set(s)
            else:
                self.set(calc_vec(s)[0] * r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format))
            Admin.REDRAW()
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_format(self):

        kill_evt_except()
        unit = self.unit  if hasattr(self, "unit") else self.rna.unit
        if unit == "ROTATION":
            if self.text_format.__name__.find("deg") == -1:
                self.text_format = UnitSystem.rs_format_deg
            else:
                self.text_format = UnitSystem.format_float

            if hasattr(self, "r_pp"): self.pp = self.r_pp()
            if self.pp is None: return
            v = self.get()
            self.blf_value.unclip_text = v
            self.blf_value.text = self.text_format(v)
            Admin.REDRAW()
        #|
    #|
    #|
class ButtonIntVector(              # StructButtonGetSetVector  ButtonInt                       
    StructButtonGetSetVector, ButtonInt):
    __slots__ = 'active_index', 'box_active', 'array_length'

    # /* 0block_ButtonIntVector_init
    def __init__(self, w, rna, pp, subtype_override=None):
        self.w = w
        self.rna = rna
        self.array_length = rna.array_length

        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp

        self.box_button = GpuRim(COL_box_val, COL_box_val_rim)
        self.box_active = GpuBox(COL_box_val_fo)
        self.text_format = D_format["INT"]
        vv = getattr(self.pp, rna.identifier)
        self.blf_value = [BlfClip(self.text_format(v), v)  for v in vv]
        self.blf_value[0].color = COL_box_val_fg

        if subtype_override is None:
            if rna.subtype in D_subtype_display:
                self.draw_blf = self.i_draw_blf_subtype
                self.dxy = self.i_dxy_subtype
                self.blf_subtype = [Blf(tx)  for _, tx in zip(vv, D_subtype_display[rna.subtype])]
                self.blf_subtype[0].color = COL_box_button_fg_info
            else:
                self.draw_blf = self.i_draw_blf
                self.dxy = self.i_dxy
        else:
            self.draw_blf = self.i_draw_blf_subtype
            self.dxy = self.i_dxy_subtype
            self.blf_subtype = [Blf(tx)  for _, tx in zip(vv, subtype_override)]
            self.blf_subtype[0].color = COL_box_button_fg_info

        self.draw_box = self.i_draw_box
        self.active_index = None
    # */

    def init_bat(self, L, R, T):
        widget_rim = SIZE_border[3]
        h = SIZE_widget[0]
        x = L + widget_rim
        y = T - widget_rim - D_SIZE['font_main_dT']
        for e in self.blf_value:
            e.x = x
            e.y = y
            y -= h

        B = T - D_SIZE['widget_full_h'] - (self.array_length - 1) * h
        self.box_button.LRBT_upd(L, R, B, T, widget_rim)

        if hasattr(self, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            y = self.box_button.inner[3] - D_SIZE['font_label_dT']
            for e in self.blf_subtype:
                e.y = y
                y -= h
                e.x = L - D_SIZE['font_label_dx'] - ceil(blfDimen(FONT0, e.text)[0])
        return B
        #|
    def r_height(self, width): return D_SIZE['widget_full_h'] + (self.array_length - 1) * SIZE_widget[0]
    def r_default_array(self): return self.rna.default_array

    def is_dark(self): return self.blf_value[0].color == COL_box_val_fg_ignore
    def dark(self):
        if self.box_button.color == COL_box_val:
            self.box_button.color = COL_box_val_ignore
            self.box_button.color_rim = COL_box_val_rim_ignore

            for e in self.blf_value:
                e.color = COL_box_val_fg_ignore
            Admin.REDRAW()
        #|
    def light(self):
        if self.box_button.color == COL_box_val_ignore:
            self.box_button.color = COL_box_val
            self.box_button.color_rim = COL_box_val_rim

            for e in self.blf_value:
                e.color = COL_box_val_fg
            Admin.REDRAW()
        #|

    def inside_evt(self):
        _valboxdata[0] = 0
        self.active_index = None
        #|
    def outside_evt(self):
        Admin.REDRAW()
        self.draw_box = self.i_draw_box
        self.active_index = None
        #|

    def modal(self):
        ind = min(max(0, (MOUSE[1] - self.box_button.inner[3]) // - SIZE_widget[0]), self.array_length - 1)

        if self.active_index != ind:

            self.draw_box = self.i_draw_box_media
            Admin.REDRAW()
            self.box_media = BoxFake()
            if self.is_dark() is True:
                self.box_active.LRBT_upd(0, 0, 0, 0)
            else:
                L, R, B, T = self.box_button.inner
                T -= SIZE_widget[0] * ind
                self.box_active.LRBT_upd(L, R, T, T - SIZE_widget[0])
            self.active_index = ind
            _valboxdata[0] = 0

        if MOUSE[0] < self.box_button.inner[0] + SIZE_widget[0]:
            if _valboxdata[0] == 0:

                Admin.REDRAW()
                self.box_media = GpuImg_valuebox_left()
                L, R, B, T = self.box_button.inner
                T -= SIZE_widget[0] * self.active_index
                self.box_media.LRBT_upd(L, L + SIZE_widget[0], T, T - SIZE_widget[0])
                _valboxdata[0] = 1
        elif MOUSE[0] >= self.box_button.inner[1] - SIZE_widget[0]:
            if _valboxdata[0] == 0:

                Admin.REDRAW()
                self.box_media = GpuImg_valuebox_right()
                L, R, B, T = self.box_button.inner
                T -= SIZE_widget[0] * self.active_index
                self.box_media.LRBT_upd(R - SIZE_widget[0], R, T, T - SIZE_widget[0])
                _valboxdata[0] = 2
        else:
            if _valboxdata[0] != 0:
                Admin.REDRAW()
                self.box_media = BoxFake()
                _valboxdata[0] = 0

        # <<< 1copy (0block_ButtonInt_modal_trigger,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['valbox_drag']():
            self.to_modal_drag()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            if _valboxdata[0] == 0: self.to_modal_drag_pre()
            elif _valboxdata[0] == 1: self.to_modal_media_left()
            else: self.to_modal_media_right()
            return True
        # >>>
        return False
        #|

    def to_modal_drag_pre(self, override=None):

        _blf_value = self.blf_value

        end_trigger = r_end_trigger('valbox_drag'  if override == "POST" else 'click')
        mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")
        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
        _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
        _xy = [0, 0]
        _valbox_drag_fac = P.valbox_drag_fac_int
        _value_data = {'confirm': True}
        _set = self.set
        _th_drag = P.th_drag
        _h = SIZE_widget[0]
        _box_active_LRBT_upd = self.box_active.LRBT_upd

        if isinstance(_blf_value, list):
            if hasattr(_blf_value[0], "unclip_text") and is_value(_blf_value[0].unclip_text): pass
            else: return

            _value_data["values"] = [(e.unclip_text, e.text)  for e in _blf_value]

            if self.is_dark() is False: self.box_active.color = COL_box_val_active
            if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()
        elif hasattr(_blf_value, "unclip_text") and is_value(_blf_value.unclip_text):
            _value_data["values"] = [(_blf_value.unclip_text, _blf_value.text)]

            if self.is_dark() is False: self.box_button.color = COL_box_val_active
            if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()
        else: return

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                ind = self.active_index
                _value_data["confirm"] = None
                w_head.fin()
                self.active_index = ind
                self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if abs(_xy[0]) >= P.th_drag:
                _xy[0] = 0
                _REDRAW()
                w_head.modal = modal_drag
            elif abs(_xy[1]) >= P.th_drag:
                _xy[0] = 0
                _xy[1] = 0
                _REDRAW()
                w_head.modal = modal_drag_pre_array
                _value_data["end_index"] = self.active_index

            mouseloop()

        def modal_drag():
            _REDRAW()

            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = False
                w_head.fin()
                return
            if end_trigger():
                w_head.fin()
                return

            dx, dy = r_dxy_mouse()
            if _TRIGGER_drag_fast(): dx *= 10
            elif _TRIGGER_drag_slow(): dx *= 0.1

            _xy[0] += dx * _valbox_drag_fac
            travel = _xy[0]
            if travel >= 1:
                dx = floor(travel)
                _xy[0] -= dx
            elif travel <= -1:
                dx = ceil(travel)
                _xy[0] -= dx
            else:
                mouseloop()
                return

            # /* 0block_ButtonIntVector_modal_drag_set
            e = _blf_value[self.active_index]
            _set(e.unclip_text + dx, self.active_index, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # */
            mouseloop()

        def modal_drag_pre_array():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                i0 = self.active_index
                _value_data["confirm"] = None
                w_head.fin()
                self.active_index = i0

                ind = _value_data["end_index"]
                if i0 > ind: i0, ind = ind, i0
                if i0 == ind:
                    self.to_dropdown()
                else:
                    self.to_dropdown(range(i0, ind + 1), _value_data["end_index"])
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if _xy[1] < - _h:
                d = (- _xy[1]) // _h
                _xy[1] += _h * d
                _xy[0] = 0
                ind = min(_value_data["end_index"] + d, self.array_length - 1)
            elif _xy[1] > _h:
                d = _xy[1] // _h
                _xy[1] -= _h * d
                _xy[0] = 0
                ind = max(0, _value_data["end_index"] - d)
            else:
                ind = _value_data["end_index"]

            if ind != _value_data["end_index"]:
                _value_data["end_index"] = ind
                L, R, B, T = self.box_button.inner
                i0 = self.active_index
                if i0 > ind: i0, ind = ind, i0
                T -= i0 * _h
                B = T - _h * (ind - i0 + 1)
                _REDRAW()
                _box_active_LRBT_upd(L, R, B, T)

            if abs(_xy[0]) >= _h:
                _xy[0] = 0
                _REDRAW()
                i0 = self.active_index
                ind = _value_data["end_index"]
                if i0 > ind: i0, ind = ind, i0
                _value_data["array_range"] = range(i0, ind + 1)
                _value_data["array_index"] = i0, ind + 1

                def modal_drag_array():
                    _REDRAW()

                    if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                        _value_data["confirm"] = False
                        w_head.fin()
                        return
                    if end_trigger():
                        w_head.fin()
                        return

                    dx, dy = r_dxy_mouse()
                    if _TRIGGER_drag_fast(): dx *= 10
                    elif _TRIGGER_drag_slow(): dx *= 0.1

                    _xy[0] += dx * _valbox_drag_fac
                    travel = _xy[0]
                    if travel >= 1:
                        dx = floor(travel)
                        _xy[0] -= dx
                    elif travel <= -1:
                        dx = ceil(travel)
                        _xy[0] -= dx
                    else:
                        mouseloop()
                        return

                    _set([_blf_value[r].unclip_text + dx  for r in _value_data["array_range"]],
                        _value_data["array_index"], undo_push=False)
                    if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
                    mouseloop()

                w_head.modal = modal_drag_array

            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
            mouseloop_end()
            kill_evt_except()
            self.box_active.color = COL_box_val_fo

            if _value_data["confirm"] is None: pass
            elif _value_data["confirm"] == True:
                if "array_range" in _value_data:
                    e = _value_data["array_range"]
                    _set([_blf_value[i].unclip_text  for i in e], (e.start, e.stop),
                        undo_push=tuple(v[0]  for v in _value_data["values"]))
                else:
                    i = self.active_index
                    self.set(_blf_value[i].unclip_text, i,
                        undo_push=tuple(v[0]  for v in _value_data["values"]))
            else:
                for e, o in zip(self.blf_value, _value_data["values"]):
                    e.unclip_text = o[0]
                    e.text = o[1]

            self.active_index = None
            if hasattr(self, "end_modal_drag_callback"): self.end_modal_drag_callback()

            MODAL_DRAG_STATE[0] = -1

        if override == "POST":
            w_head = Head(self, modal_drag, end_modal_release)
        elif override == "MEDIA":
            def modal_media():
                _REDRAW()
                if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc() or end_trigger():
                    w_head.fin()
                    return

                dx, dy = r_dxy_mouse()
                _xy[0] += dx
                if abs(_xy[0]) >= P.th_drag:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                    _xy[0] = 0
                    Admin.REDRAW()
                    self.draw_box = self.i_draw_box
                    _valboxdata[0] = 0
                    w_head.modal = modal_drag

                mouseloop()

            w_head = Head(self, modal_media, end_modal_release)
        else:
            w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    def to_modal_media_left(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0block_ButtonIntVector_modal_drag_set,, ${'+ dx':'- 1'}$)
            e = _blf_value[self.active_index]
            _set(e.unclip_text - 1, self.active_index, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    def to_modal_media_right(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0block_ButtonIntVector_modal_drag_set,, ${'+ dx':'+ 1'}$)
            e = _blf_value[self.active_index]
            _set(e.unclip_text + 1, self.active_index, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    def to_dropdown(self, array_range=None, end_index=None):

        ind = self.active_index  if array_range == None else end_index

        o = self.blf_value[ind]
        h = SIZE_widget[0]
        widget_rim = SIZE_border[3]
        L, R, B, T = self.box_button.inner
        L -= widget_rim
        R += widget_rim
        T -= h * ind
        B = T - h - widget_rim
        T += widget_rim

        if array_range == None: array_range = range(ind, ind + 1)
        DropDownVal(self, (L, R, B, T), o.text, o.unclip_text, self.rna, array_range)
        #|

    def to_modal_rm(self):

        items = [
            ("dd_cut", self.evt_area_cut),
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_all", self.evt_area_reset_all),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ]
        append_rm_item_rotation_unit(self, items, self.rna)
        append_rm_item_operator(items, self.rna)

        DropDownRMKeymap(self, MOUSE, items, override_name={"dd_cut":"Copy Array"}, title=self.rna.name)
        #|

    @ catch
    def evt_area_cut(self, is_report=True):

        kill_evt_except()
        s = ""
        for e in self.get(): s += f'{value_to_display(e)}, '

        bpy.context.window_manager.clipboard = s[: -2]
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        if self.active_index == None:
            self.evt_area_cut(is_report)
            return

        kill_evt_except()
        bpy.context.window_manager.clipboard = value_to_display(self.get()[self.active_index])
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            Admin.REDRAW()
            if s.strip().startswith("#"):
                self.set(s, 0  if self.active_index == None else self.active_index)
                return

            array = calc_vec(s)
            ll = len(array)
            if ll == 1 and self.active_index != None:
                self.set(int(round_dec(array[0])), self.active_index)
            else:
                if ll > self.array_length: array = array[: self.array_length]
                self.set([int(round_dec(v))  for v in array], (0, ll))
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_reset_single(self):

        kill_evt_except()
        Admin.REDRAW()
        if self.active_index == None:
            self.set(self.r_default_array(), (0, self.array_length))
        else:
            i = self.active_index
            self.set(self.r_default_array()[i], i)
        #|
    @ catch
    def evt_area_reset_all(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_array(), (0, self.array_length))
        #|

    def i_dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        if self.draw_box == self.i_draw_box_media:
            self.box_active.dxy_upd(dx, dy)
            self.box_media.dxy_upd(dx, dy)

        for e in self.blf_value:
            e.x += dx
            e.y += dy
        #|
    def i_dxy_subtype(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        if self.draw_box == self.i_draw_box_media:
            self.box_active.dxy_upd(dx, dy)
            self.box_media.dxy_upd(dx, dy)

        for e in self.blf_value:
            e.x += dx
            e.y += dy
        for e in self.blf_subtype:
            e.x += dx
            e.y += dy
        #|

    def i_draw_box_media(self):
        self.box_button.bind_draw()
        self.box_active.bind_draw()
        self.box_media.bind_draw()
        #|
    def i_draw_blf(self):
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *self.blf_value[0].color)
        for e in self.blf_value:
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|
    def i_draw_blf_subtype(self):
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *self.blf_value[0].color)
        for e in self.blf_value:
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)

        blfSize(FONT0, D_SIZE['font_label'])
        blfColor(FONT0, *self.blf_subtype[0].color)
        for e in self.blf_subtype:
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        for e, o in zip(self.blf_value, getattr(self.pp, self.rna.identifier)):
            if e.unclip_text == o: continue
            e.unclip_text = o
            e.text = self.text_format(o)
        #|
    #|
    #|
class ButtonBoolVector(             # StructButtonGetSetVector
    StructButtonGetSetVector):
    __slots__ = (
        'w',
        'rna',
        'pp',
        'r_pp',
        'r_object',
        'r_datapath_head',
        'box_button',
        'row_length',
        'active_index',
        'is_trigger_enable',
        'set_callback',
        'array_length',
        'array_tuple')

    def __init__(self, w, rna, pp, row_length=1):
        self.w = w
        self.rna = rna
        self.array_length = rna.array_length

        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.row_length = row_length
        self.box_button = [GpuButtonBool()  for r in range(self.array_length)]
        self.array_tuple = (False, ) * self.array_length
        #|

    def init_bat(self, L, R, T):
        blfSize(FONT0, D_SIZE['font_main'])
        row_length = self.row_length
        box_button = self.box_button
        widget_rim = SIZE_border[3]
        full_h = D_SIZE['widget_full_h']
        width = (R - L) // row_length
        range_row = range(row_length)
        LRs = []
        R0 = L + width
        for _ in range_row:
            LRs.append([L, R0])
            L = R0
            R0 += width
        LRs[-1][1] = R
        B = T - full_h
        y = B + widget_rim + D_SIZE['font_main_dy']

        i = 0
        amount = len(box_button) // row_length
        for _ in range(amount):
            for r in range_row:
                # /* 0block_ButtonBoolVector_initbutton
                L0, R0 = LRs[r]
                box_button[i].LRBT_upd(L0, R0, B, T, widget_rim)
                i += 1
                # */

            T = B
            B -= full_h
            y -= full_h

        for r in range(len(box_button) - amount * row_length):
            # <<< 1copy (0block_ButtonBoolVector_initbutton,, $$)
            L0, R0 = LRs[r]
            box_button[i].LRBT_upd(L0, R0, B, T, widget_rim)
            i += 1
            # >>>

        self.upd_data()
        return box_button[-1].B
        #|
    def r_height(self, width): return D_SIZE['widget_full_h'] * ceil(len(self.box_button) / self.row_length)
    def r_default_array(self): return self.rna.default_array

    def is_dark(self): return self.box_button[0].is_dark()
    def dark(self):
        for e in self.box_button: e.dark()
        #|
    def light(self):
        for e in self.box_button: e.light()
        #|

    def r_focus_index(self, mouse):
        for r, e in enumerate(self.box_button):
            if e.inbox(mouse): return r
        return None
        #|

    def focus_button(self, i):
        if self.box_button[i].state == 0:
            self.box_button[i].set_state_off_focus()
        #|
    def unfocus_button(self, i):
        if self.box_button[i].state == 1:
            self.box_button[i].set_state_off()
        #|
    def turnon_button(self, i):
        if self.box_button[i].state in {0, 1}:
            self.box_button[i].set_state_on()
        #|
    def turnoff_button(self, i):
        if self.box_button[i].state == 2:
            self.box_button[i].set_state_off()
        #|

    def inside(self, mouse):
        box_button = self.box_button
        if mouse[0] < box_button[0].L: return False
        if mouse[0] > box_button[self.row_length - 1].R: return False
        if mouse[1] > box_button[0].T: return False
        if mouse[1] < box_button[-1].B: return False
        return True
        #|
    def inside_evt(self):
        self.active_index = self.r_focus_index(MOUSE)
        if self.active_index != None:
            self.focus_button(self.active_index)
            Admin.REDRAW()
        self.is_trigger_enable = True
        #|
    def outside_evt(self):
        if hasattr(self, "active_index"):
            if self.active_index != None:
                self.unfocus_button(self.active_index)
                Admin.REDRAW()
        #|

    def modal(self):
        i = self.r_focus_index(MOUSE)
        if i != self.active_index:

            if self.active_index != None:
                self.unfocus_button(self.active_index)
                Admin.REDRAW()

            self.active_index = i
            self.is_trigger_enable = True

            if i != None:
                self.focus_button(i)
                Admin.REDRAW()

        if i == None: return False

        allow_trigger = self.is_trigger_enable
        if not allow_trigger:
            if EVT_TYPE[0] == "TIMER_REPORT": pass
            else:
                if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                    self.is_trigger_enable = True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if allow_trigger:
            if TRIGGER['click']():
                self.is_trigger_enable = False
                if is_first_press('click') == False:
                    self.set(_last_bool_state[0], i)
                else:
                    boo = not self.get(i)
                    self.set(boo, i)
                    _last_bool_state[0] = boo
                Admin.REDRAW()
                return True
        return False
        #|

    @ catch
    def to_modal_rm(self):


        DropDownRMKeymap(self, MOUSE, [
            ("dd_cut", self.evt_area_cut),
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_all", self.evt_area_reset_all),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ], override_name={"dd_cut":"Copy Identifier"}, title=self.rna.name)
        #|

    @ catch
    def evt_area_cut(self, is_report=True):

        kill_evt_except()
        bpy.context.window_manager.clipboard = ", ".join("1" if v else "0"  for v in self.get())
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        if self.active_index == None:
            self.evt_area_cut(is_report)
            return

        kill_evt_except()
        bpy.context.window_manager.clipboard = "1" if self.get(self.active_index) else "0"
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            array = calc_vec(s)
            ll = len(array)
            if ll == 1 and self.active_index != None:
                self.set(bool(array[0]), self.active_index)
            else:
                if ll > self.array_length: array = array[: self.array_length]
                self.set([bool(v)  for v in array], (0, ll))
            Admin.REDRAW()
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_reset_single(self):

        kill_evt_except()
        Admin.REDRAW()
        i = self.active_index
        if i == None:
            self.set(self.r_default_array(), (0, self.array_length))
        else:
            self.set(self.r_default_array()[i], i)
        #|
    @ catch
    def evt_area_reset_all(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_array(), (0, self.array_length))
        #|
    @ catch
    def evt_area_detail(self):

        kill_evt_except()
        Detail(Detail.r_rna_info(self.rna))
        #|

    def dxy(self, dx, dy):
        for e in self.box_button: e.dxy_upd(dx, dy)
    def draw_box(self):
        for e in self.box_button: e.bind_draw()
        #|
    def draw_blf(self): pass

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.array_tuple == tuple(self.get()): return
        array_tuple = tuple(self.get())



        for r, v in enumerate(array_tuple):
            self.turnon_button(r)  if v == True else self.turnoff_button(r)

        self.array_tuple = array_tuple
        #|
    #|
    #|
class ButtonFloatVector(            # ButtonIntVector                                           
    ButtonIntVector):
    __slots__ = ()

    # <<< 1copy (0block_ButtonIntVector_init,, ${'"INT"':'rna.unit'}$)
    def __init__(self, w, rna, pp, subtype_override=None):
        self.w = w
        self.rna = rna
        self.array_length = rna.array_length

        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp

        self.box_button = GpuRim(COL_box_val, COL_box_val_rim)
        self.box_active = GpuBox(COL_box_val_fo)
        self.text_format = D_format[rna.unit]
        vv = getattr(self.pp, rna.identifier)
        self.blf_value = [BlfClip(self.text_format(v), v)  for v in vv]
        self.blf_value[0].color = COL_box_val_fg

        if subtype_override is None:
            if rna.subtype in D_subtype_display:
                self.draw_blf = self.i_draw_blf_subtype
                self.dxy = self.i_dxy_subtype
                self.blf_subtype = [Blf(tx)  for _, tx in zip(vv, D_subtype_display[rna.subtype])]
                self.blf_subtype[0].color = COL_box_button_fg_info
            else:
                self.draw_blf = self.i_draw_blf
                self.dxy = self.i_dxy
        else:
            self.draw_blf = self.i_draw_blf_subtype
            self.dxy = self.i_dxy_subtype
            self.blf_subtype = [Blf(tx)  for _, tx in zip(vv, subtype_override)]
            self.blf_subtype[0].color = COL_box_button_fg_info

        self.draw_box = self.i_draw_box
        self.active_index = None
    # >>>

    def to_modal_drag_pre(self, override=None):

        _blf_value = self.blf_value

        end_trigger = r_end_trigger('valbox_drag'  if override == "POST" else 'click')
        mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")
        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
        _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
        _xy = [0, 0]
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _value_data = {'confirm': True}
        _set = self.set
        _th_drag = P.th_drag
        _h = SIZE_widget[0]
        _box_active_LRBT_upd = self.box_active.LRBT_upd

        if isinstance(_blf_value, list):
            if hasattr(_blf_value[0], "unclip_text") and is_value(_blf_value[0].unclip_text): pass
            else: return

            _value_data["values"] = [(e.unclip_text, e.text)  for e in _blf_value]

            if self.is_dark() is False: self.box_active.color = COL_box_val_active
            if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()
        elif hasattr(_blf_value, "unclip_text") and is_value(_blf_value.unclip_text):
            _value_data["values"] = [(_blf_value.unclip_text, _blf_value.text)]

            if self.is_dark() is False: self.box_button.color = COL_box_val_active
            if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()
        else: return

        _soft_min = self.rna.soft_min  if hasattr(self.rna, "soft_min") else FLOAT_min
        _soft_max = self.rna.soft_max  if hasattr(self.rna, "soft_max") else FLOAT_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 1000.0 * _valbox_drag_fac

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                ind = self.active_index
                _value_data["confirm"] = None
                w_head.fin()
                self.active_index = ind
                self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if abs(_xy[0]) >= P.th_drag:
                _xy[0] = 0
                _REDRAW()
                w_head.modal = modal_drag
                nonlocal _blf_value_fo, _index_
                _index_ = self.active_index
                _blf_value_fo = _blf_value[self.active_index]
                if _blf_value_fo.unclip_text > _soft_max:
                    _soft_value[1] = _soft_threshold
                elif _blf_value_fo.unclip_text < _soft_min:
                    _soft_value[0] = _soft_threshold

            elif abs(_xy[1]) >= P.th_drag:
                _xy[0] = 0
                _xy[1] = 0
                _REDRAW()
                w_head.modal = modal_drag_pre_array
                _value_data["end_index"] = self.active_index

            mouseloop()

        _index_ = None
        _blf_value_fo = None
        def modal_drag():
            _REDRAW()

            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = False
                w_head.fin()
                return
            if end_trigger():
                w_head.fin()
                return

            dx, dy = r_dxy_mouse()
            if _TRIGGER_drag_fast(): dx *= _valbox_drag_fac * 10
            elif _TRIGGER_drag_slow(): dx *= _valbox_drag_fac * 0.1
            else: dx *= _valbox_drag_fac

            # <<< 1copy (0defuiFloatvecModalDragSet,, $$)
            try:
                v_float = _blf_value_fo.unclip_text + dx

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                mouseloop()
                return
            _set(v_float, _index_, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>
            mouseloop()

        def modal_drag_pre_array():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                i0 = self.active_index
                _value_data["confirm"] = None
                w_head.fin()
                self.active_index = i0

                ind = _value_data["end_index"]
                if i0 > ind: i0, ind = ind, i0
                if i0 == ind:
                    self.to_dropdown()
                else:
                    self.to_dropdown(range(i0, ind + 1), _value_data["end_index"])
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if _xy[1] < - _h:
                d = (- _xy[1]) // _h
                _xy[1] += _h * d
                _xy[0] = 0
                ind = min(_value_data["end_index"] + d, self.array_length - 1)
            elif _xy[1] > _h:
                d = _xy[1] // _h
                _xy[1] -= _h * d
                _xy[0] = 0
                ind = max(0, _value_data["end_index"] - d)
            else:
                ind = _value_data["end_index"]

            if ind != _value_data["end_index"]:
                _value_data["end_index"] = ind
                L, R, B, T = self.box_button.inner
                i0 = self.active_index
                if i0 > ind: i0, ind = ind, i0
                T -= i0 * _h
                B = T - _h * (ind - i0 + 1)
                _REDRAW()
                _box_active_LRBT_upd(L, R, B, T)

            if abs(_xy[0]) >= _h:
                _xy[0] = 0
                _REDRAW()
                i0 = self.active_index
                ind = _value_data["end_index"]
                init_ind = ind

                if i0 > ind: i0, ind = ind, i0
                _value_data["array_range"] = range(i0, ind + 1)
                _value_data["array_index"] = i0, ind + 1
                le = len(_value_data["array_range"])
                _index_ = _value_data["array_index"]
                _blf_value_fo = _blf_value[init_ind]

                _set([_blf_value_fo.unclip_text] * le, _index_, undo_push=False)
                if _blf_value_fo.unclip_text > _soft_max:
                    _soft_value[1] = _soft_threshold
                elif _blf_value_fo.unclip_text < _soft_min:
                    _soft_value[0] = _soft_threshold

                def modal_drag_array():
                    _REDRAW()

                    if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                        _value_data["confirm"] = False
                        w_head.fin()
                        return
                    if end_trigger():
                        w_head.fin()
                        return

                    dx, dy = r_dxy_mouse()
                    if _TRIGGER_drag_fast(): dx *= _valbox_drag_fac * 10
                    elif _TRIGGER_drag_slow(): dx *= _valbox_drag_fac * 0.1
                    else: dx *= _valbox_drag_fac

                    # <<< 1copy (0defuiFloatvecModalDragSet,, ${
                    #     '_set(v_float': '_set([v_float] * le'
                    # }$)
                    try:
                        v_float = _blf_value_fo.unclip_text + dx

                        if _soft_value[1] >= _soft_threshold:
                            if v_float < _soft_max:
                                _soft_value[1] /= 2.0
                        else:
                            if v_float > _soft_max:
                                _soft_value[1] += v_float - _soft_max
                                _soft_value[0] = 0.0
                                v_float = _soft_max
                            else:
                                if _soft_value[0] >= _soft_threshold:
                                    if v_float > _soft_min:
                                        _soft_value[0] /= 2.0
                                else:
                                    if v_float < _soft_min:
                                        _soft_value[0] += _soft_min - v_float
                                        _soft_value[1] = 0.0
                                        v_float = _soft_min
                    except:
                        mouseloop()
                        return
                    _set([v_float] * le, _index_, undo_push=False)
                    if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
                    # >>>
                    mouseloop()

                w_head.modal = modal_drag_array

            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
            mouseloop_end()
            kill_evt_except()
            self.box_active.color = COL_box_val_fo

            if _value_data["confirm"] is None: pass
            elif _value_data["confirm"] == True:
                if "array_range" in _value_data:
                    e = _value_data["array_range"]
                    _set([_blf_value[i].unclip_text  for i in e], (e.start, e.stop),
                        undo_push=tuple(v[0]  for v in _value_data["values"]))
                else:
                    i = self.active_index
                    self.set(_blf_value[i].unclip_text, i,
                        undo_push=tuple(v[0]  for v in _value_data["values"]))
            else:
                for e, o in zip(self.blf_value, _value_data["values"]):
                    e.unclip_text = o[0]
                    e.text = o[1]

            self.active_index = None
            if hasattr(self, "end_modal_drag_callback"): self.end_modal_drag_callback()

            MODAL_DRAG_STATE[0] = -1

        if override == "POST":
            w_head = Head(self, modal_drag, end_modal_release)
            _index_ = self.active_index
            _blf_value_fo = _blf_value[self.active_index]
            if _blf_value_fo.unclip_text > _soft_max:
                _soft_value[1] = _soft_threshold
            elif _blf_value_fo.unclip_text < _soft_min:
                _soft_value[0] = _soft_threshold

        elif override == "MEDIA":
            def modal_media():
                _REDRAW()
                if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc() or end_trigger():
                    w_head.fin()
                    return

                dx, dy = r_dxy_mouse()
                _xy[0] += dx
                if abs(_xy[0]) >= P.th_drag:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                    _xy[0] = 0
                    Admin.REDRAW()
                    self.draw_box = self.i_draw_box
                    _valboxdata[0] = 0
                    w_head.modal = modal_drag
                    nonlocal _blf_value_fo, _index_
                    _index_ = self.active_index
                    _blf_value_fo = _blf_value[self.active_index]

                    if _blf_value_fo.unclip_text > _soft_max:
                        _soft_value[1] = _soft_threshold
                    elif _blf_value_fo.unclip_text < _soft_min:
                        _soft_value[0] = _soft_threshold

                mouseloop()

            w_head = Head(self, modal_media, end_modal_release)
        else:
            w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    def to_modal_media_left(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _index_ = self.active_index
        _blf_value_fo = _blf_value[self.active_index]

        _soft_min = self.rna.soft_min  if hasattr(self.rna, "soft_min") else FLOAT_min
        _soft_max = self.rna.soft_max  if hasattr(self.rna, "soft_max") else FLOAT_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 20.0 * _valbox_drag_fac

        if _blf_value_fo.unclip_text > _soft_max:
            _soft_value[1] = _soft_threshold
        elif _blf_value_fo.unclip_text < _soft_min:
            _soft_value[0] = _soft_threshold

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiFloatvecModalDragSet,, ${'+ dx':'- _valbox_drag_fac', 'mouseloop()':''}$)
            try:
                v_float = _blf_value_fo.unclip_text - _valbox_drag_fac

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                
                return
            _set(v_float, _index_, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    def to_modal_media_right(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _index_ = self.active_index
        _blf_value_fo = _blf_value[self.active_index]

        _soft_min = self.rna.soft_min  if hasattr(self.rna, "soft_min") else FLOAT_min
        _soft_max = self.rna.soft_max  if hasattr(self.rna, "soft_max") else FLOAT_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 20.0 * _valbox_drag_fac

        if _blf_value_fo.unclip_text > _soft_max:
            _soft_value[1] = _soft_threshold
        elif _blf_value_fo.unclip_text < _soft_min:
            _soft_value[0] = _soft_threshold

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiFloatvecModalDragSet,, ${'+ dx':'+ _valbox_drag_fac', 'mouseloop()':''}$)
            try:
                v_float = _blf_value_fo.unclip_text + _valbox_drag_fac

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                
                return
            _set(v_float, _index_, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    @ catch
    def evt_area_cut(self, is_report=True):

        kill_evt_except()
        s = ""
        fac = r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format)
        for e in self.get(): s += f'{value_to_display(e / fac)}, '

        bpy.context.window_manager.clipboard = s[: -2]
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        if self.active_index == None:
            self.evt_area_cut(is_report)
            return

        kill_evt_except()
        bpy.context.window_manager.clipboard = value_to_display(
            self.get()[self.active_index] / r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format))
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        fac = r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format)
        try:
            Admin.REDRAW()
            if s.strip().startswith("#"):
                self.set(s, 0  if self.active_index == None else self.active_index)
                return

            array = calc_vec(s)
            ll = len(array)
            if ll == 1 and self.active_index != None:
                self.set(float(array[0] * fac), self.active_index)
            else:
                if ll > self.array_length: array = array[: self.array_length]
                self.set([float(v * fac)  for v in array], (0, ll))
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_format(self):
        if self.rna.subtype != "EULER": return

        kill_evt_except()
        if self.text_format.__name__.find("deg") == -1:
            self.text_format = UnitSystem.rs_format_deg
            # self.rna.vmd_is_radian = False
        else:
            self.text_format = UnitSystem.format_float
            # self.rna.vmd_is_radian = True

        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return

        for e, v in zip(self.blf_value, self.get()):
            e.unclip_text = v
            e.text = self.text_format(v)
        Admin.REDRAW()
        #|
    #|
    #|
class ButtonFloatVectorColor(ButtonFloatVector):
    __slots__ = 'update_callback', 'callback_enable'

    def set(self, v, index, refresh=True, undo_push=True):
        super().set(v, index, refresh)
        self.upd_data()
        if self.callback_enable: self.update_callback()
        #|
    #|
    #|
class ButtonString:
    __slots__ = (
        'w',
        'rna',
        'pp',
        'r_pp',
        'r_object',
        'r_datapath_head',
        'box_button',
        'blf_subtype',
        'blf_value',
        'b_str',
        'row_count',
        'font_id',
        'headkey',
        'draw_blf',
        'dxy',
        'set_callback',
        'poll')

    def __init__(self, w, rna, pp, subtype_override=None):
        if subtype_override == "LINES":
            self.__class__ = ButtonStringXY
            self.__init__(w, rna, pp)
            return
        subtype = rna.subtype  if hasattr(rna, "subtype") else None
        if subtype in {"BYTE_STRING", "LINES"}:
            self.__class__ = ButtonStringXY
            self.__init__(w, rna, pp, subtype_override)
            return

        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp

        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        v = self.get()
        self.blf_value = BlfClipColor(v, v, 0, 0, COL_box_text_fg)
        self.font_id = FONT0

        if subtype_override is None:
            if subtype in D_subtype_display:
                self.draw_blf = self.i_draw_blf_subtype
                self.dxy = self.i_dxy_subtype
                self.blf_subtype = BlfColor(D_subtype_display[rna.subtype], 0, 0, COL_box_button_fg_info)
            else:
                self.draw_blf = self.i_draw_blf
                self.dxy = self.i_dxy
        else:
            self.draw_blf = self.i_draw_blf_subtype
            self.dxy = self.i_dxy_subtype
            self.blf_subtype = BlfColor(subtype_override[0], 0, 0, COL_box_button_fg_info)
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        blf_value.x = L0 + D_SIZE['font_main_dx']
        blf_value.y = B0 + D_SIZE['font_main_dy']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(
            blf_value.unclip_text, blf_value.x, R0 - D_SIZE['font_main_dx'])

        # <<< 1copy (0block_ButtonInt_init_subtype,, $$)
        if hasattr(self, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            self.blf_subtype.y = T - SIZE_border[3] - D_SIZE['font_label_dT']
            self.blf_subtype.x = L - D_SIZE['font_label_dx'] - ceil(blfDimen(FONT0, self.blf_subtype.text)[0])
        # >>>
        return B
        #|
    def r_height(self, width): return D_SIZE['widget_full_h']
    def r_default_value(self): return self.rna.default

    def is_dark(self): return self.blf_value.color == COL_box_text_fg_ignore
    def dark(self):
        if self.box_button.color != COL_box_text_ignore:
            self.box_button.color = COL_box_text_ignore
            self.box_button.color_rim = COL_box_text_rim_ignore
            self.blf_value.color = COL_box_text_fg_ignore
            Admin.REDRAW()
        #|
    def light(self):
        if self.box_button.color != COL_box_text:
            self.box_button.color = COL_box_text
            self.box_button.color_rim = COL_box_text_rim
            self.blf_value.color = COL_box_text_fg
            Admin.REDRAW()
        #|

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        if self.is_dark() is False:
            self.box_button.color = COL_box_text_active
            Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.is_dark() is False:
            self.box_button.color = COL_box_text
            Admin.REDRAW()
        #|

    def modal(self):
        # /* 0block_ButtonString_modal
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.to_dropdown()#ref
            return True
        # */
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        v = self.get()
        if isinstance(v, bytes): v = v.decode('utf-8')
        if isinstance(self.blf_value, list):
            w = DropDownStringXY(self, self.box_button.r_LRBT(), v,
                font_id=self.font_id, killevt=killevt, select_all=select_all)

            a = w.areas[0]
            e0 = self.blf_value[0]
            a.r_pan_text_override()(e0.x - a.line_x,
                (self.headkey - a.headkey) * SIZE_widget[0] + e0.y - a.blf_text[0].y)

            def end_dropdown():
                self.blf_value[:] = a.blf_text
                x = a.line_x
                for e in self.blf_value: e.x = x
                self.headkey = a.headkey

            w.data["fin_callfront"] = end_dropdown
            return w
        else:
            return DropDownString(self, self.box_button.r_LRBT(), v)
        #|

    def to_modal_rm(self):


        items = [
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ]
        append_rm_item_operator(items, self.rna)

        DropDownRMKeymap(self, MOUSE, items, title=self.rna.name)
        #|

    def to_area_pan_text(self):

        w = self.to_dropdown(killevt=False, select_all=False)
        w.areas[0].to_modal_pan_text_from_block()
        #|

    @ catch
    def evt_area_cut(self, is_report=True):
        self.evt_area_copy(is_report)
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        kill_evt_except()
        v = self.get()
        bpy.context.window_manager.clipboard = v.decode('utf-8')  if isinstance(v, bytes) else f'{v}'
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            self.set(s)
            Admin.REDRAW()
        except:
            if is_report: report("Input Error")
        #|
    @ catch
    def evt_area_reset_single(self):
        kill_evt_except()

        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_reset_all(self):
        kill_evt_except()

        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_detail(self):

        kill_evt_except()
        Detail(Detail.r_rna_info(self.rna))
        #|

    def i_dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def i_dxy_subtype(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy

        self.blf_subtype.x += dx
        self.blf_subtype.y += dy
        #|

    def draw_box(self):
        self.box_button.bind_draw()
        #|
    def i_draw_blf(self):
        e = self.blf_value
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|
    def i_draw_blf_subtype(self):
        e = self.blf_value
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        e = self.blf_subtype
        blfSize(FONT0, D_SIZE['font_label'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def get(self): return getattr(self.pp, self.rna.identifier)
    def set(self, v, refresh=True, undo_push=True):
        oldvalue = getattr(self.pp, self.rna.identifier)
        if self.rna.subtype == "BYTE_STRING" and not isinstance(v, bytes): v = str.encode(v)
        setattr(self.pp, self.rna.identifier, v)
        if refresh: update_data()

        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
        #|
    def evt_undo_push(self, undo_push, oldvalue): pass

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.rna.identifier)
        blf_value.unclip_text = v
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'])
        #|
    #|
    #|
class ButtonStringXY(               # ButtonString                                              
    ButtonString):
    __slots__ = ()

    def __init__(self, w, rna, pp, subtype_override=None):
        self.w = w
        self.rna = rna
        self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        v = getattr(pp, rna.identifier)
        self.blf_value = []
        self.b_str = v
        self.row_count = 5
        self.font_id = FONT0

        if subtype_override is None:
            if rna.subtype in D_subtype_display:
                self.draw_blf = self.i_draw_blf_subtype
                self.dxy = self.i_dxy_subtype
                self.blf_subtype = BlfColor(D_subtype_display[rna.subtype], 0, 0, COL_box_button_fg_info)
            else:
                self.draw_blf = self.i_draw_blf
                self.dxy = self.i_dxy
        else:
            self.draw_blf = self.i_draw_blf_subtype
            self.dxy = self.i_dxy_subtype
            self.blf_subtype = BlfColor(subtype_override[0], 0, 0, COL_box_button_fg_info)
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        h = SIZE_widget[0]
        B = T - D_SIZE['widget_full_h'] - (self.row_count - 1) * h
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])

        font_dx, font_dy, font_dT = r_widget_font_dx_dy_dT(self.font_id, h)
        x = self.box_button.inner[0] + font_dx
        blf_value.clear()
        self.headkey = 0
        count = self.row_count + 1
        if isinstance(self.b_str, str):
            lines = self.b_str.split('\n', count)
        else:
            lines = self.b_str.decode('utf-8').split('\n', count)
        if len(lines) > count: del lines[-1]

        y = self.box_button.inner[3] - font_dT
        for line in lines:
            blf_value.append(Blf(line, x, y))
            y -= h

        # <<< 1copy (0block_ButtonInt_init_subtype,, $$)
        if hasattr(self, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            self.blf_subtype.y = T - SIZE_border[3] - D_SIZE['font_label_dT']
            self.blf_subtype.x = L - D_SIZE['font_label_dx'] - ceil(blfDimen(FONT0, self.blf_subtype.text)[0])
        # >>>
        return B
        #|
    def r_height(self, width): return D_SIZE['widget_full_h'] + (self.row_count - 1) * SIZE_widget[0]

    def is_dark(self): return False

    def i_dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)

        for e in self.blf_value:
            e.x += dx
            e.y += dy
        #|
    def i_dxy_subtype(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)

        for e in self.blf_value:
            e.x += dx
            e.y += dy

        self.blf_subtype.x += dx
        self.blf_subtype.y += dy
        #|
    def i_draw_blf(self):
        font_id = self.font_id
        sci_x, sci_y, sci_w, sci_h = scissor_get()
        scissor_set(*r_intersect_scissor(sci_x, sci_y, sci_w, sci_h, *self.box_button.inner))
        blfSize(font_id, D_SIZE['font_main'])
        blfColor(font_id, *COL_box_text_fg)
        for e in self.blf_value:
            blfPos(font_id, e.x, e.y, 0)
            blfDraw(font_id, e.text)
        scissor_set(sci_x, sci_y, sci_w, sci_h)
        #|
    def i_draw_blf_subtype(self):
        font_id = self.font_id
        sci_x, sci_y, sci_w, sci_h = scissor_get()
        scissor_set(*r_intersect_scissor(sci_x, sci_y, sci_w, sci_h, *self.box_button.inner))
        blfSize(font_id, D_SIZE['font_main'])
        blfColor(font_id, *COL_box_text_fg)
        for e in self.blf_value:
            blfPos(font_id, e.x, e.y, 0)
            blfDraw(font_id, e.text)
        scissor_set(sci_x, sci_y, sci_w, sci_h)

        e = self.blf_subtype
        blfSize(FONT0, D_SIZE['font_label'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.b_str == getattr(self.pp, self.rna.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.rna.identifier)
        self.b_str = v

        line_h = SIZE_widget[0]
        font_dx, font_dy, font_dT = r_widget_font_dx_dy_dT(self.font_id, line_h)
        x = self.box_button.inner[0] + font_dx
        blf_value.clear()
        self.headkey = 0
        count = self.row_count + 1
        if isinstance(v, str):
            lines = v.split('\n', count)
        else:
            lines = v.decode('utf-8').split('\n', count)
        if len(lines) > count: del lines[-1]

        y0 = self.box_button.inner[3] - font_dT
        for line in lines:
            blf_value.append(Blf(line, x, y0))
            y0 -= line_h
        #|
    #|
    #|
class ButtonStringObjectPath(       # ButtonString                                              
    ButtonString):
    __slots__ = 'box_icon_arrow', 'r_file'

    def __init__(self, w, rna, pp, r_file):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_icon_arrow = GpuImg_unfold()
        v = getattr(self.pp, rna.identifier)
        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.font_id = FONT0
        self.r_file = r_file
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        self.box_icon_arrow.LRBT_upd(R0 - SIZE_widget[0], R0, B0, T0)

        blf_value.x = L0 + D_SIZE['font_main_dx']
        blf_value.y = B0 + D_SIZE['font_main_dy']
        blf_value.unclip_text = ""
        blf_value.text = ""
        self.upd_data()
        return B
        #|

    def inside_evt(self):
        # <<< 1copy (0block_ButtonEnumObject_modal_update_picker_focus,, ${
        #     'Admin.REDRAW()': '',
        #     'GpuImg_object_picker_focus': 'GpuImg_unfold',
        #     'GpuImg_object_picker': 'GpuImg_unfold'
        # }$)
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                        self.box_icon_arrow.__class__ = GpuImg_delete_focus
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    
        else:
            region = 0
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    
        # >>>
        Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.is_dark() is True: return

        self.box_button.color = COL_box_text
        if self.get():
            self.box_icon_arrow.__class__ = GpuImg_delete
        else:
            self.box_icon_arrow.__class__ = GpuImg_unfold
        Admin.REDRAW()
        #|

    def modal(self):
        # <<< 1copy (0block_ButtonEnumObject_modal_update_picker_focus,, ${
        #     'GpuImg_object_picker_focus': 'GpuImg_unfold',
        #     'GpuImg_object_picker': 'GpuImg_unfold'
        # }$)
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                        self.box_icon_arrow.__class__ = GpuImg_delete_focus
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        Admin.REDRAW()

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    Admin.REDRAW()
        else:
            region = 0
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        Admin.REDRAW()

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    Admin.REDRAW()
        # >>>

        # <<< 1copy (0block_ButtonString_modal,, ${'self.to_dropdown()#ref':'self.evt_click(region)'}$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.evt_click(region)
            return True
        # >>>
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        cache_file = self.r_file()
        if cache_file:
            items = [Name(e.path)  for e in cache_file.object_paths]
        else:
            items = None

        return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=items, fixed_width=True)
        #|

    def evt_click(self, region=0):
        if region == 0:
            self.to_dropdown()
        else:
            if getattr(self.pp, self.rna.identifier):
                self.evt_delete_object()
            else:
                self.to_dropdown()
        #|
    def evt_delete_object(self):

        kill_evt_except()
        try:
            self.set("")
        except Exception as ex:
            DropDownOk(None, MOUSE, input_text=f'Unexpected error, please report to the author: 02\n{ex}')
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_icon_arrow.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        self.box_icon_arrow.bind_draw()
        #|
    def draw_blf(self):
        e = self.blf_value
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def set(self, v, refresh=True, undo_push=True):
        oldvalue = getattr(self.pp, self.rna.identifier)
        cache_file = self.r_file()
        if cache_file and v:
            if v not in {e.path  for e in cache_file.object_paths}: return

        setattr(self.pp, self.rna.identifier, v)
        if refresh: update_data()
        self.evt_undo_push(undo_push, oldvalue)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.rna.identifier)
        if v:
            if self.box_icon_arrow.__class__ != GpuImg_delete:
                self.box_icon_arrow.__class__ = GpuImg_delete
        else:
            if self.box_icon_arrow.__class__ != GpuImg_unfold:
                self.box_icon_arrow.__class__ = GpuImg_unfold

        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_icon_arrow.L - D_SIZE['font_main_dx'])
        #|
    #|
    #|
class ButtonStringFile(             # ButtonStringObjectPath                                    
    ButtonStringObjectPath):
    __slots__ = ()

    def __init__(self, w, rna, pp):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_icon_arrow = GpuImg_FILE_FOLDER()
        v = getattr(self.pp, rna.identifier)
        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.font_id = FONT0
        #|

    def inside_evt(self):
        # <<< 1copy (0block_ButtonStringFile_update_button_focus,, ${'Admin.REDRAW()':''}$)
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.box_icon_arrow.__class__ != GpuImg_FILE_FOLDER_focus:
                    self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER_focus
                    

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    
        else:
            region = 0
            if self.is_dark() is False:
                if self.box_icon_arrow.__class__ != GpuImg_FILE_FOLDER:
                    self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER
                    

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    
        # >>>
        Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.is_dark() is True: return

        self.box_button.color = COL_box_text
        self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER
        Admin.REDRAW()
        #|

    def modal(self):
        # /* 0block_ButtonStringFile_update_button_focus
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.box_icon_arrow.__class__ != GpuImg_FILE_FOLDER_focus:
                    self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER_focus
                    Admin.REDRAW()

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    Admin.REDRAW()
        else:
            region = 0
            if self.is_dark() is False:
                if self.box_icon_arrow.__class__ != GpuImg_FILE_FOLDER:
                    self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER
                    Admin.REDRAW()

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    Admin.REDRAW()
        # */

        # <<< 1copy (0block_ButtonString_modal,, ${'self.to_dropdown()#ref':'self.evt_click(region)'}$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.evt_click(region)
            return True
        # >>>
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        return DropDownString(self, self.box_button.r_LRBT(), self.get())
        #|
    def to_filebrowser(self):


        OpScanFile.end_fn = self.set
        bpy.ops.wm.vmd_scan_file("INVOKE_DEFAULT", filepath=self.get())
        #|

    def evt_click(self, region=0):
        if region == 0:
            self.to_dropdown()
        else:
            self.to_filebrowser()
        #|

    def set(self, v, refresh=True, undo_push=True):
        oldvalue = getattr(self.pp, self.rna.identifier)
        if self.rna.subtype == "BYTE_STRING" and not isinstance(v, bytes): v = str.encode(v)
        setattr(self.pp, self.rna.identifier, v)
        if refresh: update_data()

        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.rna.identifier)
        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_icon_arrow.L - D_SIZE['font_main_dx'])
        #|
    #|
    #|
class ButtonStringVector(           # ButtonString                                              
    ButtonString):
    __slots__ = ()

    def __init__(self, w, rna, pp, subtype_override=None):
        subtype = rna.subtype  if hasattr(rna, "subtype") else None
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp

        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        v = self.get()
        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.font_id = FONT0

        if subtype_override is None:
            if subtype in D_subtype_display:
                self.draw_blf = self.i_draw_blf_subtype
                self.dxy = self.i_dxy_subtype
                self.blf_subtype = BlfColor(D_subtype_display[rna.subtype], 0, 0, COL_box_button_fg_info)
            else:
                self.draw_blf = self.i_draw_blf
                self.dxy = self.i_dxy
        else:
            self.draw_blf = self.i_draw_blf_subtype
            self.dxy = self.i_dxy_subtype
            self.blf_subtype = BlfColor(subtype_override[0], 0, 0, COL_box_button_fg_info)
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        blf_value.x = L0 + D_SIZE['font_main_dx']
        blf_value.y = B0 + D_SIZE['font_main_dy']
        v = [v  for v in getattr(self.pp, self.rna.identifier)]
        blf_value.unclip_text = v
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(rs_format_float6_vec(v),
            blf_value.x, R0 - D_SIZE['font_main_dx'])

        # <<< 1copy (0block_ButtonInt_init_subtype,, $$)
        if hasattr(self, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            self.blf_subtype.y = T - SIZE_border[3] - D_SIZE['font_label_dT']
            self.blf_subtype.x = L - D_SIZE['font_label_dx'] - ceil(blfDimen(FONT0, self.blf_subtype.text)[0])
        # >>>
        return B
        #|

    def r_default_value(self): return self.rna.default_array

    def to_dropdown(self, killevt=True, select_all=None):

        return DropDownString(self, self.box_button.r_LRBT(), ", ".join("{:.16f}".format(v)  for v in self.get()))
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        kill_evt_except()
        s = ""
        fac = r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, None)
        for e in self.get(): s += f'{value_to_display(e / fac)}, '

        bpy.context.window_manager.clipboard = s[: -2]
        if is_report: report("Copy to Clipboard")
        #|

    def set(self, v, refresh=True, undo_push=True):
        oldvalue = getattr(self.pp, self.rna.identifier)
        array_length = self.rna.array_length
        if isinstance(v, str): v = calc_vec(v)

        le = len(v)
        if le < array_length:
            new_v = [0.0] * array_length
            new_v[ : le] = v
            v = new_v
        else:
            v = v[ : array_length]

        v = Vector(v).normalized()
        setattr(self.pp, self.rna.identifier, list(v))
        if refresh: update_data()

        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return


        blf_value = self.blf_value
        v = [v  for v in getattr(self.pp, self.rna.identifier)]
        blf_value.unclip_text = v
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(rs_format_float6_vec(v),
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'])
        #|
    #|
    #|
class ButtonStringColorHex(ButtonString):
    __slots__ = 'set_callfront'

    def set(self, v, refresh=True, undo_push=True):
        self.set_callfront(v.strip().replace(" ", "").replace("0x", "").replace("#", ""))
        #|
    #|
    #|
class ButtonFn:
    __slots__ = (
        'w',
        'rna',
        'fn',
        'box_button',
        'blf_value',
        'is_trigger_enable',
        'is_repeat',
        'set_callback',
        'poll')

    def __init__(self, w, rna, fn):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = GpuButton()
        self.blf_value = BlfClipColor("", rna.default, 0, 0, COL_box_button_fg)
        #|

    def init_bat(self, L, R, T):
        widget_rim = SIZE_border[3]
        B = T - D_SIZE['widget_full_h']
        if hasattr(self.rna, "size") and self.rna.size != 0:
            if self.rna.size < 0:
                L = max(L, round(R - widget_rim + SIZE_widget[0] * self.rna.size - widget_rim))
            else:
                R = min(R, round(L + widget_rim + SIZE_widget[0] * self.rna.size + widget_rim))

        self.box_button.LRBT_upd(L, R, B, T, widget_rim)
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        d = D_SIZE['font_main_dx'] + SIZE_border[3]
        blf_value = self.blf_value
        blf_value.text = r_blf_clipping_end(self.rna.default, d, R - L - d)

        blf_value.x = floor((R + L - blfDimen(FONT0, blf_value.text)[0]) / 2)
        blf_value.y = B + widget_rim + D_SIZE['font_main_dy']
        return B
        #|
    def r_height(self, width): return D_SIZE['widget_full_h']
    def r_override_width(self): return SIZE_border[3] * 2 + round(abs(SIZE_widget[0] * self.rna.size))
    def set_button_text(self, s):
        e = self.box_button
        L = e.L
        R = e.R
        B = e.B
        self.blf_value.text = s
        blfSize(FONT0, D_SIZE['font_main'])
        self.blf_value.x = floor((R + L - blfDimen(FONT0, self.blf_value.text)[0]) / 2)
        self.blf_value.y = B + SIZE_border[3] + D_SIZE['font_main_dy']
        #|

    def is_dark(self): return self.box_button.is_dark()
    def dark(self):
        self.box_button.dark()
        self.blf_value.color = COL_box_button_fg_ignore
        #|
    def light(self):
        self.box_button.light()
        self.blf_value.color = COL_box_button_fg
        #|

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        Admin.REDRAW()
        self.box_button.set_state_focus()
        self.is_trigger_enable = True
        #|
    def outside_evt(self):
        if self.is_repeat:
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
        Admin.REDRAW()
        self.box_button.set_state_default()
        #|

    def modal(self):
        if self.is_dark(): return False
        if self.is_trigger_enable is True:
            if TRIGGER['click']():
                Admin.REDRAW()
                self.is_trigger_enable = False
                self.box_button.set_state_press()
                self.fn()  if self.fn.__defaults__ is None else self.fn(self)
                if self.is_repeat: self.reg_repeat_timer()
                return True
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        else:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                if self.is_repeat:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                self.is_trigger_enable = True
                self.box_button.set_state_focus()
                Admin.REDRAW()

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True
        return False
        #|

    def to_modal_rm(self):

        if not self.rna: return

        items = [("detail", self.evt_area_detail)]
        append_rm_item_operator(items, self.rna)

        DropDownRMKeymap(self, MOUSE, items, title=self.rna.name)
        #|
    def evt_area_detail(self):

        kill_evt_except()
        if not self.rna: return
        Detail(Detail.r_rna_info(self.rna))
        #|

    def reg_repeat_timer(self):
        global _timer_button_fn
        _timer_button_fn = self.fn

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        #|
    def draw_blf(self):
        e = self.blf_value
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self): pass
    #|
    #|
class ButtonFnFreeSize(             # ButtonFn                                                  
    ButtonFn):
    __slots__ = 'height'

    def __init__(self, w, rna, fn, font_size, height):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = GpuButton()
        self.height = height

        # <<< 1copy (init_blf_clipping_end,, ${"D_SIZE['font_size']":'font_size'}$)
        blfSize(FONT0, font_size)
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        font_dx, font_dy, font_dT = r_widget_font_dx_dy_dT(FONT0, height)
        d = font_dx + SIZE_border[3]
        self.blf_value = BlfClipColor(r_blf_clipping_end(
            rna.default, d, D_SIZE['widget_width'] - d), rna.default, 0, 0, COL_box_button_fg)
        self.blf_value.size = font_size
        #|

    def init_bat(self, L, R, T):
        widget_rim = SIZE_border[3]
        B = T - self.height - widget_rim - widget_rim
        if hasattr(self.rna, "size") and self.rna.size != 0:
            if self.rna.size < 0:
                L = max(L, round(R - widget_rim + self.height * self.rna.size - widget_rim))
            else:
                R = min(R, round(L + widget_rim + self.height * self.rna.size + widget_rim))
        self.box_button.LRBT_upd(L, R, B, T, widget_rim)
        blfSize(FONT0, self.blf_value.size)
        self.blf_value.x = floor((R + L - blfDimen(FONT0, self.blf_value.text)[0]) / 2)
        self.blf_value.y = B + widget_rim + r_widget_font_dx_dy_dT(FONT0, self.height)[1]
        return B
        #|
    def r_height(self, width): return self.height + SIZE_border[3] * 2
    def r_override_width(self): return SIZE_border[3] * 2 + round(abs(self.height * self.rna.size))

    def draw_blf(self):
        e = self.blf_value
        blfSize(FONT0, e.size)
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|
    #|
    #|
class ButtonFnImg(                  # ButtonFn                                                  
    ButtonFn):
    __slots__ = 'box_img', 'imgLight', 'imgDark'

    def __init__(self, w, rna, fn, imgLight, imgDark=None):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.imgLight = imgLight
        self.imgDark = imgDark
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = GpuButton()
        self.box_img = getattr(blg, imgLight)()
        #|

    def init_bat(self, L, R, T):
        widget_rim = SIZE_border[3]
        B = T - D_SIZE['widget_full_h']
        if hasattr(self.rna, "size") and self.rna.size != 0:
            if self.rna.size < 0:
                L = max(L, round(R - widget_rim + SIZE_widget[0] * self.rna.size - widget_rim))
            else:
                R = min(R, round(L + widget_rim + SIZE_widget[0] * self.rna.size + widget_rim))
        self.box_button.LRBT_upd(L, R, B, T, widget_rim)
        self.box_img.LRBT_upd(*self.box_button.inner)
        return B
        #|

    def is_dark(self): return self.box_button.__class__.__name__ == self.imgDark
    def dark(self):
        if self.box_img.__class__.__name__ == self.imgDark: return
        self.box_img.__class__ = getattr(blg, self.imgDark)
        self.box_img.upd()
        Admin.REDRAW()
        #|
    def light(self):
        if self.box_img.__class__.__name__ == self.imgLight: return
        self.box_img.__class__ = getattr(blg, self.imgLight)
        self.box_img.upd()
        Admin.REDRAW()
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_img.dxy_upd(dx, dy)
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        self.box_img.bind_draw()
        #|
    def draw_blf(self): pass
    #|
    #|
class ButtonFnImgHover(             # ButtonFn                                                  
    ButtonFn):
    __slots__ = 'box_hover', 'imgLight', 'imgDark'

    def __init__(self, w, rna, fn, imgLight, imgDark=None):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.imgLight = imgLight
        self.imgDark = imgDark
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = getattr(blg, imgLight)()
        #|

    def init_bat(self, L, R, T):
        B = T - R + L
        self.box_button.LRBT_upd(L, R, B, T)
        self.box_hover = None
        return B
        #|
    def r_height(self, width): return SIZE_widget[0]

    def is_dark(self): return self.box_button.__class__.__name__ == self.imgDark
    def dark(self):
        if self.box_button.__class__.__name__ == self.imgDark: return
        self.box_button.__class__ = getattr(blg, self.imgDark)
        self.box_button.upd()
        Admin.REDRAW()
        #|
    def light(self):
        if self.box_button.__class__.__name__ == self.imgLight: return
        self.box_button.__class__ = getattr(blg, self.imgLight)
        self.box_button.upd()
        Admin.REDRAW()
        #|
    def inside_evt(self):
        Admin.REDRAW()
        self.box_hover = GpuImg_area_icon_hover(*self.box_button.r_LRBT())
        self.box_hover.upd()
        self.is_trigger_enable = True
        #|
    def outside_evt(self):
        if self.is_repeat:
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
        Admin.REDRAW()
        self.box_hover = None
        #|

    def modal(self):
        if self.is_trigger_enable is True:
            if TRIGGER['click']():
                Admin.REDRAW()
                self.is_trigger_enable = False
                # self.box_button.set_state_press()
                self.fn()
                if self.is_repeat: self.reg_repeat_timer()
                return True
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        else:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                if self.is_repeat:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                self.is_trigger_enable = True
                # self.box_button.set_state_focus()
                Admin.REDRAW()

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True
        return False
        #|

    def to_modal_rm(self):

        kill_evt_except()
        if self.rna == None: return

        DropDownRMKeymap(self, MOUSE, [
            ("detail", self.evt_area_detail),
        ], title=self.rna.name)
        #|

    def evt_area_detail(self):

        kill_evt_except()
        if self.rna == None: return
        Detail(Detail.r_rna_info(self.rna))
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        if self.box_hover != None: self.box_hover.dxy_upd(dx, dy)
        #|
    def draw_box(self):
        if self.box_hover != None: self.box_hover.bind_draw()
        self.box_button.bind_draw()
        #|
    def draw_blf(self): pass
    #|
    #|
class ButtonFnImgHoverKeyframe(     # ButtonFnImgHover                                          
    ButtonFnImgHover):
    __slots__ = ()

    def __init__(self, w, rna, fn):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.is_repeat = False
        self.box_button = GpuImg_keyframe_false()
        #|

    def modal(self):
        if self.is_trigger_enable is True:
            if TRIGGER['click']():
                Admin.REDRAW()
                self.is_trigger_enable = False
                if is_first_press('click') == False:
                    boo = self.box_button.__class__ in {
                        GpuImg_keyframe_current_true_even,
                        GpuImg_keyframe_current_true_odd}
                    if _last_bool_state[0] != boo:
                        self.fn()
                else:
                    self.fn()
                    _last_bool_state[0] = self.box_button.__class__ in {
                        GpuImg_keyframe_current_true_even,
                        GpuImg_keyframe_current_true_odd}

                if self.is_repeat: self.reg_repeat_timer()
                return True
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        else:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                if self.is_repeat:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                self.is_trigger_enable = True
                # self.box_button.set_state_focus()
                Admin.REDRAW()

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True
        return False
        #|
    #|
    #|
class ButtonFnImgHoverKeyframeRef(  # ButtonFnImgHover                                          
    ButtonFnImgHover):
    __slots__ = ()

    def __init__(self, w, rna, fn):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.is_repeat = False
        self.box_button = GpuImgNull()
        #|

    def inside_evt(self):
        if self.box_button.__class__ == GpuImgNull:
            self.is_trigger_enable = True
            return
        super().inside_evt()
        #|
    #|
    #|
class ButtonFnImgList(              # ButtonFn                                                  
    ButtonFn): # h = SIZE_widget[0]
    __slots__ = 'L', 'R', 'inside_evt_callback', 'outside_evt_callback'

    BLF_X = 0
    BLF_OFFSET_Y = 0
    IMG_L = 0
    IMG_R = 0
    H = 0

    @classmethod
    def set_offset(cls, L, blf_offset_y, outer, h):
        cls.BLF_OFFSET_Y = blf_offset_y
        cls.H = h
        cls.IMG_L = L + outer
        cls.IMG_R = cls.IMG_L + h
        cls.BLF_X = cls.IMG_R + blf_offset_y
        #|

    def __init__(self, w, rna, fn, imgLight, title, font_color, inside_evt_callback, outside_evt_callback):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.inside_evt_callback = inside_evt_callback
        self.outside_evt_callback = outside_evt_callback
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = getattr(blg, imgLight)()
        self.blf_value = BlfClipColor(self, unclip_text=title, color=font_color)
        #|

    def init_bat_dimen(self, L, R, T): # need set_offset, init_blf_clipping_end
        self.L = L
        self.R = R
        blf_value = self.blf_value
        B = T - ButtonFnImgList.H
        self.box_button.LRBT_upd(ButtonFnImgList.IMG_L, ButtonFnImgList.IMG_R, B, T)
        blf_value.x = ButtonFnImgList.BLF_X
        blf_value.y = B + ButtonFnImgList.BLF_OFFSET_Y
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text,
            blf_value.x, R - ButtonFnImgList.BLF_OFFSET_Y)
        return B
    def init_bat(self, L, R, T):
        self.L = L
        self.R = R
        blf_value = self.blf_value
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        L += SIZE_setting_list_border[0]
        R = L + SIZE_widget[0]
        B = T - SIZE_widget[0]
        self.box_button.LRBT_upd(L, R, B, T)
        blf_value.x = R + D_SIZE['font_main_dy']
        blf_value.y = B + D_SIZE['font_main_dy']
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text,
            blf_value.x, R - D_SIZE['font_main_dy'])
        return B
        #|
    def r_height(self, width): return SIZE_widget[0]

    def inside(self, mouse):
        return self.box_button.B <= mouse[1] < self.box_button.T and self.L <= mouse[0] < self.R
        #|
    def inside_evt(self):
        Admin.REDRAW()
        self.is_trigger_enable = True
        self.inside_evt_callback(self)
        #|
    def outside_evt(self):
        if self.is_repeat:
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
        Admin.REDRAW()
        self.outside_evt_callback(self)
        #|

    def modal(self):
        if self.is_trigger_enable is True:
            if TRIGGER['click']():
                Admin.REDRAW()
                self.is_trigger_enable = False
                # self.box_button.set_state_press()
                self.fn()
                if self.is_repeat: self.reg_repeat_timer()
                return True
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        else:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                if self.is_repeat:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                self.is_trigger_enable = True
                # self.box_button.set_state_focus()
                Admin.REDRAW()

        if hasattr(self, "submodal"):
            if self.submodal(): return True
        return False
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.blf_value.x += dx
        self.blf_value.y += dy
        self.L += dx
        self.R += dx
        #|
    #|
    #|
class ButtonFnBlf(                  # ButtonFn                                                  
    ButtonFn):
    __slots__ = 'inside_evt_callback', 'outside_evt_callback'

    BLF_X = 0
    BLF_OFFSET_Y = 0
    H = 0

    @classmethod
    def set_offset(cls, L, blf_offset_x, blf_offset_y, h):
        cls.BLF_OFFSET_Y = blf_offset_y
        cls.H = h
        cls.BLF_X = L + blf_offset_x
        #|

    def __init__(self, w, rna, fn, title, font_color, inside_evt_callback, outside_evt_callback):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.inside_evt_callback = inside_evt_callback
        self.outside_evt_callback = outside_evt_callback
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = GpuBox()
        self.blf_value = BlfClipColor(self, unclip_text=title, color=font_color)
        #|

    def init_bat_dimen(self, L, R, T): # need set_offset, init_blf_clipping_end
        blf_value = self.blf_value
        B = T - ButtonFnBlf.H
        self.box_button.LRBT(L, R, B, T)
        blf_value.x = ButtonFnBlf.BLF_X
        blf_value.y = B + ButtonFnBlf.BLF_OFFSET_Y
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text,
            blf_value.x, R - ButtonFnBlf.BLF_OFFSET_Y)
        return B
        #|
    def init_bat(self, L, R, T):
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value = self.blf_value
        B = T - SIZE_widget[0]
        self.box_button.LRBT(L, R, B, T)
        blf_value.x = L + D_SIZE['font_main_dx']
        blf_value.y = B + D_SIZE['font_main_dy']
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text,
            blf_value.x, R - D_SIZE['font_main_dy'])
        return B
        #|
    def r_height(self, width): return SIZE_widget[0]

    def inside_evt(self):
        Admin.REDRAW()
        self.is_trigger_enable = True
        self.inside_evt_callback(self)
        #|
    def outside_evt(self):
        if self.is_repeat:
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
        Admin.REDRAW()
        self.outside_evt_callback(self)
        #|

    def modal(self):
        if self.is_trigger_enable is True:
            if TRIGGER['click']():
                Admin.REDRAW()
                self.is_trigger_enable = False
                # self.box_button.set_state_press()
                self.fn()
                if self.is_repeat: self.reg_repeat_timer()
                return True
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        else:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                if self.is_repeat:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                self.is_trigger_enable = True
                # self.box_button.set_state_focus()
                Admin.REDRAW()

        if hasattr(self, "submodal"):
            if self.submodal(): return True
        return False
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy(dx, dy)
        self.blf_value.x += dx
        self.blf_value.y += dy
        #|

    def draw_box(self): pass
    #|
    #|
class StructButtonEnum:
    __slots__ = ()

    def r_default_value(self): return self.rna.default

    # /* 0block_StructButtonEnum_evt_set
    @ catch
    def to_modal_rm(self):


        DropDownRMKeymap(self, MOUSE, [
            ("dd_cut", self.evt_area_cut),
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ], override_name={"dd_cut":"Copy Identifier"}, title=self.rna.name)
        #|

    @ catch
    def evt_area_cut(self, is_report=True):

        kill_evt_except()
        ob = self.get()
        if hasattr(ob, "name"):
            ob = r_ID_dp(ob)

        bpy.context.window_manager.clipboard = f'{ob}'
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        kill_evt_except()

        if hasattr(self.rna, "enum_items"):
            v = self.get()
            if v == None: s = "None"
            elif isinstance(v, set):
                ls = [e.name  for e in self.rna.enum_items  if e.identifier in v]
                s = str(ls).replace("[", "{").replace("]", "}")
            else:
                s = self.rna.enum_items[v].name  if v in self.rna.enum_items else v
        else:
            s = self.get()

        bpy.context.window_manager.clipboard = f'{s}'
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            self.set(s)
            Admin.REDRAW()
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_reset_single(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_reset_all(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_detail(self):

        kill_evt_except()
        Detail(Detail.r_rna_info(self.rna))
        #|

    def get(self):
        return getattr(self.pp, self.rna.identifier)
        #|
    def set(self, v, refresh=True, undo_push=True): # allow input name, Nonetype
        rna = self.rna
        oldvalue = getattr(self.pp, rna.identifier)
        if v in rna.enum_items:
            setattr(self.pp, rna.identifier, v)
            if refresh: update_data()
            if hasattr(self, "set_callback"): self.set_callback()
            self.evt_undo_push(undo_push, oldvalue)
        else:
            if v == None:
                if hasattr(rna, "is_never_none") and rna.is_never_none: return
            else:
                for e in rna.enum_items:
                    if e.name == v:
                        setattr(self.pp, rna.identifier, e.identifier)
                        if refresh: update_data()
                        if hasattr(self, "set_callback"): self.set_callback()
                        self.evt_undo_push(undo_push, oldvalue)
                        return
    # */
    def evt_undo_push(self, undo_push, oldvalue): pass
    #|
    #|
class ButtonEnum(                   # StructButtonEnum          ButtonString                    
    StructButtonEnum, ButtonString):
    __slots__ = 'box_icon_arrow', 'get_icon'

    def __init__(self, w, rna, pp):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_icon_arrow = GpuImg_unfold()
        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.font_id = FONT0
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        self.box_icon_arrow.LRBT_upd(R0 - SIZE_widget[0], R0, B0, T0)

        blf_value.x = L0 + D_SIZE['font_main_dx']
        blf_value.y = B0 + D_SIZE['font_main_dy']
        blf_value.unclip_text = ""
        blf_value.text = ""
        self.upd_data()
        return B
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        if hasattr(self, "poll") and self.poll(self) == False: return

        v = self.get()
        if v == None: v = "None"
        elif hasattr(self.rna, "enum_items"):
            if v in self.rna.enum_items: v = self.rna.enum_items[v].name

        if hasattr(self, "D_icon"):
            D_icon = self.D_icon
            def get_icon(e):
                if hasattr(e, "identifier"):
                    return D_icon[e.identifier]()  if e.identifier in D_icon else GpuImgNull()

                return D_icon[e.name]()  if e.name in D_icon else GpuImgNull()
        else:
            get_icon = self.get_icon  if hasattr(self, "get_icon") else None

        return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, get_icon=get_icon)
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_icon_arrow.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        self.box_icon_arrow.bind_draw()
        #|
    def draw_blf(self):
        e = self.blf_value
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        blf_value = self.blf_value
        if blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return

        v = getattr(self.pp, self.rna.identifier)
        blf_value.unclip_text = v
        if v == None: v = "None"
        elif hasattr(self.rna, "enum_items"):
            if v in self.rna.enum_items: v = self.rna.enum_items[v].name

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - SIZE_widget[0])
        #|
    #|
    #|
class ButtonEnumIcon(               # ButtonEnum                                                
    ButtonEnum):
    __slots__ = 'box_icon_object', 'D_icon'

    def __init__(self, w, rna, pp, D_icon, default_icon=None):
        super().__init__(w, rna, pp)

        self.box_icon_object = default_icon
        self.D_icon = D_icon

        if D_icon:
            D_geticon_DriverVar = blg.D_geticon_DriverVar
            def get_icon(e):
                if hasattr(e, "identifier") and e.identifier in D_geticon_DriverVar:
                    return D_geticon_DriverVar[e.identifier]()
                return GpuImgNull()

            self.get_icon = get_icon
        else:
            self.get_icon = None
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        self.box_icon_arrow.LRBT_upd(R0 - SIZE_widget[0], R0, B0, T0)

        if self.box_icon_object is None: pass
        else:
            LL = L0
            L0 += SIZE_widget[0]
            self.box_icon_object.LRBT_upd(LL, L0, B0, T0)

        blf_value.x = L0 + D_SIZE['font_main_dx']
        blf_value.y = B0 + D_SIZE['font_main_dy']
        blf_value.unclip_text = ""
        blf_value.text = ""
        self.upd_data()
        return B
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_icon_arrow.dxy_upd(dx, dy)
        if self.box_icon_object is not None:
            self.box_icon_object.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        self.box_icon_arrow.bind_draw()
        if self.box_icon_object is not None:
            self.box_icon_object.bind_draw()
        #|

    def upd_data(self):
        # super
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        blf_value = self.blf_value
        if blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return

        v = getattr(self.pp, self.rna.identifier)
        blf_value.unclip_text = v

        L0, R0, B0, T0 = self.box_button.inner
        self.box_icon_object = self.D_icon[v]  if v in self.D_icon else None
        if self.box_icon_object is None: pass
        else:
            self.box_icon_object = self.box_icon_object()
            LL = L0
            L0 += SIZE_widget[0]
            self.box_icon_object.LRBT_upd(LL, L0, B0, T0)

        blf_value.x = L0 + D_SIZE['font_main_dx']

        if v == None: v = "None"
        elif hasattr(self.rna, "enum_items"):
            if v in self.rna.enum_items: v = self.rna.enum_items[v].name

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - SIZE_widget[0])
        #|
    #|
    #|
class ButtonEnumXY(                 # StructButtonEnum                                          
    StructButtonEnum):
    __slots__ = (
        'w',
        'rna',
        'pp',
        'r_pp',
        'r_object',
        'r_datapath_head',
        'box_button',
        'blf_value',
        'row_length',
        'focus_index',
        'is_trigger_enable',
        'enum_value',
        'set_callback',
        'poll')

    def __init__(self, w, rna, pp, row_length=1):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.row_length = row_length
        self.box_button = [GpuButtonBool()  for e in rna.enum_items]
        self.blf_value = [BlfColor(e.name, color=COL_box_button_fg)  for e in rna.enum_items]
        self.enum_value = ""
        #|

    def init_bat(self, L, R, T):
        blfSize(FONT0, D_SIZE['font_main'])
        row_length = self.row_length
        box_button = self.box_button
        blf_value = self.blf_value
        widget_rim = SIZE_border[3]
        full_h = D_SIZE['widget_full_h']
        width = (R - L) // row_length
        range_row = range(row_length)
        LRs = []
        R0 = L + width
        for _ in range_row:
            LRs.append([L, R0])
            L = R0
            R0 += width
        LRs[-1][1] = R
        B = T - full_h
        y = B + widget_rim + D_SIZE['font_main_dy']

        i = 0
        amount = len(box_button) // row_length
        for _ in range(amount):
            for r in range_row:
                # /* 0block_ButtonEnumXY_initbutton
                L0, R0 = LRs[r]
                box_button[i].LRBT_upd(L0, R0, B, T, widget_rim)
                e = blf_value[i]
                e.y = y
                e.x = floor((R0 + L0 - blfDimen(FONT0, e.text)[0]) / 2)
                i += 1
                # */

            T = B
            B -= full_h
            y -= full_h

        for r in range(len(box_button) - amount * row_length):
            # <<< 1copy (0block_ButtonEnumXY_initbutton,, $$)
            L0, R0 = LRs[r]
            box_button[i].LRBT_upd(L0, R0, B, T, widget_rim)
            e = blf_value[i]
            e.y = y
            e.x = floor((R0 + L0 - blfDimen(FONT0, e.text)[0]) / 2)
            i += 1
            # >>>

        self.upd_data()
        return box_button[-1].B
        #|
    def r_height(self, width): return D_SIZE['widget_full_h'] * ceil(len(self.box_button) / self.row_length)

    def is_dark(self): return self.box_button[0].is_dark()
    def dark(self):
        for e in self.box_button: e.dark()
        for e in self.blf_value: e.color = COL_box_button_fg_ignore
        #|
    def light(self):
        for e in self.box_button: e.light()
        for e in self.blf_value: e.color = COL_box_button_fg
        #|

    def r_focus_index(self, mouse):
        for r, e in enumerate(self.box_button):
            if e.inbox(mouse): return r
        return None
        #|
    def fn(self, i):

        Admin.REDRAW()
        v = self.rna.enum_items[i].identifier
        self.set(v)
        #|

    def focus_button(self, i):
        if self.box_button[i].state == 0:
            self.box_button[i].set_state_off_focus()
        #|
    def unfocus_button(self, i):
        if self.box_button[i].state == 1:
            self.box_button[i].set_state_off()
        #|
    def turnon_button(self, i):
        if self.box_button[i].state in {0, 1}:
            self.box_button[i].set_state_on()
        #|
    def turnoff_button(self, i):
        if self.box_button[i].state == 2:
            self.box_button[i].set_state_off()
        #|

    def inside(self, mouse):
        box_button = self.box_button
        if mouse[0] < box_button[0].L: return False
        if mouse[0] > box_button[self.row_length - 1].R: return False
        if mouse[1] > box_button[0].T: return False
        if mouse[1] < box_button[-1].B: return False
        return True
        #|
    def inside_evt(self):
        self.focus_index = self.r_focus_index(MOUSE)
        if self.focus_index != None:
            self.focus_button(self.focus_index)
            Admin.REDRAW()
        self.is_trigger_enable = True
        #|
    def outside_evt(self):
        if hasattr(self, "focus_index"):
            if self.focus_index != None:
                self.unfocus_button(self.focus_index)
                Admin.REDRAW()
        #|

    def modal(self):
        i = self.r_focus_index(MOUSE)
        if i != self.focus_index:

            if self.focus_index != None:
                self.unfocus_button(self.focus_index)
                Admin.REDRAW()

            self.focus_index = i
            self.is_trigger_enable = True

            if i != None:
                self.focus_button(i)
                Admin.REDRAW()

        if i == None: return False

        allow_trigger = self.is_trigger_enable
        if not allow_trigger:
            if EVT_TYPE[0] == "TIMER_REPORT": pass
            else:
                if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                    self.is_trigger_enable = True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if allow_trigger:
            if TRIGGER['click']():
                self.is_trigger_enable = False
                self.fn(i)
                return True
        return False
        #|

    def dxy(self, dx, dy):
        for e in self.box_button: e.dxy_upd(dx, dy)
        for e in self.blf_value:
            e.x += dx
            e.y += dy
        #|
    def draw_box(self):
        for e in self.box_button: e.bind_draw()
        #|
    def draw_blf(self):
        blfSize(FONT0, D_SIZE['font_main'])
        for e in self.blf_value:
            blfColor(FONT0, *e.color)
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.enum_value == self.get(): return
        v = self.get()

        if v in self.rna.enum_items:
            for r, e in enumerate(self.rna.enum_items):
                self.turnon_button(r)  if e.identifier == v else self.turnoff_button(r)
        else:
            for r, e in enumerate(self.rna.enum_items): self.turnoff_button(r)

        self.enum_value = v
        #|
    #|
    #|
class ButtonEnumXYFlag(             # ButtonEnumXY                                              
    ButtonEnumXY):
    __slots__ = ()

    def r_default_value(self):
        v = self.rna.default
        if v: return v
        return set()
        #|

    def fn(self, i):

        Admin.REDRAW()
        old_v = self.get()
        v = self.rna.enum_items[i].identifier

        if old_v:
            new_v = old_v.copy()
            if v in new_v:
                new_v.remove(v)
            else:
                new_v.add(v)

            self.set(new_v)
        else:
            self.set(v)
        #|

    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            self.set(s)
            Admin.REDRAW()
        except:
            if is_report: report("Input Error")
        #|

    def set(self, v, refresh=True, undo_push=True): # str or set, None, allow input name
        rna = self.rna
        oldvalue = getattr(self.pp, rna.identifier)
        if v == None: v = set()
        if isinstance(v, str):
            if v.startswith("{"):
                v = calc_py_exp(v)
                if not isinstance(v, set): return
            else:
                v = {v}

        name_to_id = {e.name: identifier  for identifier, e in rna.enum_items.items()}

        try:
            setattr(self.pp, rna.identifier, {(name_to_id[v]  if v in name_to_id else v)  for v in v})
            if refresh: update_data()

            if hasattr(self, "set_callback"): self.set_callback()
            self.evt_undo_push(undo_push, oldvalue)
        except: return
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.enum_value == self.get(): return
        v = self.get()

        if v:
            for r, e in enumerate(self.rna.enum_items):
                self.turnon_button(r)  if e.identifier in v else self.turnoff_button(r)
        else:
            for r, e in enumerate(self.rna.enum_items): self.turnoff_button(r)

        self.enum_value = v
        #|
    #|
    #|
class ButtonEnumXYFlagPython(ButtonEnumXYFlag):
    __slots__ = ()

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.enum_value == self.get(): return
        v = self.get().copy()

        if v:
            for r, e in enumerate(self.rna.enum_items):
                self.turnon_button(r)  if e.identifier in v else self.turnoff_button(r)
        else:
            for r, e in enumerate(self.rna.enum_items): self.turnoff_button(r)

        self.enum_value = v
        #|
    #|
    #|
class ButtonEnumObject(             # ButtonEnum                                                
    ButtonEnum):
    __slots__ = 'allow_types', 'r_except_objects', 'box_icon_object'

    def __init__(self, w, rna, pp, allow_types=None, r_except_objects=None):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_icon_arrow = GpuImg_object_picker()
        v = self.get()
        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.font_id = FONT0

        self.allow_types = allow_types
        self.r_except_objects = r_except_objects
        if allow_types is None:
            self.box_icon_object = GpuImg_OBJECT_DATA()
        else:
            if len(allow_types) == 1:
                for allow_type in allow_types: break
                self.box_icon_object = getattr(blg, f"GpuImg_OUTLINER_OB_{allow_type}", GpuImg_OBJECT_DATA)()
            else: self.box_icon_object = GpuImg_OBJECT_DATA()
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        self.box_icon_arrow.LRBT_upd(R0 - SIZE_widget[0], R0, B0, T0)
        LL = L0
        L0 += SIZE_widget[0]
        self.box_icon_object.LRBT_upd(LL, L0, B0, T0)

        blf_value.x = L0 + D_SIZE['font_main_dx']
        blf_value.y = B0 + D_SIZE['font_main_dy']
        blf_value.unclip_text = ""
        blf_value.text = ""
        self.upd_data()
        return B
        #|

    def r_default_value(self): return None

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        # <<< 1copy (0block_ButtonEnumObject_modal_update_picker_focus,, ${'Admin.REDRAW()':''}$)
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                        self.box_icon_arrow.__class__ = GpuImg_delete_focus
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_object_picker_focus:
                        self.box_icon_arrow.__class__ = GpuImg_object_picker_focus
                        

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    
        else:
            region = 0
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_object_picker:
                        self.box_icon_arrow.__class__ = GpuImg_object_picker
                        

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    
        # >>>
        Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.is_dark() is True: return

        self.box_button.color = COL_box_text
        if self.get():
            self.box_icon_arrow.__class__ = GpuImg_delete
        else:
            self.box_icon_arrow.__class__ = GpuImg_object_picker
        Admin.REDRAW()
        #|

    def modal(self):
        # /* 0block_ButtonEnumObject_modal_update_picker_focus
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                        self.box_icon_arrow.__class__ = GpuImg_delete_focus
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_object_picker_focus:
                        self.box_icon_arrow.__class__ = GpuImg_object_picker_focus
                        Admin.REDRAW()

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    Admin.REDRAW()
        else:
            region = 0
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_object_picker:
                        self.box_icon_arrow.__class__ = GpuImg_object_picker
                        Admin.REDRAW()

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    Admin.REDRAW()
        # */

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['dd_preview']():
            if hasattr(self, "evt_area_preview"):
                self.evt_area_preview()
                return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.evt_click(region)
            return True
        return False
        #|

    def to_modal_rm(self): pass

    def to_dropdown(self, killevt=True, select_all=None):


        return DropDownEnumPointer(self, self.box_button.r_LRBT(), self.rna.name,
            bpy.data.objects,
            self.allow_types,
            self.r_except_objects)
        #|
    def to_modal_picker(self):

        modal_object_picker_init(self.allow_types, self.r_except_objects, self.set)
        #|

    @ catch
    def evt_click(self, region=0):
        if region == 0:
            self.to_dropdown()
        else:
            if self.get():
                self.evt_delete_object()
            else:
                self.to_modal_picker()
        #|
    @ catch
    def evt_delete_object(self):

        kill_evt_except()
        try:
            self.set(None)
        except Exception as ex:
            DropDownOk(None, MOUSE, input_text=f'Unexpected error, please report to the author: 03\n{ex}')
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            if s.startswith(";"):
                if s.startswith(";;"): s = s[1 :]
                else:
                    self.set(calc_py_exp(s[1 :]))
                    Admin.REDRAW()
                    return

            self.set(s)
            Admin.REDRAW()
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        kill_evt_except()
        ob = self.get()
        if ob == None: tx = ";None"
        else:
            if hasattr(ob, "library") and ob.library:
                tx = f';{r_ID_dp(ob)}'
            else:
                tx = ob.name
                if tx.startswith(";"): tx = ";" + tx

        bpy.context.window_manager.clipboard = tx
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_jump_to_target(self):

        kill_evt_except()
        if object_select(self.get(), "EXTEND"):
            ed_undo_push(message=f'jump to target "{self.get().name}"')
        #|
    @ catch
    def evt_mark_asset(self, is_report=True):

        kill_evt_except()
        ob = self.get()
        if ob == None: return
        try:
            if ob.asset_data:
                ob.asset_clear()
                if is_report: report(f'"{ob.name}" is not an asset anymore')
                ed_undo_push(message=f'clear asset "{ob.name}"')
            else:
                ob.asset_mark()
                if is_report: report(f'"{ob.name}" is now an asset')
                ed_undo_push(message=f'mark asset "{ob.name}"')

            update_data()
        except Exception as ex:
            if is_report: DropDownOk(None, MOUSE, input_text=str(ex))
        #|
    @ catchBug
    def evt_rename(self, is_report=True):

        kill_evt_except()
        ob = self.get()
        if ob == None: return
        L, R, B, T = self.box_button.r_LRBT()
        R += R - L

        DropDownEnumRename(None, (L, R, B, T), ob, ob, is_report=is_report)
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_icon_arrow.dxy_upd(dx, dy)
        self.box_icon_object.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        self.box_icon_arrow.bind_draw()
        self.box_icon_object.bind_draw()
        #|

    # /* 0block_ButtonEnumObject_set
    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "r_object"):
            ob = self.r_object()
            if hasattr(ob, "is_editable") and not ob.is_editable:
                report(r_library_or_override_message(ob))
                return

        rna = self.rna
        oldvalue = self.get()

        if isinstance(v, str):
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in bpy.data.objects: v = bpy.data.objects[v]
                    else:
                        if refresh: report("Object not found")
                        return
                elif v.startswith(";"):
                    try: v = calc_py_exp(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in bpy.data.objects: v = bpy.data.objects[v]
                    else:
                        if refresh: report("Object not found")
                        return
            else:
                v = None

        if self.r_except_objects != None and v in self.r_except_objects():
            if refresh: report("Invalid Object")
            return
        if hasattr(v, "type"):
            if self.allow_types != None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Object Type")
                    return

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
    # */

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        ob = getattr(self.pp, self.rna.identifier)
        if self.blf_value.unclip_text == (ob.name  if ob else ""): return

        blf_value = self.blf_value

        if ob == None:
            v = ""
            if self.box_icon_arrow.__class__ != GpuImg_object_picker:
                self.box_icon_arrow.__class__ = GpuImg_object_picker
        else:
            v = ob.name
            if self.box_icon_arrow.__class__ != GpuImg_delete:
                self.box_icon_arrow.__class__ = GpuImg_delete

        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - SIZE_widget[0])
        #|
    #|
    #|
class ButtonEnumCollection(         # ButtonEnumObject                                          
    ButtonEnumObject):
    __slots__ = ()

    def __init__(self, w, rna, pp, allow_types=None, r_except_objects=None):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_icon_arrow = GpuImg_unfold()
        v = self.get()
        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.font_id = FONT0
        self.allow_types = allow_types
        self.r_except_objects = r_except_objects

        self.box_icon_object = GpuImg_ID_COLLECTION()
        #|

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        # <<< 1copy (0block_ButtonEnumCollection_modal_update_picker_focus,, ${'Admin.REDRAW()':''}$)
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.get() == None:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                        self.box_icon_arrow.__class__ = GpuImg_delete_focus
                        

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    
        else:
            region = 0
            if self.is_dark() is False:
                if self.get() == None:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    
        # >>>
        Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.is_dark() is True: return

        self.box_button.color = COL_box_text
        if self.get() == None:
            self.box_icon_arrow.__class__ = GpuImg_unfold
        else:
            self.box_icon_arrow.__class__ = GpuImg_delete
        Admin.REDRAW()
        #|

    def modal(self):
        # /* 0block_ButtonEnumCollection_modal_update_picker_focus
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.get() == None:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                        self.box_icon_arrow.__class__ = GpuImg_delete_focus
                        Admin.REDRAW()

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    Admin.REDRAW()
        else:
            region = 0
            if self.is_dark() is False:
                if self.get() == None:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        Admin.REDRAW()

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    Admin.REDRAW()
        # */

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['dd_preview']():
            if hasattr(self, "evt_area_preview"):
                self.evt_area_preview()
                return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.evt_click(region)
            return True
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        return DropDownEnumPointer(self, self.box_button.r_LRBT(), self.rna.name, bpy.data.collections)
        #|
    def to_modal_picker(self): return self.to_dropdown()

    def evt_click(self, region=0):
        if region == 0:
            self.to_dropdown()
        else:
            if self.get() == None:
                self.to_modal_picker()
            else:
                self.evt_delete_object()
        #|

    # <<< 1copy (0block_ButtonEnumObject_set,, ${'.objects':'.collections', 'Object':'Collection'}$)
    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "r_object"):
            ob = self.r_object()
            if hasattr(ob, "is_editable") and not ob.is_editable:
                report(r_library_or_override_message(ob))
                return

        rna = self.rna
        oldvalue = self.get()

        if isinstance(v, str):
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in bpy.data.collections: v = bpy.data.collections[v]
                    else:
                        if refresh: report("Collection not found")
                        return
                elif v.startswith(";"):
                    try: v = calc_py_exp(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in bpy.data.collections: v = bpy.data.collections[v]
                    else:
                        if refresh: report("Collection not found")
                        return
            else:
                v = None

        if self.r_except_objects != None and v in self.r_except_objects():
            if refresh: report("Invalid Collection")
            return
        if hasattr(v, "type"):
            if self.allow_types != None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Collection Type")
                    return

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
    # >>>

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        ob = getattr(self.pp, self.rna.identifier)
        if self.blf_value.unclip_text == (ob.name  if ob else ""): return

        blf_value = self.blf_value

        if ob == None:
            v = ""
            if self.box_icon_arrow.__class__ != GpuImg_unfold:
                self.box_icon_arrow.__class__ = GpuImg_unfold
        else:
            v = ob.name
            if self.box_icon_arrow.__class__ != GpuImg_delete:
                self.box_icon_arrow.__class__ = GpuImg_delete

        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - SIZE_widget[0])
        #|
    #|
    #|
class ButtonEnumParticle(           # ButtonEnumCollection                                      
    ButtonEnumCollection):
    __slots__ = 'r_particle_object'

    def __init__(self, w, rna, pp, r_particle_object, allow_types=None, r_except_objects=None):
        super().__init__(w, rna, pp, allow_types=allow_types, r_except_objects=r_except_objects)
        self.box_icon_object.__class__ = GpuImg_PARTICLE_SYSTEM
        self.r_particle_object = r_particle_object
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        target = self.r_particle_object()
        if not target: return
        if not hasattr(target, "particle_systems"): return

        return DropDownEnumPointer(self, self.box_button.r_LRBT(), self.rna.name, target.particle_systems)
        #|

    # <<< 1copy (0block_ButtonEnumObject_set,, ${
    #     'bpy.data.objects': 'self.r_particle_object().particle_systems',
    # }$)
    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "r_object"):
            ob = self.r_object()
            if hasattr(ob, "is_editable") and not ob.is_editable:
                report(r_library_or_override_message(ob))
                return

        rna = self.rna
        oldvalue = self.get()

        if isinstance(v, str):
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in self.r_particle_object().particle_systems: v = self.r_particle_object().particle_systems[v]
                    else:
                        if refresh: report("Object not found")
                        return
                elif v.startswith(";"):
                    try: v = calc_py_exp(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in self.r_particle_object().particle_systems: v = self.r_particle_object().particle_systems[v]
                    else:
                        if refresh: report("Object not found")
                        return
            else:
                v = None

        if self.r_except_objects != None and v in self.r_except_objects():
            if refresh: report("Invalid Object")
            return
        if hasattr(v, "type"):
            if self.allow_types != None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Object Type")
                    return

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
    # >>>
    #|
    #|
class ButtonEnumShapekey(           # ButtonEnumCollection                                      
    ButtonEnumCollection):
    __slots__ = 'r_shapekey'

    def __init__(self, w, rna, pp, r_shapekey, allow_types=None, r_except_objects=None):
        super().__init__(w, rna, pp, allow_types=allow_types, r_except_objects=r_except_objects)
        self.box_icon_object.__class__ = GpuImg_ID_KEY
        self.r_shapekey = r_shapekey
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        target = self.r_shapekey()
        if not target: return
        if not hasattr(target, "key_blocks"): return

        return DropDownEnumPointer(self, self.box_button.r_LRBT(), self.rna.name, target.key_blocks)
        #|

    # <<< 1copy (0block_ButtonEnumObject_set,, ${
    #     'bpy.data.objects': 'self.r_shapekey().key_blocks',
    # }$)
    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "r_object"):
            ob = self.r_object()
            if hasattr(ob, "is_editable") and not ob.is_editable:
                report(r_library_or_override_message(ob))
                return

        rna = self.rna
        oldvalue = self.get()

        if isinstance(v, str):
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in self.r_shapekey().key_blocks: v = self.r_shapekey().key_blocks[v]
                    else:
                        if refresh: report("Object not found")
                        return
                elif v.startswith(";"):
                    try: v = calc_py_exp(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in self.r_shapekey().key_blocks: v = self.r_shapekey().key_blocks[v]
                    else:
                        if refresh: report("Object not found")
                        return
            else:
                v = None

        if self.r_except_objects != None and v in self.r_except_objects():
            if refresh: report("Invalid Object")
            return
        if hasattr(v, "type"):
            if self.allow_types != None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Object Type")
                    return

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
    # >>>
    #|
    #|
class ButtonEnumTexture(            # ButtonEnumObject                                          
    StructPreview,
    ButtonEnumObject):
    __slots__ = 'box_icon_fakeuser', 'box_icon_duplicate', 'box_icon_rename', 'user_state', 'link_state', 'blf_users'

    def __init__(self, w, rna, pp, allow_types=None, r_except_objects=None):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_icon_arrow = GpuImg_ADD()
        v = self.get()
        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.font_id = FONT0
        self.allow_types = allow_types
        self.r_except_objects = r_except_objects

        self.box_icon_object = GpuImg_ID_TEXTURE()
        self.box_icon_fakeuser = GpuImg_FAKE_USER_OFF()
        self.box_icon_duplicate = GpuImg_DUPLICATE()
        self.box_icon_rename = GpuImg_rename()

        self.user_state = "NONE"
        self.link_state = "NONE"
        self.blf_users = BlfClipColor("", 0, 0, 0, COL_box_text_fg)
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        h = SIZE_widget[0]
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        L1 = R0 - h
        self.box_icon_arrow.LRBT_upd(L1, R0, B0, T0)
        L1 -= h
        R0 -= h
        self.box_icon_fakeuser.LRBT_upd(L1, R0, B0, T0)
        L1 -= h
        R0 -= h
        self.box_icon_duplicate.LRBT_upd(L1, R0, B0, T0)
        L1 -= h
        R0 -= h
        self.box_icon_rename.LRBT_upd(L1, R0, B0, T0)
        LL = L0
        L0 += h
        self.box_icon_object.LRBT_upd(LL, L0, B0, T0)

        blf_value.x = L0 + D_SIZE['font_main_dx']
        y = B0 + D_SIZE['font_main_dy']
        blf_value.y = y
        blf_value.unclip_text = ""
        blf_value.text = ""
        self.blf_users.y = y
        self.upd_data()
        return B
        #|

    def inside_evt(self):
        # <<< 1copy (0block_ButtonEnumTexture_modal_update_picker_focus,, ${'Admin.REDRAW()':''}$)
        x = MOUSE[0]
        if x >= self.box_icon_rename.L:
            if x >= self.box_icon_fakeuser.L:
                if x >= self.box_icon_arrow.L:
                    region = 1
                    if self.is_dark() is False:
                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                                self.box_icon_arrow.__class__ = GpuImg_delete_focus
                                
                        else:
                            if self.box_icon_arrow.__class__ != GpuImg_ADD_focus:
                                self.box_icon_arrow.__class__ = GpuImg_ADD_focus
                                

                        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                            
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
                            
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                            

                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_duplicate.__class__ != GpuImgNull:
                                self.box_icon_duplicate.__class__ = GpuImgNull
                                
                        else:
                            if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE:
                                self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
                                

                        if self.box_icon_rename.__class__ == GpuImg_rename_focus:
                            self.box_icon_rename.__class__ = GpuImg_rename
                            
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                            
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                            

                        if self.box_button.color != COL_box_text:
                            self.box_button.color = COL_box_text
                            

                        if self.blf_users.color != COL_box_text_fg:
                            self.blf_users.color = COL_box_text_fg
                            
                else:
                    region = 2
                    if self.is_dark() is False:
                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_arrow.__class__ != GpuImg_delete:
                                self.box_icon_arrow.__class__ = GpuImg_delete
                                
                        else:
                            if self.box_icon_arrow.__class__ != GpuImg_ADD:
                                self.box_icon_arrow.__class__ = GpuImg_ADD
                                

                        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON_focus
                            
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF_focus
                            
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB_focus
                            

                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_duplicate.__class__ != GpuImgNull:
                                self.box_icon_duplicate.__class__ = GpuImgNull
                                
                        else:
                            if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE:
                                self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
                                

                        if self.box_icon_rename.__class__ == GpuImg_rename_focus:
                            self.box_icon_rename.__class__ = GpuImg_rename
                            
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                            
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                            

                        if self.box_button.color != COL_box_text:
                            self.box_button.color = COL_box_text
                            

                        if self.blf_users.color != COL_box_text_fg:
                            self.blf_users.color = COL_box_text_fg
                            
            else:
                if x >= self.box_icon_duplicate.L:
                    region = 3
                    if self.is_dark() is False:
                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_arrow.__class__ != GpuImg_delete:
                                self.box_icon_arrow.__class__ = GpuImg_delete
                                
                        else:
                            if self.box_icon_arrow.__class__ != GpuImg_ADD:
                                self.box_icon_arrow.__class__ = GpuImg_ADD
                                

                        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                            
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
                            
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                            

                        if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE_focus:
                            self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE_focus
                            

                        if self.box_icon_rename.__class__ == GpuImg_rename_focus:
                            self.box_icon_rename.__class__ = GpuImg_rename
                            
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                            
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                            

                        if self.box_button.color != COL_box_text:
                            self.box_button.color = COL_box_text
                            

                        if self.blf_users.color != FLO_0000:
                            self.blf_users.color = FLO_0000
                            
                else:
                    region = 4
                    if self.is_dark() is False:
                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_arrow.__class__ != GpuImg_delete:
                                self.box_icon_arrow.__class__ = GpuImg_delete
                                
                        else:
                            if self.box_icon_arrow.__class__ != GpuImg_ADD:
                                self.box_icon_arrow.__class__ = GpuImg_ADD
                                

                        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                            
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
                            
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                            

                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_duplicate.__class__ != GpuImgNull:
                                self.box_icon_duplicate.__class__ = GpuImgNull
                                
                        else:
                            if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE:
                                self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
                                

                        if self.box_icon_rename.__class__ == GpuImg_rename:
                            self.box_icon_rename.__class__ = GpuImg_rename_focus
                            
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK_focus
                            
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE_focus
                            

                        if self.box_button.color != COL_box_text:
                            self.box_button.color = COL_box_text
                            

                        if self.blf_users.color != COL_box_text_fg:
                            self.blf_users.color = COL_box_text_fg
                            
        else:
            region = 0
            if self.is_dark() is False:
                if getattr(self.pp, self.rna.identifier):
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_ADD:
                        self.box_icon_arrow.__class__ = GpuImg_ADD
                        

                if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                    
                elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
                    
                elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                    

                if getattr(self.pp, self.rna.identifier):
                    if self.box_icon_duplicate.__class__ != GpuImgNull:
                        self.box_icon_duplicate.__class__ = GpuImgNull
                        
                else:
                    if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE:
                        self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
                        

                if self.box_icon_rename.__class__ == GpuImg_rename_focus:
                    self.box_icon_rename.__class__ = GpuImg_rename
                    
                elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                    
                elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                    

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    

                if self.blf_users.color != COL_box_text_fg:
                    self.blf_users.color = COL_box_text_fg
                    
        # >>>
        Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.is_dark() is True: return

        self.box_button.color = COL_box_text
        if getattr(self.pp, self.rna.identifier):
            if self.box_icon_arrow.__class__ != GpuImg_delete: self.box_icon_arrow.__class__ = GpuImg_delete
        else:
            if self.box_icon_arrow.__class__ != GpuImg_ADD: self.box_icon_arrow.__class__ = GpuImg_ADD

        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB

        if self.box_icon_rename.__class__ == GpuImg_rename_focus:
            self.box_icon_rename.__class__ = GpuImg_rename
        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE

        if getattr(self.pp, self.rna.identifier):
            self.box_icon_duplicate.__class__ = GpuImgNull
        else:
            self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE

        if self.box_icon_rename.__class__ == GpuImg_rename_focus:
            self.box_icon_rename.__class__ = GpuImg_rename

        if self.blf_users.color != COL_box_text_fg: self.blf_users.color = COL_box_text_fg
        Admin.REDRAW()
        #|

    def modal(self):
        # /* 0block_ButtonEnumTexture_modal_update_picker_focus
        x = MOUSE[0]
        if x >= self.box_icon_rename.L:
            if x >= self.box_icon_fakeuser.L:
                if x >= self.box_icon_arrow.L:
                    region = 1
                    if self.is_dark() is False:
                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                                self.box_icon_arrow.__class__ = GpuImg_delete_focus
                                Admin.REDRAW()
                        else:
                            if self.box_icon_arrow.__class__ != GpuImg_ADD_focus:
                                self.box_icon_arrow.__class__ = GpuImg_ADD_focus
                                Admin.REDRAW()

                        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                            Admin.REDRAW()
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
                            Admin.REDRAW()
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                            Admin.REDRAW()

                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_duplicate.__class__ != GpuImgNull:
                                self.box_icon_duplicate.__class__ = GpuImgNull
                                Admin.REDRAW()
                        else:
                            if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE:
                                self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
                                Admin.REDRAW()

                        if self.box_icon_rename.__class__ == GpuImg_rename_focus:
                            self.box_icon_rename.__class__ = GpuImg_rename
                            Admin.REDRAW()
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                            Admin.REDRAW()
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                            Admin.REDRAW()

                        if self.box_button.color != COL_box_text:
                            self.box_button.color = COL_box_text
                            Admin.REDRAW()

                        if self.blf_users.color != COL_box_text_fg:
                            self.blf_users.color = COL_box_text_fg
                            Admin.REDRAW()
                else:
                    region = 2
                    if self.is_dark() is False:
                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_arrow.__class__ != GpuImg_delete:
                                self.box_icon_arrow.__class__ = GpuImg_delete
                                Admin.REDRAW()
                        else:
                            if self.box_icon_arrow.__class__ != GpuImg_ADD:
                                self.box_icon_arrow.__class__ = GpuImg_ADD
                                Admin.REDRAW()

                        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON_focus
                            Admin.REDRAW()
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF_focus
                            Admin.REDRAW()
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB_focus
                            Admin.REDRAW()

                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_duplicate.__class__ != GpuImgNull:
                                self.box_icon_duplicate.__class__ = GpuImgNull
                                Admin.REDRAW()
                        else:
                            if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE:
                                self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
                                Admin.REDRAW()

                        if self.box_icon_rename.__class__ == GpuImg_rename_focus:
                            self.box_icon_rename.__class__ = GpuImg_rename
                            Admin.REDRAW()
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                            Admin.REDRAW()
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                            Admin.REDRAW()

                        if self.box_button.color != COL_box_text:
                            self.box_button.color = COL_box_text
                            Admin.REDRAW()

                        if self.blf_users.color != COL_box_text_fg:
                            self.blf_users.color = COL_box_text_fg
                            Admin.REDRAW()
            else:
                if x >= self.box_icon_duplicate.L:
                    region = 3
                    if self.is_dark() is False:
                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_arrow.__class__ != GpuImg_delete:
                                self.box_icon_arrow.__class__ = GpuImg_delete
                                Admin.REDRAW()
                        else:
                            if self.box_icon_arrow.__class__ != GpuImg_ADD:
                                self.box_icon_arrow.__class__ = GpuImg_ADD
                                Admin.REDRAW()

                        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                            Admin.REDRAW()
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
                            Admin.REDRAW()
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                            Admin.REDRAW()

                        if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE_focus:
                            self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE_focus
                            Admin.REDRAW()

                        if self.box_icon_rename.__class__ == GpuImg_rename_focus:
                            self.box_icon_rename.__class__ = GpuImg_rename
                            Admin.REDRAW()
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                            Admin.REDRAW()
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                            Admin.REDRAW()

                        if self.box_button.color != COL_box_text:
                            self.box_button.color = COL_box_text
                            Admin.REDRAW()

                        if self.blf_users.color != FLO_0000:
                            self.blf_users.color = FLO_0000
                            Admin.REDRAW()
                else:
                    region = 4
                    if self.is_dark() is False:
                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_arrow.__class__ != GpuImg_delete:
                                self.box_icon_arrow.__class__ = GpuImg_delete
                                Admin.REDRAW()
                        else:
                            if self.box_icon_arrow.__class__ != GpuImg_ADD:
                                self.box_icon_arrow.__class__ = GpuImg_ADD
                                Admin.REDRAW()

                        if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                            Admin.REDRAW()
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
                            Admin.REDRAW()
                        elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
                            self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                            Admin.REDRAW()

                        if getattr(self.pp, self.rna.identifier):
                            if self.box_icon_duplicate.__class__ != GpuImgNull:
                                self.box_icon_duplicate.__class__ = GpuImgNull
                                Admin.REDRAW()
                        else:
                            if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE:
                                self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
                                Admin.REDRAW()

                        if self.box_icon_rename.__class__ == GpuImg_rename:
                            self.box_icon_rename.__class__ = GpuImg_rename_focus
                            Admin.REDRAW()
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK_focus
                            Admin.REDRAW()
                        elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE:
                            self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE_focus
                            Admin.REDRAW()

                        if self.box_button.color != COL_box_text:
                            self.box_button.color = COL_box_text
                            Admin.REDRAW()

                        if self.blf_users.color != COL_box_text_fg:
                            self.blf_users.color = COL_box_text_fg
                            Admin.REDRAW()
        else:
            region = 0
            if self.is_dark() is False:
                if getattr(self.pp, self.rna.identifier):
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_ADD:
                        self.box_icon_arrow.__class__ = GpuImg_ADD
                        Admin.REDRAW()

                if self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_ON_focus:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                    Admin.REDRAW()
                elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_OFF_focus:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF
                    Admin.REDRAW()
                elif self.box_icon_fakeuser.__class__ == GpuImg_FAKE_USER_LIB_focus:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                    Admin.REDRAW()

                if getattr(self.pp, self.rna.identifier):
                    if self.box_icon_duplicate.__class__ != GpuImgNull:
                        self.box_icon_duplicate.__class__ = GpuImgNull
                        Admin.REDRAW()
                else:
                    if self.box_icon_duplicate.__class__ != GpuImg_DUPLICATE:
                        self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
                        Admin.REDRAW()

                if self.box_icon_rename.__class__ == GpuImg_rename_focus:
                    self.box_icon_rename.__class__ = GpuImg_rename
                    Admin.REDRAW()
                elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_LINK_focus:
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                    Admin.REDRAW()
                elif self.box_icon_rename.__class__ == GpuImg_FAKE_USER_OVERRIDE_focus:
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                    Admin.REDRAW()

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    Admin.REDRAW()

                if self.blf_users.color != COL_box_text_fg:
                    self.blf_users.color = COL_box_text_fg
                    Admin.REDRAW()
        # */

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['dd_preview']():
            if hasattr(self, "evt_area_preview"):
                self.evt_area_preview()
                return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.evt_click(region)
            return True
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        return DropDownEnumTexture(self, self.box_button.r_LRBT(), self.rna.name, bpy.data.textures)
        #|

    def evt_add_button(self):

        kill_evt_except()
        e = bpy.data.textures.new("", "IMAGE")
        self.set(e)
        #|

    def evt_click(self, region=0):
        if region == 0:
            self.to_dropdown()
        elif region == 1:
            if getattr(self.pp, self.rna.identifier):
                self.evt_delete_object()
            else:
                self.evt_add_button()
        elif region == 2:
            self.evt_fakeuser()
        elif region == 3:
            self.evt_duplicate()
        else:
            self.evt_rename()
        #|
    def evt_fakeuser(self):

        kill_evt_except()
        ob = self.get()
        if not ob: return
        s = r_library_or_override_message(ob)
        if s:
            report(s)
            return

        if hasattr(ob, "asset_data") and ob.asset_data:
            if not hasattr(ob, "asset_clear"): return
            ob.asset_clear()
            update_scene_push(f"{type(ob).__name__} Asset Clear")
        elif ob.use_fake_user:
            ob.use_fake_user = False
            update_scene_push(f"{type(ob).__name__} Fake User disable")
        else:
            ob.use_fake_user = True
            update_scene_push(f"{type(ob).__name__} Fake User enable")
        #|
    def evt_duplicate(self):

        kill_evt_except()
        ob = self.get()
        if not ob: return
        self.set(ob.copy(), undo_push=False)
        update_scene_push("Texture Duplicate")
        #|
    def evt_mark_asset(self, is_report=True): pass
    def evt_rename(self, is_report=True):
        kill_evt_except()
        ob = self.get()
        if not ob: return

        if hasattr(self, "link_state"):
            if self.link_state == "LINK":
                if hasattr(ob, "override_create"):
                    try:
                        ob.override_create(remap_local_usages=True)
                        update_scene_push("Override Create")
                    except: pass
                return
            if self.link_state == "OVERRIDE":
                try:
                    ob.make_local(clear_liboverride=True, clear_asset_data=True)
                    update_scene_push("Make Local")
                except: pass
                return

        super().evt_rename(is_report=is_report)
        #|

    # <<< 1copy (0block_ButtonEnumObject_set,, ${'.objects':'.textures', 'Object':'Texture'}$)
    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "r_object"):
            ob = self.r_object()
            if hasattr(ob, "is_editable") and not ob.is_editable:
                report(r_library_or_override_message(ob))
                return

        rna = self.rna
        oldvalue = self.get()

        if isinstance(v, str):
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in bpy.data.textures: v = bpy.data.textures[v]
                    else:
                        if refresh: report("Texture not found")
                        return
                elif v.startswith(";"):
                    try: v = calc_py_exp(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in bpy.data.textures: v = bpy.data.textures[v]
                    else:
                        if refresh: report("Texture not found")
                        return
            else:
                v = None

        if self.r_except_objects != None and v in self.r_except_objects():
            if refresh: report("Invalid Texture")
            return
        if hasattr(v, "type"):
            if self.allow_types != None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Texture Type")
                    return

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
    # >>>

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_icon_arrow.dxy_upd(dx, dy)
        self.box_icon_object.dxy_upd(dx, dy)
        self.box_icon_fakeuser.dxy_upd(dx, dy)
        self.box_icon_duplicate.dxy_upd(dx, dy)
        self.box_icon_rename.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_users.x += dx
        self.blf_users.y += dy
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        self.box_icon_arrow.bind_draw()
        self.box_icon_object.bind_draw()
        self.box_icon_fakeuser.bind_draw()
        self.box_icon_duplicate.bind_draw()
        self.box_icon_rename.bind_draw()
        #|
    def draw_blf(self):
        e = self.blf_value
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        e = self.blf_users
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        ob = getattr(self.pp, self.rna.identifier)

        if ob:
            if hasattr(ob, "asset_data") and ob.asset_data:
                user_state = "ASSET"
            else:
                user_state = "FAKEUSER"  if ob.use_fake_user else "NONE"

            if ob.library:
                link_state = "LINK"
            else:
                link_state = "OVERRIDE"  if hasattr(ob, "override_library") and ob.override_library else "NONE"

            if self.blf_value.unclip_text == ob.name and self.user_state == user_state and self.link_state == link_state and self.blf_users.unclip_text == ob.users: return


            blf_value = self.blf_value
            v = ob.name
            self.user_state = user_state
            self.link_state = link_state
            self.blf_users.unclip_text = ob.users
            self.blf_users.text = "9+"  if ob.users > 9 else str(ob.users)
            if self.box_icon_arrow.__class__ != GpuImg_delete:
                self.box_icon_arrow.__class__ = GpuImg_delete

            if user_state == "ASSET":
                if self.box_icon_fakeuser.__class__.__name__.endswith("s"):
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB_focus
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
            elif user_state == "FAKEUSER":
                if self.box_icon_fakeuser.__class__.__name__.endswith("s"):
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON_focus
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
            else:
                if self.box_icon_fakeuser.__class__.__name__.endswith("s"):
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF_focus
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF

            self.box_icon_duplicate.__class__ = GpuImgNull
            if link_state == "LINK":
                if self.box_icon_rename.__class__.__name__.endswith("s"):
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK_focus
                else:
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
            elif link_state == "OVERRIDE":
                if self.box_icon_rename.__class__.__name__.endswith("s"):
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE_focus
                else:
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
            else:
                if self.box_icon_rename.__class__.__name__.endswith("s"):
                    self.box_icon_rename.__class__ = GpuImg_rename_focus
                else:
                    self.box_icon_rename.__class__ = GpuImg_rename
        else:
            if self.blf_value.unclip_text == "" and self.user_state == "NONE" and self.link_state == "NONE" and self.blf_users.unclip_text == 0: return


            blf_value = self.blf_value
            v = ""
            self.user_state = "NONE"
            self.link_state = "NONE"
            self.blf_users.unclip_text = 0
            self.blf_users.text = ""
            if self.box_icon_arrow.__class__ != GpuImg_ADD:
                self.box_icon_arrow.__class__ = GpuImg_ADD

            if self.box_icon_fakeuser.__class__.__name__.endswith("s"):
                self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF_focus
            else:
                self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF

            self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE
            if self.box_icon_rename.__class__.__name__.endswith("s"):
                self.box_icon_rename.__class__ = GpuImg_rename_focus
            else:
                self.box_icon_rename.__class__ = GpuImg_rename

        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - SIZE_widget[0] * 4)

        self.blf_users.x = round(self.box_icon_duplicate.r_center_x_float() - blfDimen(FONT0, self.blf_users.text)[0] / 2)
        #|
    #|
    #|
class ButtonEnumCacheFile(          # ButtonEnumTexture                                         
    ButtonEnumTexture):
    __slots__ = ()

    def __init__(self, w, rna, pp, allow_types=None, r_except_objects=None):
        super().__init__(w, rna, pp, allow_types=allow_types, r_except_objects=r_except_objects)
        self.box_icon_object.__class__ = GpuImg_ID_CACHEFILE
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        return DropDownEnumPointer(self, self.box_button.r_LRBT(), self.rna.name, bpy.data.cache_files,
            get_info=get_info_users, fixed_width=True)
        #|

    def evt_add_button(self):
        def end_fn(s):
            try:
                caches = [e for e in bpy.data.cache_files]
                bpy.ops.cachefile.open(filepath=s)
                new_cac = next(e for e in bpy.data.cache_files  if e not in caches)

                new_cac.user_clear()
                self.set(new_cac, undo_push=False)
                update_scene_push("Import Cache File")
            except: pass

        OpScanFile.end_fn = end_fn
        bpy.ops.wm.vmd_scan_file("INVOKE_DEFAULT", filepath="")
        #|

    # <<< 1copy (0block_ButtonEnumObject_set,, ${'.objects':'.cache_files', 'Object':'Cache File'}$)
    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "r_object"):
            ob = self.r_object()
            if hasattr(ob, "is_editable") and not ob.is_editable:
                report(r_library_or_override_message(ob))
                return

        rna = self.rna
        oldvalue = self.get()

        if isinstance(v, str):
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in bpy.data.cache_files: v = bpy.data.cache_files[v]
                    else:
                        if refresh: report("Cache File not found")
                        return
                elif v.startswith(";"):
                    try: v = calc_py_exp(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in bpy.data.cache_files: v = bpy.data.cache_files[v]
                    else:
                        if refresh: report("Cache File not found")
                        return
            else:
                v = None

        if self.r_except_objects != None and v in self.r_except_objects():
            if refresh: report("Invalid Cache File")
            return
        if hasattr(v, "type"):
            if self.allow_types != None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Cache File Type")
                    return

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
    # >>>
    #|
    #|
class ButtonEnumNodeTree(           # ButtonEnumTexture                                         
    ButtonEnumTexture):
    __slots__ = ()

    def __init__(self, w, rna, pp, allow_types=None, r_except_objects=None):
        super().__init__(w, rna, pp, allow_types=allow_types, r_except_objects=r_except_objects)
        self.box_icon_object.__class__ = GpuImg_ID_NODETREE
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        allow_types = self.allow_types
        if allow_types is None:
            node_groups = bpy.data.node_groups
        else:
            node_groups = [e  for e in bpy.data.node_groups  if e.type in allow_types]

        return DropDownEnumPointer(self, self.box_button.r_LRBT(), self.rna.name, node_groups,
            get_info=get_info_users, fixed_width=True)
        #|

    def evt_add_button(self):
        kill_evt_except()
        self.set(add_empty_geometry_node_group())
        #|

    # <<< 1copy (0block_ButtonEnumObject_set,, ${'.objects':'.node_groups', 'Object':'Node Group'}$)
    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "r_object"):
            ob = self.r_object()
            if hasattr(ob, "is_editable") and not ob.is_editable:
                report(r_library_or_override_message(ob))
                return

        rna = self.rna
        oldvalue = self.get()

        if isinstance(v, str):
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in bpy.data.node_groups: v = bpy.data.node_groups[v]
                    else:
                        if refresh: report("Node Group not found")
                        return
                elif v.startswith(";"):
                    try: v = calc_py_exp(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in bpy.data.node_groups: v = bpy.data.node_groups[v]
                    else:
                        if refresh: report("Node Group not found")
                        return
            else:
                v = None

        if self.r_except_objects != None and v in self.r_except_objects():
            if refresh: report("Invalid Node Group")
            return
        if hasattr(v, "type"):
            if self.allow_types != None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Node Group Type")
                    return

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
    # >>>
    #|
    #|
class ButtonEnumIDParticle(         # ButtonEnumTexture                                         
    ButtonEnumTexture):
    __slots__ = ()

    def __init__(self, w, rna, pp, allow_types=None, r_except_objects=None):
        super().__init__(w, rna, pp, allow_types=allow_types, r_except_objects=r_except_objects)
        self.box_icon_object.__class__ = GpuImg_ID_PARTICLE
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        particles = list(bpy.data.particles)

        return DropDownEnumPointer(self, self.box_button.r_LRBT(), self.rna.name, particles,
            get_info=get_info_users, fixed_width=True)
        #|

    def evt_add_button(self):
        kill_evt_except()
        self.set(bpy.data.particles.new(""))
        #|

    # <<< 1copy (0block_ButtonEnumObject_set,, ${'.objects':'.particles', 'Object':'Particle'}$)
    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "r_object"):
            ob = self.r_object()
            if hasattr(ob, "is_editable") and not ob.is_editable:
                report(r_library_or_override_message(ob))
                return

        rna = self.rna
        oldvalue = self.get()

        if isinstance(v, str):
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in bpy.data.particles: v = bpy.data.particles[v]
                    else:
                        if refresh: report("Particle not found")
                        return
                elif v.startswith(";"):
                    try: v = calc_py_exp(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in bpy.data.particles: v = bpy.data.particles[v]
                    else:
                        if refresh: report("Particle not found")
                        return
            else:
                v = None

        if self.r_except_objects != None and v in self.r_except_objects():
            if refresh: report("Invalid Particle")
            return
        if hasattr(v, "type"):
            if self.allow_types != None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Particle Type")
                    return

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
    # >>>
    #|
    #|
class ButtonEnumVertexGroup(        # ButtonEnum                                                
    ButtonEnum):
    __slots__ = 'box_icon_object', 'r_enum_items'

    def __init__(self, w, rna, pp):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_icon_arrow = GpuImg_unfold()
        v = getattr(self.pp, rna.identifier)
        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.font_id = FONT0

        self.box_icon_object = GpuImg_GROUP_VERTEX()
        #|

    def init_bat(self, L, R, T):
        blf_value = self.blf_value
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        self.box_icon_arrow.LRBT_upd(R0 - SIZE_widget[0], R0, B0, T0)
        LL = L0
        L0 += SIZE_widget[0]
        self.box_icon_object.LRBT_upd(LL, L0, B0, T0)

        blf_value.x = L0 + D_SIZE['font_main_dx']
        blf_value.y = B0 + D_SIZE['font_main_dy']
        blf_value.unclip_text = ""
        blf_value.text = ""
        self.upd_data()
        return B
        #|

    def r_default_value(self): return ""

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        # <<< 1copy (0block_ButtonEnumObject_modal_update_picker_focus,, ${
        #     'Admin.REDRAW()': '',
        #     'GpuImg_object_picker_focus': 'GpuImg_unfold',
        #     'GpuImg_object_picker': 'GpuImg_unfold'
        # }$)
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                        self.box_icon_arrow.__class__ = GpuImg_delete_focus
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    
        else:
            region = 0
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    
        # >>>
        Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.is_dark() is True: return

        self.box_button.color = COL_box_text
        if getattr(self.pp, self.rna.identifier):
            self.box_icon_arrow.__class__ = GpuImg_delete
        else:
            self.box_icon_arrow.__class__ = GpuImg_unfold
        Admin.REDRAW()
        #|

    def modal(self):
        # <<< 1copy (0block_ButtonEnumObject_modal_update_picker_focus,, ${
        #     'GpuImg_object_picker_focus': 'GpuImg_unfold',
        #     'GpuImg_object_picker': 'GpuImg_unfold'
        # }$)
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete_focus:
                        self.box_icon_arrow.__class__ = GpuImg_delete_focus
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        Admin.REDRAW()

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    Admin.REDRAW()
        else:
            region = 0
            if self.is_dark() is False:
                if self.get():
                    if self.box_icon_arrow.__class__ != GpuImg_delete:
                        self.box_icon_arrow.__class__ = GpuImg_delete
                        Admin.REDRAW()
                else:
                    if self.box_icon_arrow.__class__ != GpuImg_unfold:
                        self.box_icon_arrow.__class__ = GpuImg_unfold
                        Admin.REDRAW()

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    Admin.REDRAW()
        # >>>

        # <<< 1copy (0block_ButtonString_modal,, ${'self.to_dropdown()#ref':'self.evt_click(region)'}$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.evt_click(region)
            return True
        # >>>
        return False
        #|

    def to_modal_rm(self):


        DropDownRMKeymap(self, MOUSE, [
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ], title=self.rna.name)
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        ob = self.r_object()
        if not hasattr(ob, "vertex_groups"): return

        if hasattr(self, "r_enum_items"):
            return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=self.r_enum_items())
        return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=ob.vertex_groups)
        #|

    def evt_click(self, region=0):
        if region == 0:
            self.to_dropdown()
        else:
            if getattr(self.pp, self.rna.identifier):
                self.evt_delete_object()
            else:
                self.to_dropdown()
        #|
    def evt_delete_object(self):

        kill_evt_except()
        try:
            self.set("")
            Admin.REDRAW()
        except Exception as ex:
            DropDownOk(None, MOUSE, input_text=f'Unexpected error, please report to the author: 04\n{ex}')
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_icon_arrow.dxy_upd(dx, dy)
        self.box_icon_object.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        self.box_icon_arrow.bind_draw()
        self.box_icon_object.bind_draw()
        #|

    def set(self, v, refresh=True, undo_push=True):
        rna = self.rna
        oldvalue = getattr(self.pp, self.rna.identifier)

        setattr(self.pp, rna.identifier, v)
        if refresh: update_data()

        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        v = getattr(self.pp, self.rna.identifier)
        if self.blf_value.unclip_text == v:
            if hasattr(self, "r_enum_items"):
                if v in self.r_enum_items():
                    if self.is_dark() is True:
                        if self.blf_value.color != COL_box_text_fg_ignore:
                            self.blf_value.color = COL_box_text_fg_ignore
                    else:
                        if self.blf_value.color != COL_box_text_fg:
                            self.blf_value.color = COL_box_text_fg
                else:
                    if self.is_dark() is True:
                        if self.blf_value.color != COL_box_text_fg_ignore:
                            self.blf_value.color = COL_box_text_fg_ignore
                    else:
                        if self.blf_value.color != COL_box_val_fg_error:
                            self.blf_value.color = COL_box_val_fg_error
            return



        blf_value = self.blf_value
        if v:
            if self.box_icon_arrow.__class__ != GpuImg_delete:
                self.box_icon_arrow.__class__ = GpuImg_delete
        else:
            if self.box_icon_arrow.__class__ != GpuImg_unfold:
                self.box_icon_arrow.__class__ = GpuImg_unfold

        blf_value.unclip_text = v
        if hasattr(self, "r_enum_items"):
            if v in self.r_enum_items():
                if self.is_dark() is True:
                    blf_value.color = COL_box_text_fg_ignore
                else:
                    blf_value.color = COL_box_text_fg
            else:
                if self.is_dark() is True:
                    blf_value.color = COL_box_text_fg_ignore
                else:
                    blf_value.color = COL_box_val_fg_error

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_icon_arrow.L - D_SIZE['font_main_dx'])
        #|
    #|
    #|
class ButtonEnumUV(                 # ButtonEnumVertexGroup                                     
    ButtonEnumVertexGroup):
    __slots__ = ()

    def __init__(self, w, rna, pp):
        super().__init__(w, rna, pp)
        self.box_icon_object.__class__ = GpuImg_GROUP_UVS
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        ob = self.r_object()
        if not ob: return
        if hasattr(self, "r_enum_items"):
            return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=self.r_enum_items())
        if hasattr(ob, "data"):
            if hasattr(ob.data, "uv_layers"):
                return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=ob.data.uv_layers)
        #|
    #|
    #|
class ButtonEnumGpLayer(            # ButtonEnumVertexGroup                                     
    ButtonEnumVertexGroup):
    __slots__ = ()

    def __init__(self, w, rna, pp):
        self.r_enum_items = self.r_layers
        super().__init__(w, rna, pp)
        self.box_icon_object.__class__ = GpuImg_GREASEPENCIL
        #|

    def r_layers(self):
        ob = self.r_object()
        if ob:
            if hasattr(ob, "data"):
                if hasattr(ob.data, "layers"):
                    return ob.data.layers
        return Dictlist(None)
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        ob = self.r_object()
        if not ob: return
        if hasattr(self, "r_enum_items"):
            return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=self.r_enum_items())
        elif hasattr(ob, "data"):
            if hasattr(ob.data, "layers"):
                return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=ob.data.layers)
        #|
    #|
    #|
class ButtonEnumVertexColor(        # ButtonEnumVertexGroup                                     
    ButtonEnumVertexGroup):
    __slots__ = ()

    def __init__(self, w, rna, pp):
        super().__init__(w, rna, pp)
        self.box_icon_object.__class__ = GpuImg_GROUP_VCOL
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        ob = self.r_object()
        if not ob: return
        if hasattr(self, "r_enum_items"):
            return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=self.r_enum_items())
        if hasattr(ob, "data"):
            if hasattr(ob.data, "vertex_colors"):
                return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=ob.data.vertex_colors)
        #|
    #|
    #|
class ButtonEnumBone(               # ButtonEnumVertexGroup                                     
    ButtonEnumVertexGroup):
    __slots__ = 'r_armature'

    def __init__(self, w, rna, pp, r_armature):
        super().__init__(w, rna, pp)
        self.box_icon_object.__class__ = GpuImg_BONE_DATA
        self.r_armature = r_armature
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        ob = self.r_armature()
        if not ob: return
        if hasattr(ob, "data"):
            if hasattr(ob.data, "bones"):
                return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=ob.data.bones)
        #|
    #|
    #|
class ButtonEnumFalloff(            # ButtonEnumVertexGroup                                     
    ButtonEnumVertexGroup):
    __slots__ = ()

    D_get_icon = {}

    def __init__(self, w, rna, pp):
        super().__init__(w, rna, pp)
        self.box_icon_object.__class__ = GpuImgNull
        #|

    def inside_evt(self):
        if self.blf_value.color == COL_box_text_fg_ignore: pass
        else:
            self.box_button.color = COL_box_text_active
            Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.blf_value.color == COL_box_text_fg_ignore: pass
        else:
            self.box_button.color = COL_box_text
            Admin.REDRAW()
        #|

    def modal(self):
        # <<< 1copy (0block_ButtonString_modal,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.to_dropdown()#ref
            return True
        # >>>
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        v = self.get()
        if v == None: v = "None"
        elif hasattr(self.rna, "enum_items"):
            if v in self.rna.enum_items: v = self.rna.enum_items[v].name

        return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, get_icon=self.get_icon)
        #|
    def get_icon(self, e):
        if e.name in ButtonEnumFalloff.D_get_icon: return ButtonEnumFalloff.D_get_icon[e.name]()
        return GpuImgNull()
        #|

    # <<< 1copy (0block_StructButtonEnum_evt_set,, $$)
    @ catch
    def to_modal_rm(self):


        DropDownRMKeymap(self, MOUSE, [
            ("dd_cut", self.evt_area_cut),
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ], override_name={"dd_cut":"Copy Identifier"}, title=self.rna.name)
        #|

    @ catch
    def evt_area_cut(self, is_report=True):

        kill_evt_except()
        ob = self.get()
        if hasattr(ob, "name"):
            ob = r_ID_dp(ob)

        bpy.context.window_manager.clipboard = f'{ob}'
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_copy(self, is_report=True):

        kill_evt_except()

        if hasattr(self.rna, "enum_items"):
            v = self.get()
            if v == None: s = "None"
            elif isinstance(v, set):
                ls = [e.name  for e in self.rna.enum_items  if e.identifier in v]
                s = str(ls).replace("[", "{").replace("]", "}")
            else:
                s = self.rna.enum_items[v].name  if v in self.rna.enum_items else v
        else:
            s = self.get()

        bpy.context.window_manager.clipboard = f'{s}'
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, is_report=True):

        kill_evt_except()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        try:
            self.set(s)
            Admin.REDRAW()
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_reset_single(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_reset_all(self):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value())
        #|
    @ catch
    def evt_area_detail(self):

        kill_evt_except()
        Detail(Detail.r_rna_info(self.rna))
        #|

    def get(self):
        return getattr(self.pp, self.rna.identifier)
        #|
    def set(self, v, refresh=True, undo_push=True): # allow input name, Nonetype
        rna = self.rna
        oldvalue = getattr(self.pp, rna.identifier)
        if v in rna.enum_items:
            setattr(self.pp, rna.identifier, v)
            if refresh: update_data()
            if hasattr(self, "set_callback"): self.set_callback()
            self.evt_undo_push(undo_push, oldvalue)
        else:
            if v == None:
                if hasattr(rna, "is_never_none") and rna.is_never_none: return
            else:
                for e in rna.enum_items:
                    if e.name == v:
                        setattr(self.pp, rna.identifier, e.identifier)
                        if refresh: update_data()
                        if hasattr(self, "set_callback"): self.set_callback()
                        self.evt_undo_push(undo_push, oldvalue)
                        return
    # >>>

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        blf_value = self.blf_value
        if blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return

        v = getattr(self.pp, self.rna.identifier)
        blf_value.unclip_text = v
        if v in ButtonEnumFalloff.D_get_icon:
            self.box_icon_object.__class__ = ButtonEnumFalloff.D_get_icon[v]
            blf_value.x = self.box_button.inner[0] + D_SIZE['font_main_dx'] + SIZE_widget[0]
        else:
            self.box_icon_object.__class__ = GpuImgNull
            blf_value.x = self.box_button.inner[0] + D_SIZE['font_main_dx']

        if v == None: v = "None"
        elif hasattr(self.rna, "enum_items"):
            if v in self.rna.enum_items: v = self.rna.enum_items[v].name

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - SIZE_widget[0])
        #|
    #|
    #|
class ButtonEnumIDType(             # ButtonEnumFalloff
    ButtonEnumFalloff):
    __slots__ = ()

    D_get_icon = {}

    def to_dropdown(self, killevt=True, select_all=None):


        return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name,
            items=self.rna.enum_items, get_icon=self.get_icon)

    def get_icon(self, e):
        s = f"GpuImg_ID_{e.identifier}"
        if hasattr(blg, s): return getattr(blg, s)()
        return GpuImgNull()
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        blf_value = self.blf_value
        if blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return

        v = getattr(self.pp, self.rna.identifier)
        blf_value.unclip_text = v
        s = f"GpuImg_ID_{v}"
        if hasattr(blg, s):
            self.box_icon_object.__class__ = getattr(blg, s)
            blf_value.x = self.box_button.inner[0] + D_SIZE['font_main_dx'] + SIZE_widget[0]
        else:
            self.box_icon_object.__class__ = GpuImgNull
            blf_value.x = self.box_button.inner[0] + D_SIZE['font_main_dx']

        if v == None: v = "None"
        else:
            if v in self.rna.enum_items: v = self.rna.enum_items[v].name

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - SIZE_widget[0])
        #|
    #|
    #|
class ButtonEnumDriverPath(         # ButtonEnumVertexGroup                                     
    ButtonEnumVertexGroup):
    __slots__ = 'r_ID'

    def __init__(self, w, rna, pp, r_ID):
        super().__init__(w, rna, pp)
        self.box_icon_object.__class__ = GpuImg_rna
        self.r_ID = r_ID
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        ob = self.r_ID()
        if not ob: return

        if hasattr(ob, "animation_data") and hasattr(ob.animation_data, "drivers"):
            drivers = ob.animation_data.drivers
            if drivers:
                items = [NameValue(f'{fc.data_path}[{fc.array_index}]' if is_array_fcurve(ob, fc
                    ) else fc.data_path, fc)  for fc in drivers]

                def get_info(e):
                    name = r_fcurve_name(ob, e.value)
                    return ""  if name is None else name

                return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name,
                    items = items,
                    fixed_width = True,
                    get_info = get_info)

        return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, items=None)
        #|

    def check(self, ob):
        if hasattr(ob, "animation_data") and hasattr(ob.animation_data, "drivers"):
            drivers = ob.animation_data.drivers
            if drivers:
                datapath = self.get()
                if datapath:
                    if datapath.endswith("]") and datapath[-2 : -1] in "0123456789":
                        i0 = datapath.rfind("[")
                        try:
                            index = int(datapath[i0 + 1 : -1])
                        except: pass
                        fc = drivers.find(datapath[ : i0], index=index)
                        if fc is not None: return fc
                    else:
                        fc = drivers.find(datapath)
                        if fc is not None: return fc
                else: return None

        setattr(self.pp, self.rna.identifier, "")
        return None
        #|
    #|
    #|
class ButtonEnumID(                 # ButtonEnumObject
    ButtonEnumObject):
    __slots__ = 'idtype'

    def __init__(self, w, rna, pp, idtype="OBJECT"):
        self.idtype = idtype
        super().__init__(w, rna, pp)
        #|

    def inside_evt(self):
        # <<< 1copy (0block_ButtonEnumID_update_picker_focus,, ${'Admin.REDRAW()':''}$)
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                clsname = self.box_icon_arrow.__class__.__name__
                if clsname == "GpuImgNull": pass
                elif clsname[-6 : ] != "_focus":
                    self.box_icon_arrow.__class__ = globals()[clsname + "_focus"]
                    

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    
        else:
            region = 0
            if self.is_dark() is False:
                clsname = self.box_icon_arrow.__class__.__name__
                if clsname == "GpuImgNull": pass
                elif clsname.endswith("_focus"):
                    self.box_icon_arrow.__class__ = globals()[clsname[ : -6]]
                    

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    
        # >>>
        Admin.REDRAW()
        #|
    def outside_evt(self):
        if self.is_dark() is True: return

        self.box_button.color = COL_box_text
        clsname = self.box_icon_arrow.__class__.__name__
        if clsname == "GpuImgNull": pass
        elif clsname.endswith("_focus"):
            self.box_icon_arrow.__class__ = globals()[clsname[ : -6]]
        Admin.REDRAW()
        #|

    def modal(self):
        # /* 0block_ButtonEnumID_update_picker_focus
        if MOUSE[0] >= self.box_icon_arrow.L:
            region = 1
            if self.is_dark() is False:
                clsname = self.box_icon_arrow.__class__.__name__
                if clsname == "GpuImgNull": pass
                elif clsname[-6 : ] != "_focus":
                    self.box_icon_arrow.__class__ = globals()[clsname + "_focus"]
                    Admin.REDRAW()

                if self.box_button.color != COL_box_text:
                    self.box_button.color = COL_box_text
                    Admin.REDRAW()
        else:
            region = 0
            if self.is_dark() is False:
                clsname = self.box_icon_arrow.__class__.__name__
                if clsname == "GpuImgNull": pass
                elif clsname.endswith("_focus"):
                    self.box_icon_arrow.__class__ = globals()[clsname[ : -6]]
                    Admin.REDRAW()

                if self.box_button.color != COL_box_text_active:
                    self.box_button.color = COL_box_text_active
                    Admin.REDRAW()
        # */

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste()
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy()
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single()
            return True
        if isinstance(self.blf_value, list) and TRIGGER['pan']():
            self.to_area_pan_text()
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['dd_preview']():
            if hasattr(self, "evt_area_preview"):
                self.evt_area_preview()
                return True
        if hasattr(self, "submodal"):
            if self.submodal(): return True

        if TRIGGER['click']():
            self.evt_click(region)
            return True
        return False
        #|

    def submodal(self):
        if TRIGGER['ui_jump_to_target']():
            if self.get().__class__.__name__ == "Object":
                self.evt_jump_to_target()
            return True
        if TRIGGER['ui_mark_asset']():
            if hasattr(self.get(), "asset_data"):
                self.evt_mark_asset()
            return True
        return False
        #|

    def to_modal_rm(self):

        ob = self.get()
        items = [
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("dd_cut", self.evt_area_cut),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ]
        if ob.__class__.__name__ == "Object":
            items.append(("ui_jump_to_target", self.evt_jump_to_target))
        if hasattr(ob, "asset_data"):
            items.append(("ui_mark_asset", self.evt_mark_asset))
        items.append(("Rename Object", self.evt_rename))

        override_name = {
            "dd_cut": "Copy Object Path",
            "ui_mark_asset": "Clear Asset"  if hasattr(ob, "asset_data") and ob.asset_data else "Mark as Asset"
        }

        if hasattr(self, "r_rm_items"):
            rm_items, rm_override_name = self.r_rm_items(ob)
            items += rm_items
            override_name.update(rm_override_name)

        append_rm_item_preview(self, items, self.rna)

        DropDownRMKeymap(self, MOUSE, items, override_name=override_name, title=self.rna.name)
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        if hasattr(self, "poll") and self.poll(self) == False: return

        idtype = self.idtype
        bpy_data_type = getattr(bpy.data, D_id_blendData[idtype], None)
        if bpy_data_type is None: return

        LRBT = self.box_button.r_LRBT()

        get_icon = None


        if idtype == "OBJECT": get_icon = geticon_Object
        if idtype == "IMAGE":
            return DropDownEnumImage(self, LRBT, self.rna.name, bpy_data_type)
        elif idtype == "TEXTURE":
            return DropDownEnumTexture(self, LRBT, self.rna.name, bpy_data_type)
        elif idtype == "MATERIAL":
            return DropDownEnumMaterial(self, LRBT, self.rna.name, bpy_data_type)

        return DropDownEnumPointer(self, LRBT, self.rna.name,
            bpy_data_type,
            self.allow_types,
            self.r_except_objects,
            get_icon = get_icon)
        #|

    def update_icon(self):
        idtype = self.idtype
        good_idtype = idtype in D_id_blendData and hasattr(bpy.data, D_id_blendData[idtype])
        if good_idtype is True:
            if self.is_dark() is True:
                self.light()
        else:
            if self.is_dark() is False:
                self.dark()

        ob = getattr(self.pp, self.rna.identifier)

        if ob:
            clsname = ob.__class__.__name__
            if clsname in D_cls_id:
                idtype = D_cls_id[clsname]

        if idtype == "OBJECT":
            if ob == None:
                name = ""
                self.box_icon_arrow.__class__ = GpuImg_object_picker
                self.box_icon_object.__class__ = GpuImgNull
            else:
                name = ob.name
                self.box_icon_arrow.__class__ = GpuImg_delete
                if hasattr(ob, "type"):
                    self.box_icon_object.__class__ = getattr(blg, f"GpuImg_OUTLINER_OB_{ob.type}", GpuImgNull)
                else:
                    self.box_icon_object.__class__ = GpuImg_ID_OBJECT
        else:
            self.box_icon_object.__class__ = getattr(blg, f"GpuImg_ID_{idtype}", GpuImgNull)
            if ob == None:
                name = ""
                self.box_icon_arrow.__class__ = GpuImg_unfold
            else:
                name = ob.name
                self.box_icon_arrow.__class__ = GpuImg_delete

        return name
        #|
    def check(self, idtype):
        if self.idtype == idtype:
            ob = getattr(self.pp, self.rna.identifier)
            if ob:
                try: ob.name
                except:
                    old_name = self.blf_value.unclip_text
                    if idtype in D_id_blendData:
                        bpy_data = getattr(bpy.data, D_id_blendData[idtype], None)
                        if bpy_data and old_name in bpy_data:
                            setattr(self.pp, self.rna.identifier, bpy_data[old_name])
                            self.update_icon()
                            return

                    setattr(self.pp, self.rna.identifier, None)
                    self.box_icon_arrow.__class__ = GpuImg_unfold
        else:
            self.idtype = idtype
            if getattr(self.pp, self.rna.identifier) == None: pass
            else:
                setattr(self.pp, self.rna.identifier, None)

            if self.box_icon_arrow.__class__ != GpuImg_unfold:
                self.box_icon_arrow.__class__ = GpuImg_unfold

        self.update_icon()
        #|

    def evt_click(self, region=0):
        if region == 0:
            self.to_dropdown()
        else:
            if self.get():
                self.evt_delete_object()
            else:
                if self.idtype == "OBJECT":
                    self.to_modal_picker()
                else:
                    self.to_dropdown()
        #|
    def evt_area_preview(self):

        kill_evt_except()
        mat = self.get()
        if mat:
            preview_datablock(mat)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        ob = getattr(self.pp, self.rna.identifier)
        if self.blf_value.unclip_text == (ob.name  if ob else ""): return


        blf_value = self.blf_value
        v = self.update_icon()

        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - SIZE_widget[0])
        #|
    #|
    #|
class ButtonBoolArrayX:
    __slots__ = (
        'w',
        'rna',
        'pp',
        'r_pp',
        'r_object',
        'r_datapath_head',
        'box_button',
        'blf_value',
        'is_trigger_enable',
        'focus_index',
        'set_callback',
        'poll')

    def __init__(self, w, rna, pp, title=None):
        self.w = w
        self.rna = rna
        if type(pp) is tuple:
            self.r_pp, self.r_object, self.r_datapath_head = pp
            self.pp = self.r_pp()
        else:
            self.pp = pp
        self.box_button = [GpuButtonBool()  for e in rna]
        if title is None:
            self.blf_value = [BlfColor(e.name, color=COL_box_button_fg)  for e in rna]
        else:
            self.blf_value = [BlfColor(e, color=COL_box_button_fg)  for e in title]
        #|

    def init_bat(self, L, R, T):
        # /* 0block_ButtonBoolArrayX_init_bat
        blfSize(FONT0, D_SIZE['font_main'])
        box_button = self.box_button
        blf_value = self.blf_value
        widget_rim = SIZE_border[3]
        full_h = D_SIZE['widget_full_h']
        width = (R - L) // len(box_button)

        B = T - full_h
        y = B + widget_rim + D_SIZE['font_main_dy']

        for r in range(len(box_button) - 1):
            R0 = L + width
            box_button[r].LRBT_upd(L, R0, B, T, widget_rim)
            e = blf_value[r]
            e.y = y
            e.x = floor((R0 + L - blfDimen(FONT0, e.text)[0]) / 2)
            L = R0

        box_button[-1].LRBT_upd(L, R, B, T, widget_rim)
        e = blf_value[-1]
        e.y = y
        e.x = floor((R + L - blfDimen(FONT0, e.text)[0]) / 2)

        self.upd_data()
        return B
        # */
    def r_height(self, width): return D_SIZE['widget_full_h']
    def r_default_value(self, index): return self.rna[index].default

    def is_dark(self): return self.box_button[0].is_dark()
    def dark(self):
        for e in self.box_button: e.dark()
        for e in self.blf_value: e.color = COL_box_button_fg_ignore
        #|
    def light(self):
        for e in self.box_button: e.light()
        for e in self.blf_value: e.color = COL_box_button_fg
        #|
    def dark_index(self, r):
        self.box_button[r].dark()
        self.blf_value[r].color = COL_box_button_fg_ignore
        #|
    def light_index(self, r):
        self.box_button[r].light()
        self.blf_value[r].color = COL_box_button_fg
        #|

    def r_focus_index(self, mouse):
        for r, e in enumerate(self.box_button):
            if e.inbox(mouse): return r
        return None
        #|

    def focus_button(self, i):
        if self.box_button[i].state == 0:
            self.box_button[i].set_state_off_focus()
        #|
    def unfocus_button(self, i):
        if self.box_button[i].state == 1:
            self.box_button[i].set_state_off()
        #|
    def turnon_button(self, i):
        if self.box_button[i].state in {0, 1}:
            self.box_button[i].set_state_on()
        #|
    def turnoff_button(self, i):
        if self.box_button[i].state == 2:
            self.box_button[i].set_state_off()
        #|

    def inside(self, mouse):
        box_button = self.box_button
        if mouse[0] < box_button[0].L: return False
        if mouse[0] > box_button[-1].R: return False
        if mouse[1] > box_button[0].T: return False
        if mouse[1] < box_button[-1].B: return False
        return True
        #|
    def inside_evt(self):
        self.focus_index = self.r_focus_index(MOUSE)
        if self.focus_index != None:
            self.focus_button(self.focus_index)
            Admin.REDRAW()
        self.is_trigger_enable = True
        #|
    def outside_evt(self):
        if hasattr(self, "focus_index"):
            if self.focus_index != None:
                self.unfocus_button(self.focus_index)
                Admin.REDRAW()
        #|

    def modal(self):
        i = self.r_focus_index(MOUSE)
        if i != self.focus_index:

            if self.focus_index != None:
                self.unfocus_button(self.focus_index)
                Admin.REDRAW()

            self.focus_index = i
            self.is_trigger_enable = True

            if i != None:
                self.focus_button(i)
                Admin.REDRAW()

        if i == None: return False

        allow_trigger = self.is_trigger_enable
        if not allow_trigger:
            if EVT_TYPE[0] == "TIMER_REPORT": pass
            else:
                if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                    self.is_trigger_enable = True

        if TRIGGER['rm']():
            self.to_modal_rm(i)
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut(i)
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(i)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(i)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(i)
            return True
        if TRIGGER['detail']():
            self.evt_area_detail(i)
            return True

        if hasattr(self, "submodal"):
            if self.submodal(i): return True

        if allow_trigger:
            if TRIGGER['click']():
                self.is_trigger_enable = False
                if is_first_press('click') == False:
                    self.set(_last_bool_state[0], i)
                else:
                    boo = not self.get(i)
                    self.set(boo, i)
                    _last_bool_state[0] = boo
                Admin.REDRAW()
                return True
        return False

    def to_modal_rm(self, i=0):


        DropDownRMKeymap(self, MOUSE, [
            ("dd_cut", self.evt_area_cut),
            ("dd_paste", lambda: self.evt_area_paste(i)),
            ("dd_copy", lambda: self.evt_area_copy(i)),
            ("valbox_reset_all", self.evt_area_reset_all),
            ("valbox_reset_single", lambda: self.evt_area_reset_single(i)),
            ("detail", lambda: self.evt_area_detail(i)),
        ], override_name={"valbox_reset_all":"Value Box Reset All"}, title=self.rna[i].name)
        #|

    @ catch
    def evt_area_cut(self, index=0, is_report=True):

        kill_evt_except()
        s = ""
        for r in range(len(self.rna)): s += f'{value_to_display(self.get(r))}, '

        bpy.context.window_manager.clipboard = s[: -2]
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_copy(self, index=0, is_report=True):

        kill_evt_except()
        bpy.context.window_manager.clipboard = f'{self.get(index)}'
        if is_report: report("Copy to Clipboard")
        #|
    @ catch
    def evt_area_paste(self, index=0, is_report=True):

        kill_evt_except()
        Admin.REDRAW()
        s = bpy.context.window_manager.clipboard
        if not s:
            if is_report: report("Clipboard is Empty")
            return

        s = s.strip()
        if s in {'True', 'true', '1', '1.0'}:
            self.set(True, index)
            return
        elif s in {'False', 'false', '0', '0.0'}:
            self.set(False, index)
            return

        try:
            Admin.REDRAW()
            if s.strip().startswith("#"):
                self.set(s, index)
                return

            array = calc_vec(s)
            if len(array) == 1:
                self.set(bool(int(array[0])), index)
            else:
                self.set([bool(int(e))  for e in array], (0, min(len(self.rna), len(array))))
        except:
            if is_report: report("Invalid Input")
            return
        #|
    @ catch
    def evt_area_reset_single(self, index=0):

        kill_evt_except()
        Admin.REDRAW()
        self.set(self.r_default_value(index), index)
        #|
    @ catch
    def evt_area_reset_all(self, index=0):

        kill_evt_except()
        Admin.REDRAW()
        for r in range(len(self.rna)):
            self.set(self.r_default_value(r), r)
        #|
    @ catch
    def evt_area_detail(self, index=0):

        kill_evt_except()
        Detail(Detail.r_rna_info(self.rna[index]))
        #|

    def dxy(self, dx, dy):
        for e in self.box_button: e.dxy_upd(dx, dy)
        for e in self.blf_value:
            e.x += dx
            e.y += dy
        #|
    def draw_box(self):
        for e in self.box_button: e.bind_draw()
        #|
    def draw_blf(self):
        blfSize(FONT0, D_SIZE['font_main'])
        for e in self.blf_value:
            blfColor(FONT0, *e.color)
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def get(self, index):
        return getattr(self.pp, self.rna[index].identifier)
        #|
    def set(self, v, index, refresh=True, undo_push=True):
        rna = self.rna
        pp = self.pp
        if isinstance(index, int):
            oldvalue = getattr(pp, rna[index].identifier)
            setattr(pp, rna[index].identifier, v)
        else:
            oldvalue = None
            for r, v in zip(range(index[0], index[1]), v):
                setattr(pp, rna[r].identifier, v)
        if refresh: update_data()
        if hasattr(self, "set_callback"): self.set_callback()
        self.evt_undo_push(undo_push, oldvalue, index)
        #|
    def evt_undo_push(self, undo_push, oldvalue, index): pass

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        for r, e in enumerate(self.box_button):
            if self.get(r):
                if e.state in {0, 1}: self.turnon_button(r)
            else:
                if e.state in {0, 1}: continue
                self.turnoff_button(r)
        #|
    #|
    #|


#_c4#_c4#_c4#_c4
class ButtonBoolPref(               # ButtonBoolPref            ButtonBool                      
    StructUndoPushPref,
    ButtonBool):
    __slots__ = ()
class ButtonIntPref(                # StructUndoPushPref        ButtonInt                       
    StructUndoPushPref,
    ButtonInt):
    __slots__ = ()
class ButtonFloatPref(              # StructUndoPushPref        ButtonFloat                     
    StructUndoPushPref,
    ButtonFloat):
    __slots__ = ()
class ButtonIntVectorPref(          # StructUndoPushPrefVector  ButtonIntVector                 
    StructUndoPushPrefVector, ButtonIntVector):
    __slots__ = ()
class ButtonFloatVectorPref(        # StructUndoPushPrefVector  ButtonFloatVector               
    StructUndoPushPrefVector,
    ButtonFloatVector):
    __slots__ = ()
class ButtonStringPref(             # StructUndoPushPref        ButtonString                    
    StructUndoPushPref,
    ButtonString):
    __slots__ = ()

    def __init__(self, w, rna, pp, subtype_override=None):
        if subtype_override == "LINES":
            self.__class__ = ButtonStringXYPref
            self.__init__(w, rna, pp)
            return
        if rna.subtype in {"BYTE_STRING", "LINES"}:
            self.__class__ = ButtonStringXYPref
            self.__init__(w, rna, pp, subtype_override)
            return

        ButtonString.__init__(self, w, rna, pp, subtype_override)
        #|
    #|
    #|
class ButtonStringXYPref(           # StructUndoPushPref        ButtonStringXY                  
    StructUndoPushPref,
    ButtonStringXY):
    __slots__ = ()
class ButtonEnumPref(               # StructUndoPushPref        ButtonEnum                      
    StructUndoPushPref,
    ButtonEnum):
    __slots__ = ()

#_c4#_c4#_c4#_c4
class ButtonBoolTemp(               # ButtonBool                                                
    ButtonBool):
    __slots__ = ()

    def set(self, v, refresh=False, undo_push=False):
        oldvalue = getattr(self.pp, self.rna.identifier)
        setattr(self.pp, self.rna.identifier, v)
        if refresh: update_data()
        self.evt_undo_push(undo_push, oldvalue)

        self.upd_data()
        if hasattr(self, "set_callback"): self.set_callback(v)
        #|
    #|
    #|
class ButtonEnumXYTemp(             # ButtonEnumXY                                              
    ButtonEnumXY):
    __slots__ = ()

    def set(self, v, refresh=False, undo_push=False): # allow input name, Nonetype
        rna = self.rna
        oldvalue = getattr(self.pp, rna.identifier)
        if v in rna.enum_items:
            setattr(self.pp, rna.identifier, v)
            if refresh: update_data()
            self.evt_undo_push(undo_push, oldvalue)
        else:
            if v == None:
                if hasattr(rna, "is_never_none") and rna.is_never_none:
                    self.upd_data()
                    if hasattr(self, "set_callback"): self.set_callback(v)
                    return
            else:
                for e in rna.enum_items:
                    if e.name == v:
                        setattr(self.pp, rna.identifier, e.identifier)
                        if refresh: update_data()
                        self.evt_undo_push(undo_push, oldvalue)
                        self.upd_data()
                        if hasattr(self, "set_callback"): self.set_callback(v)
                        return

        self.upd_data()
        if hasattr(self, "set_callback"): self.set_callback(v)
        #|
    #|
    #|

SLOTS_ED = ("use_push",)
class StructPoll:
    __slots__ = ()

    def set(self, v, refresh=False, undo_push=True):
        if hasattr(self, "poll") and self.poll(self) == False: return
        if hasattr(self, "use_push") and self.use_push == False: undo_push = False
        super().set(v, refresh=refresh, undo_push=undo_push)
        #|
    #|
    #|
class StructPollVector:
    __slots__ = ()

    def set(self, v, index, refresh=False, undo_push=True):
        if hasattr(self, "poll") and self.poll(self) == False: return
        if hasattr(self, "use_push") and self.use_push == False: undo_push = False
        super().set(v, index, refresh=refresh, undo_push=undo_push)
        #|
    #|
    #|

class EdInt(            # StructPoll        StructPush      ButtonInt                               
    StructPoll,
    StructPush,
    ButtonInt):
    __slots__ = SLOTS_ED
class EdIntVector(      # StructPollVector  StructPush      ButtonIntVector
    StructPollVector,
    StructPush,
    ButtonIntVector):
    __slots__ = SLOTS_ED
class EdFloat(          # StructPoll        StructPush      ButtonFloat                             
    StructPoll,
    StructPush,
    ButtonFloat):
    __slots__ = SLOTS_ED
class EdFloatVector(    # StructPollVector  StructPush      ButtonFloatVector                   
    StructPollVector,
    StructPush,
    ButtonFloatVector):
    __slots__ = SLOTS_ED
class EdBool(           # StructPoll        StructPush      ButtonBool                          
    StructPoll,
    StructPush,
    ButtonBool):
    __slots__ = SLOTS_ED
class EdString(         # StructPoll        StructPush      ButtonString                        
    StructPoll,
    StructPush,
    ButtonString):
    __slots__ = SLOTS_ED
class EdStringVector(   # StructPoll        StructPush      ButtonStringVector                  
    StructPoll,
    StructPush,
    ButtonStringVector):
    __slots__ = SLOTS_ED
class EdEnum(           # StructPoll        StructPush      ButtonEnum                          
    StructPoll,
    StructPush,
    ButtonEnum):
    __slots__ = SLOTS_ED
class EdEnumIcon(       # StructPoll        StructPush      ButtonEnumIcon                      
    StructPoll,
    StructPush,
    ButtonEnumIcon):
    __slots__ = SLOTS_ED
class EdEnumIDType(     # StructPoll        StructPush      ButtonEnumIDType                    
    StructPoll,
    StructPush,
    ButtonEnumIDType):
    __slots__ = SLOTS_ED
class EdEnumDriverPath( # StructPoll        StructPush      ButtonEnumDriverPath                
    StructPoll,
    StructPush,
    ButtonEnumDriverPath):
    __slots__ = SLOTS_ED
class EdBoolflag(       # StructPollVector  StructPushIndex ButtonBoolArrayX                    
    StructPollVector,
    StructPushIndex,
    ButtonBoolArrayX):
    __slots__ = SLOTS_ED
class Edfn(             # ButtonFn                                                              
    ButtonFn):
    __slots__ = SLOTS_ED
class EdID(             # StructPoll        StructPush      ButtonEnumID                        
    StructPoll,
    StructPush,
    ButtonEnumID):
    __slots__ = SLOTS_ED
class EdBone(           # StructPoll        StructPush      ButtonEnumBone                      
    StructPoll,
    StructPush,
    ButtonEnumBone):
    __slots__ = SLOTS_ED

#_c4#_c4#_c4#_c4
class ButtonBoolCall(           # ButtonBool                                                    
    ButtonBool):
    __slots__ = 'set_callfront', 'get_default_value'

    def r_default_value(self):
        if hasattr(self, "get_default_value"): return self.get_default_value()
        return self.rna.default
        #|

    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "set_callfront"): v = self.set_callfront(v)

        oldvalue = getattr(self.pp, self.rna.identifier)
        setattr(self.pp, self.rna.identifier, v)
        if refresh: update_data()
        self.evt_undo_push(undo_push, oldvalue)

        if hasattr(self, "set_callback"): self.set_callback(v)
        #|
    #|
    #|
class ButtonStringMatchButton(  # ButtonString                                                  
    ButtonString):
    __slots__ = (
        'box_match_case',
        'box_match_case_bg',
        'box_match_whole_word',
        'box_match_whole_word_bg',
        'box_match_end',
        'box_match_end_bg',
        'box_match_hover',
        'is_match_case',
        'is_match_whole_word',
        'is_match_end',
        'set_callfront',
        'set_callback',
        'get_default_value')

    OFFSET_FAC = 0
    OFFSET_TEXT = ""

    def __init__(self, w, rna, pp, subtype_override=None):
        self.w = w
        self.rna = rna
        self.pp = pp
        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        v = getattr(pp, rna.identifier)
        self.blf_value = BlfClipColor(v, v, 0, 0, COL_box_text_fg)
        self.font_id = FONT0

        if subtype_override is None:
            if rna.subtype in D_subtype_display:
                self.draw_blf = self.i_draw_blf_subtype
                self.dxy = self.i_dxy_subtype
                self.blf_subtype = BlfColor(D_subtype_display[rna.subtype], 0, 0, COL_box_button_fg_info)
            else:
                self.draw_blf = self.i_draw_blf
                self.dxy = self.i_dxy
        else:
            self.draw_blf = self.i_draw_blf_subtype
            self.dxy = self.i_dxy_subtype
            self.blf_subtype = BlfColor(subtype_override[0], 0, 0, COL_box_button_fg_info)

        self.box_match_case = GpuImg_filter_match_case()
        self.box_match_whole_word = GpuImg_filter_match_whole_word()
        self.box_match_end = GpuImg_filter_match_end_left()
        self.box_match_end_bg = GpuImg_filter_match_active()
        self.box_match_whole_word_bg = GpuImg_filter_match_active()
        self.box_match_case_bg = GpuImg_filter_match_active()
        self.is_match_end = P.filter_match_end
        self.is_match_case = P.filter_match_case
        self.is_match_whole_word = P.filter_match_whole_word
        self.box_match_hover = GpuImg_filter_match_hover()
        self.box_match_hover.set_draw_state(False)
        #|

    def r_default_value(self):
        if hasattr(self, "get_default_value"): return self.get_default_value()
        return self.rna.default
        #|

    def init_bat(self, L, R, T):
        cls = self.__class__
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value = self.blf_value
        L += round(SIZE_widget[0] * cls.OFFSET_FAC
            + blfDimen(FONT0, cls.OFFSET_TEXT)[0] + D_SIZE['font_main_title_offset'])
        B = T - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R, B, T, SIZE_border[3])
        L0, R0, B0, T0 = self.box_button.inner
        blf_value.x = L0 + D_SIZE['font_main_dx']
        blf_value.y = B0 + D_SIZE['font_main_dy']
        blf_value.text = r_blf_clipping_end(
            blf_value.text, blf_value.x, R0 - D_SIZE['font_main_dx'])

        self.upd_match_button(L0, R0, B0, T0)
        return B
        #|

    def upd_match_button(self, L, R0, B0, T0):
        h = SIZE_widget[0]
        L0 = R0 - h
        if self.is_match_end == 1:
            if isinstance(self.box_match_end, GpuImg_filter_match_end_right):
                self.box_match_end.__class__ = GpuImg_filter_match_end_left
            self.box_match_end_bg.set_draw_state(True)
        elif self.is_match_end == 2:
            if isinstance(self.box_match_end, GpuImg_filter_match_end_left):
                self.box_match_end.__class__ = GpuImg_filter_match_end_right
            self.box_match_end_bg.set_draw_state(True)
        else:
            if isinstance(self.box_match_end, GpuImg_filter_match_end_right):
                self.box_match_end.__class__ = GpuImg_filter_match_end_left
            self.box_match_end_bg.set_draw_state(False)
        self.box_match_end.LRBT_upd(L0, R0, B0, T0)
        self.box_match_end_bg.LRBT_upd(L0, R0, B0, T0)

        R0 -= h
        L0 -= h
        self.box_match_whole_word.LRBT_upd(L0, R0, B0, T0)
        self.box_match_whole_word_bg.LRBT_upd(L0, R0, B0, T0)
        self.box_match_whole_word_bg.set_draw_state(self.is_match_whole_word)
        R0 -= h
        L0 -= h
        self.box_match_case.LRBT_upd(L0, R0, B0, T0)
        self.box_match_case_bg.LRBT_upd(L0, R0, B0, T0)
        self.box_match_case_bg.set_draw_state(self.is_match_case)
        #|

    def outside_evt(self):
        self.box_match_hover.set_draw_state(False)
        super().outside_evt()
        #|

    def modal(self):
        if MOUSE[0] >= self.box_match_case.L:
            if self.box_match_hover.set_draw_state(True): Admin.REDRAW()
            if MOUSE[0] >= self.box_match_end.L:
                ind = 2
                if not is_LRBT_match(self.box_match_end, self.box_match_hover):
                    Admin.REDRAW()
                    self.box_match_hover.LRBT_upd(*self.box_match_end.r_LRBT())
            elif MOUSE[0] >= self.box_match_whole_word.L:
                ind = 1
                if not is_LRBT_match(self.box_match_whole_word, self.box_match_hover):
                    Admin.REDRAW()
                    self.box_match_hover.LRBT_upd(*self.box_match_whole_word.r_LRBT())
            else:
                ind = 0
                if not is_LRBT_match(self.box_match_case, self.box_match_hover):
                    Admin.REDRAW()
                    self.box_match_hover.LRBT_upd(*self.box_match_case.r_LRBT())

            if TRIGGER['click']():
                if ind == 0: self.evt_toggle_match_case()
                elif ind == 1: self.evt_toggle_match_whole_word()
                else: self.evt_toggle_match_end()
                return True
        else:
            if self.box_match_hover.set_draw_state(False): Admin.REDRAW()
        return super().modal()
        #|

    def evt_toggle_match_case(self, v=None):

        kill_evt_except()
        Admin.REDRAW()
        if v == None: v = not self.is_match_case
        self.is_match_case = v
        self.upd_match_button(*self.box_button.inner)
        if hasattr(self, "set_callback"):
            self.set_callback((self.is_match_case, self.is_match_whole_word, self.is_match_end))
        #|
    def evt_toggle_match_whole_word(self, v=None):

        kill_evt_except()
        Admin.REDRAW()
        if v == None: v = not self.is_match_whole_word
        self.is_match_whole_word = v
        self.upd_match_button(*self.box_button.inner)
        if hasattr(self, "set_callback"):
            self.set_callback((self.is_match_case, self.is_match_whole_word, self.is_match_end))
        #|
    def evt_toggle_match_end(self, v=None):

        kill_evt_except()
        Admin.REDRAW()
        if v == None:
            v = self.is_match_end + 1
            if v == 3: v = 0
        self.is_match_end = v
        self.upd_match_button(*self.box_button.inner)
        if hasattr(self, "set_callback"):
            self.set_callback((self.is_match_case, self.is_match_whole_word, self.is_match_end))
        #|

    def i_dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_match_case.dxy_upd(dx, dy)
        self.box_match_whole_word.dxy_upd(dx, dy)
        self.box_match_end.dxy_upd(dx, dy)
        self.box_match_case_bg.dxy_upd(dx, dy)
        self.box_match_whole_word_bg.dxy_upd(dx, dy)
        self.box_match_end_bg.dxy_upd(dx, dy)
        self.box_match_hover.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def i_dxy_subtype(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_match_case.dxy_upd(dx, dy)
        self.box_match_whole_word.dxy_upd(dx, dy)
        self.box_match_end.dxy_upd(dx, dy)
        self.box_match_case_bg.dxy_upd(dx, dy)
        self.box_match_whole_word_bg.dxy_upd(dx, dy)
        self.box_match_end_bg.dxy_upd(dx, dy)
        self.box_match_hover.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy

        self.blf_subtype.x += dx
        self.blf_subtype.y += dy
        #|

    def draw_box(self):
        self.box_button.bind_draw()
        self.box_match_hover.bind_draw()
        self.box_match_case_bg.bind_draw()
        self.box_match_whole_word_bg.bind_draw()
        self.box_match_end_bg.bind_draw()
        self.box_match_case.bind_draw()
        self.box_match_whole_word.bind_draw()
        self.box_match_end.bind_draw()
        #|

    def set(self, v, refresh=True, undo_push=True):
        if hasattr(self, "set_callfront"): v = self.set_callfront(v)

        oldvalue = getattr(self.pp, self.rna.identifier)
        if self.rna.subtype == "BYTE_STRING" and not isinstance(v, bytes): v = str.encode(v)
        setattr(self.pp, self.rna.identifier, v)
        if refresh: update_data()
        self.evt_undo_push(undo_push, oldvalue)

        if hasattr(self, "set_callback"): self.set_callback(v)
        #|

    def upd_data(self):
        if hasattr(self, "r_pp"): self.pp = self.r_pp()
        if self.pp is None: return
        if self.blf_value.unclip_text == getattr(self.pp, self.rna.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.rna.identifier)
        blf_value.unclip_text = v
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value.text = r_blf_clipping_end(v,
            blf_value.x, self.box_button.inner[1] - D_SIZE['font_main_dx'] - 3 * SIZE_widget[0])
        #|
    #|
    #|

#_c4#_c4#_c4#_c4
@ successResult
def paste_full_data_path_as_driver_safe(s, fc, dp, ob, rna, pp, index=None, update_push=True):
    if r_library_editable(ob) is False:
        report(r_library_or_override_message(ob))
        return

    if not s:
        report("Clipboard is empty")
        return

    tar_obj, dr_path = r_obj_path_by_full_path(s)
    if tar_obj is None:
        report("Invalid path")
        return

    id_type = r_id_type(tar_obj)
    if id_type is None:
        report("Invalid Object ID Type")
        return

    if fc:
        pp.driver_remove(rna.identifier)  if index is None else pp.driver_remove(rna.identifier, index)

    if hasattr(rna, "bl_socket_idname"):
        fc = pp.driver_add(f'["{escape_identifier(rna.identifier)}"]')  if index is None else pp.driver_add(f'["{escape_identifier(rna.identifier)}"]', index)
    elif rna.is_animatable:
        fc = pp.driver_add(rna.identifier)  if index is None else pp.driver_add(rna.identifier, index)
    else:
        fc = r_md_driver_add(ob, pp.name, rna.identifier)

    vs = fc.driver.variables
    v = vs[0] if vs else vs.new()
    tar = v.targets[0]
    tar.id_type = id_type
    tar.id = tar_obj
    tar.data_path = dr_path
    fc.driver.expression = v.name

    if update_push:
        update_scene_push("Paste Full Path as Driver")
        upd_link_data()
    #|

@ successResult
def add_new_driver(ob, rna, pp, index=None, exp="var", update_push=True):
    if r_library_editable(ob) is False:
        report(r_library_or_override_message(ob))
        return

    if hasattr(rna, "bl_socket_idname"):
        fc = pp.driver_add(f'["{escape_identifier(rna.identifier)}"]')  if index is None else pp.driver_add(f'["{escape_identifier(rna.identifier)}"]', index)
        driver = fc.driver
        driver.type = "SCRIPTED"
        driver.expression = exp
    elif rna.is_animatable:
        fc = pp.driver_add(rna.identifier)  if index is None else pp.driver_add(rna.identifier, index)
        driver = fc.driver
        driver.type = "SCRIPTED"
        driver.expression = exp
    else:
        # if type(ob) != bpy.types.Object:
        #     report("This attribute does not support Reference Driver")
        #     return

        r_md_driver_add(ob, pp.name, rna.identifier, exp=exp, use_variable=False)
    if update_push: update_scene_push("Add Driver")
    #|

@ successResult
def add_new_keyframe(ob, rna, pp, index=None, update_push=True):
    if r_library_editable(ob) is False:
        report(r_library_or_override_message(ob))
        return

    if not rna.is_animatable:
        report("This property cannot be animated")
        return

    if hasattr(rna, "bl_socket_idname"):
        if index is None:
            pp.keyframe_insert(f'["{escape_identifier(rna.identifier)}"]')
        else:
            pp.keyframe_insert(f'["{escape_identifier(rna.identifier)}"]', index=index)
    else:
        if index is None:
            pp.keyframe_insert(rna.identifier)
        else:
            pp.keyframe_insert(rna.identifier, index=index)

    if update_push: update_scene_push("Insert Keyframe")
    #|

@ successResult
def del_keyframe(ob, rna, pp, index=None, update_push=True):
    if r_library_editable(ob) is False:
        report(r_library_or_override_message(ob))
        return

    if hasattr(rna, "bl_socket_idname"):
        if index is None:
            pp.keyframe_delete(f'["{escape_identifier(rna.identifier)}"]')
        else:
            pp.keyframe_delete(f'["{escape_identifier(rna.identifier)}"]', index=index)
    else:
        if index is None:
            pp.keyframe_delete(rna.identifier)
        else:
            pp.keyframe_delete(rna.identifier, index=index)

    if update_push: update_scene_push("Delete Keyframe")
    #|

@ successResult
def clear_keyframe(ob, fc, update_push=True):
    if r_library_editable(ob) is False:
        report(r_library_or_override_message(ob))
        return

    if ob.animation_data and ob.animation_data.action and ob.animation_data.action.fcurves:
        ob.animation_data.action.fcurves.remove(fc)

        if update_push: update_scene_push("Clear Keyframe")
    #|

@ catch
def open_driver_editor_from(datablock, dp, index=None):

    w = m.D_EDITOR["DriverEditor"](
        id_class = "DriverEditor",
        use_pos = True,
        use_fit = True,
        pos_offset = (-15, 15)
    )
    w.set_driver_to(datablock, dp, index=index)
    #|

#_c4#_c4#_c4#_c4
class BlockSep(             # ButtonSep                                                         
    ButtonSep):
    __slots__ = 'box_block'

    def __init__(self):
        self.box_block = GpuBox()
        #|

    def init_bat(self, L, R, T):
        B = T - SIZE_block[6]
        self.box_block.LRBT(L, R, B, T)
        return B
    def r_height(self, width): return SIZE_block[6]

    def dxy(self, dx, dy): self.box_block.dxy(dx, dy)
    #|
    #|

class BlockSubtab:
    __slots__ = (
        'w',
        'rna',
        'fn',
        'box_block',
        'box_icon',
        'blf_title',
        'blf_info')

    def __init__(self, w, rna, fn):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.box_block = GpuBox(COL_block)
        self.blf_title = Blf(rna.name)
        self.blf_info = []
        self.box_icon = getattr(blg, rna.icon_id, BoxFake)()
        #|

    def init_bat(self, L, R, T):
        blf_info = self.blf_info
        font_subtitle_dx = D_SIZE['font_subtitle_dx']
        offset_x = SIZE_block[1] + font_subtitle_dx
        L0 = L + offset_x
        T0 = T - SIZE_block[4]
        y = T0 - D_SIZE['font_subtitle_dT']
        B0 = y - D_SIZE['font_subtitle_dy']
        icon_h = T0 - B0
        R0 = L0 + icon_h
        self.box_icon.LRBT_upd(L0, R0, B0 - font_subtitle_dx, T0 - font_subtitle_dx)
        x = R0 + offset_x
        self.blf_title.x = x
        self.blf_title.y = y
        y -= SIZE_block[5]

        blfSize(FONT0, D_SIZE['font_label'])
        infos = self.rna.description.split('\n')
        if len(infos) == 1:
            blf_info[:] = rl_blf_wrap_LR(infos[0], x, R - offset_x, y,
                floor((D_SIZE['font_label_dy'] + D_SIZE['font_label_dT']) * SIZE_foreground_height[3]))
        else:
            blf_info.clear()
            depth = floor((D_SIZE['font_label_dy'] + D_SIZE['font_label_dT']) * SIZE_foreground_height[3])
            for info in infos:
                blf_info += rl_blf_wrap_LR(info, x, R - offset_x, y, depth)
                y = blf_info[-1].y - depth

        B = (blf_info[-1].y  if blf_info else y) - D_SIZE['font_label_dy'] - SIZE_block[3]
        self.box_block.LRBT_upd(L, R, B, T)
        return B
        #|
    def r_height(self, width):
        R = width
        T = 0
        blf_info = []
        offset_x = SIZE_block[1] + D_SIZE['font_subtitle_dx']
        x = offset_x
        y = T - SIZE_block[4] - D_SIZE['font_subtitle_dT']
        y -= SIZE_block[5]

        blfSize(FONT0, D_SIZE['font_label'])
        infos = self.rna.description.split('\n')
        if len(infos) == 1:
            blf_info[:] = rl_blf_wrap_LR(infos[0], x, R - offset_x, y,
                floor((D_SIZE['font_label_dy'] + D_SIZE['font_label_dT']) * SIZE_foreground_height[3]))
        else:
            blf_info.clear()
            depth = floor((D_SIZE['font_label_dy'] + D_SIZE['font_label_dT']) * SIZE_foreground_height[3])
            for info in infos:
                blf_info += rl_blf_wrap_LR(info, x, R - offset_x, y, depth)
                y = blf_info[-1].y - depth

        B = (blf_info[-1].y  if blf_info else y) - D_SIZE['font_label_dy'] - SIZE_block[3]
        return -B
        #|

    def inside_evt(self):
        self.box_block.color = COL_block_fo
        #|
    def outside_evt(self):
        self.box_block.color = COL_block
        #|

    def modal(self):
        if TRIGGER['click']():
            if self.fn.__defaults__ is None:
                self.fn()
            else:
                self.fn(self)
        #|

    def dxy(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        self.box_icon.dxy_upd(dx, dy)
        self.blf_title.x += dx
        self.blf_title.y += dy
        for e in self.blf_info:
            e.x += dx
            e.y += dy
        #|

    def draw_box(self):
        self.box_block.bind_draw()
        self.box_icon.bind_draw()
        #|
    def draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_subtitle'])
        blfColor(FONT0, *COL_block_fg)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        blfSize(FONT0, D_SIZE['font_label'])
        blfColor(FONT0, *COL_block_fg_info)
        for e in self.blf_info:
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def upd_data(self): pass
    #|
    #|
class BlockCalcDisplay:
    __slots__ = (
        'w',
        'box_block',
        'blf_title',
        'blf_info')

    def __init__(self, w):
        self.w = w
        self.box_block = GpuBox(COL_block_calc_display)
        self.blf_title = Blf("Click here to calculate")
        self.blf_info = []
        #|

    def init_bat(self, L, R, T):
        rna = self.w.w.data["rna"]
        blf_info = self.blf_info
        offset_x = SIZE_block[1] + D_SIZE['font_main_dx']
        x = L + offset_x
        y = T - SIZE_block[4] - D_SIZE['font_main_dT']
        self.blf_title.x = x
        self.blf_title.y = y
        y -= SIZE_block[5]

        # blfSize(FONT0, D_SIZE['font_label'])
        depth = floor((D_SIZE['font_label_dy'] + D_SIZE['font_label_dT']) * SIZE_foreground_height[3])
        if hasattr(rna, "hard_min"):
            hard_min = rna.hard_min
            hard_max = rna.hard_max
        else:
            hard_min = rna.min_value
            hard_max = rna.max_value

        blf_info[:] = [
            Blf(f"min :  {value_to_display(hard_min)}", x, y),
            Blf(f"max :  {value_to_display(hard_max)}", x, y - depth)]

        B = blf_info[-1].y - D_SIZE['font_label_dy'] - SIZE_block[3]
        self.box_block.LRBT_upd(L, R, B, T)
        return B
        #|
    def r_height(self, width):
        R = width
        T = 0
        rna = self.w.w.data["rna"]
        blf_info = []
        offset_x = SIZE_block[1] + D_SIZE['font_main_dx']
        x = offset_x
        y = T - SIZE_block[4] - D_SIZE['font_main_dT']
        y -= SIZE_block[5]

        # blfSize(FONT0, D_SIZE['font_label'])
        depth = floor((D_SIZE['font_label_dy'] + D_SIZE['font_label_dT']) * SIZE_foreground_height[3])
        if hasattr(rna, "hard_min"):
            hard_min = rna.hard_min
            hard_max = rna.hard_min
        else:
            hard_min = rna.min_value
            hard_max = rna.max_value

        blf_info[:] = [
            Blf(f"min :  {value_to_display(hard_min)}", x, y),
            Blf(f"max :  {value_to_display(hard_max)}", x, y - depth)]

        B = blf_info[-1].y - D_SIZE['font_label_dy'] - SIZE_block[3]
        return -B
        #|

    def outside_evt(self):
        self.box_block.color = COL_block_calc_display
        Admin.REDRAW()
        #|

    def modal(self):
        if TRIGGER['click']():
            self.w.w.area_textbox.calc_text()
            return True
        return False
        #|

    def dxy(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        self.blf_title.x += dx
        self.blf_title.y += dy
        for e in self.blf_info:
            e.x += dx
            e.y += dy
        #|

    def draw_box(self):
        self.box_block.bind_draw()
        #|
    def draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *COL_block_fg)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        blfSize(FONT0, D_SIZE['font_label'])
        blfColor(FONT0, *COL_block_fg_info)
        for e in self.blf_info:
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def upd_data(self): pass
    #|
    #|


class FnDarkButton0:
    __slots__ = ()

    def dark(self):
        if hasattr(self.button0, "dark"): self.button0.dark()
        #|
    def light(self):
        if hasattr(self.button0, "light"): self.button0.light()
        #|
    #|
    #|
class FnDarkButtons:
    __slots__ = ()

    def dark(self):
        for e in self.buttons:
            if hasattr(e, "dark"): e.dark()
        #|
    def light(self):
        for e in self.buttons:
            if hasattr(e, "light"): e.light()
        #|
    #|
    #|
class FnDarkItems:
    __slots__ = ()

    def dark(self, use_head=True):
        if use_head:
            if hasattr(self, "button0"):
                if hasattr(self.button0, "dark"):
                    self.button0.dark()
            elif hasattr(self, "buttons"):
                if self.buttons:
                    for e in self.buttons:
                        if hasattr(e, "dark"): e.dark()

        for e in self.items:
            if hasattr(e, "dark"): e.dark()
        #|
    def light(self, use_head=True):
        if use_head:
            if hasattr(self, "button0"):
                if hasattr(self.button0, "light"):
                    self.button0.light()
            elif hasattr(self, "buttons"):
                if self.buttons:
                    for e in self.buttons:
                        if hasattr(e, "light"): e.light()

        for e in self.items:
            if hasattr(e, "light"): e.light()
        #|
    #|
    #|
class BlockFull(FnDarkButton0):
    __slots__ = (
        'w',
        'button0',
        'box_block',
        'upd_data',
        'focus_element')

    def __init__(self, w, button0):
        self.w = w
        self.box_block = GpuBox_block()
        self.button0 = button0
        button0.w = self
        self.upd_data = button0.upd_data
        #|

    def init_bat(self, L, R, T):
        B = self.button0.init_bat(L, R, T)
        self.box_block.LRBT_upd(L, R, B, T)
        return B
        #|
    def r_height(self, width):
        return self.button0.r_height(width)
        #|

    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        self.button0.outside_evt()
        #|

    def modal(self):
        if self.button0.inside(MOUSE): e = self.button0
        else: e = None

        if e is None:
            if self.focus_element is not None:
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        return False
        #|

    def to_modal_rm(self):

        items = []
        if hasattr(self.w, "evt_fold_all_toggle"):
            items.append(("Unfold All", self.w.evt_unfold_all))
            items.append(("Fold All", self.w.evt_fold_all))
            items.append(("fold_all_toggle", self.w.evt_fold_all_toggle))
        if hasattr(self.w, "w") and hasattr(self.w.w, "evt_undo"):
            items.append(("redo", self.w.w.evt_redo))
            items.append(("undo", self.w.w.evt_undo))

        if items: DropDownRMKeymap(self, MOUSE, items)
        #|

    def dxy(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        self.button0.dxy(dx, dy)
        #|
    def draw_box(self):
        self.box_block.bind_draw()
        self.button0.draw_box()
        #|
    def draw_blf(self):
        self.button0.draw_blf()
        #|
    #|
    #|
class BlockR(FnDarkButtons):
    __slots__ = (
        'w',
        'buttons',
        'box_block',
        'focus_element',
        'use_anim_slot')

    def __init__(self, w):
        self.w = w
        self.box_block = GpuBox_block()
        self.use_anim_slot = True
        #|

    def init_bat(self, LL, RR, TT):
        gap = SIZE_button[1]
        full_h = D_SIZE['widget_full_h']
        T = TT - SIZE_block[4]
        B = T - full_h
        R = RR - SIZE_block[2]
        L = R - D_SIZE['widget_width']
        Lb = R - D_SIZE['widget_bool_full_h']

        for e in self.buttons:
            if hasattr(e, "rna") and hasattr(e, "type") and e.rna.type == "BOOLEAN":
                T = e.init_bat(Lb, R, T - D_SIZE['widget_bool_dT']) - D_SIZE['widget_bool_dB'] - gap
            else:
                T = e.init_bat(L, R, T) - gap

        B = T + gap - SIZE_block[3]
        self.box_block.LRBT_upd(LL, RR, B, TT)
        return B
        #|
    def r_height(self, width):
        return sum(e.r_height(width) for e in self.buttons) + (len(self.buttons) - 1) * SIZE_button[1] + SIZE_block[4] + SIZE_block[3]
        #|

    def inside(self, mouse): return self.box_block.inbox(mouse)
    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        for e in self.buttons: e.outside_evt()
        #|

    def modal(self):
        e = None
        for button in self.buttons:
            if button.inside(MOUSE):
                e = button
                break

        if e is None:
            if self.focus_element is not None:
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True

        return False
        #|

    def dxy(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        for e in self.buttons: e.dxy(dx, dy)
        #|
    def draw_box(self):
        self.box_block.bind_draw()
        for e in self.buttons: e.draw_box()
        #|
    def draw_blf(self):
        for e in self.buttons: e.draw_blf()
        #|

    def no_background(self):
        self.box_block.__class__ = GpuBox
        self.box_block.color = FLO_0000
        #|

    def upd_data(self):
        for e in self.buttons: e.upd_data()
        #|
    #|
    #|
class Blocks(BlockR):
    __slots__ = 'area', 'level', 'is_fold', 'r_offset_L'

    def __init__(self, w):
        self.w = w
        self.box_block = GpuBox_block()
        self.is_fold = False

        if hasattr(w, "level"):
            self.level = w.level + 1
            self.area = w.area
            self.use_anim_slot = w.use_anim_slot
        else:
            self.level = 0
            self.area = w
            self.use_anim_slot = True
        #|

    def init_bat(self, LL, RR, TT):
        gap = SIZE_button[1]
        full_h = D_SIZE['widget_full_h']
        T = TT - SIZE_block[4]
        B = T - full_h

        if hasattr(self, "level"):
            if self.level == 0: pass
            else:
                LL += SIZE_widget[0] // 2

        if hasattr(self, "r_offset_L"):
            L = LL + SIZE_block[1] + self.r_offset_L()
        else:
            L = LL + SIZE_block[1]

        for e in self.buttons:
            if hasattr(e, "level"):
                T = e.init_bat(LL, RR, T) - gap
            else:
                if self.use_anim_slot is False:
                    T = e.init_bat(L, RR - SIZE_block[2] + SIZE_border[3] + SIZE_widget[0], T) - gap
                else:
                    T = e.init_bat(L, RR - SIZE_block[2], T) - gap

        B = T + gap - SIZE_block[3]
        self.box_block.LRBT_upd(LL, RR, B, TT)
        return B
        #|

    def r_width_input(self, button):
        if hasattr(button, "level"):
            if hasattr(self, "r_offset_L"):
                return self.w.r_width_input(self) - self.r_offset_L()
            return self.w.r_width_input(self)
        else:
            if hasattr(self, "r_offset_L"):
                return self.w.r_width_input(self) - SIZE_block[1] - SIZE_block[2] - self.r_offset_L()
            return self.w.r_width_input(self) - SIZE_block[1] - SIZE_block[2]
        #|

    def init_fold(self, recursive=False):
        self.is_fold = True
        for e in self.buttons:
            if hasattr(e, "init_fold"): e.init_fold(recursive=recursive)
        #|
    def init_unfold(self, recursive=False):
        self.is_fold = False
        for e in self.buttons:
            if hasattr(e, "init_unfold"): e.init_unfold(recursive=recursive)
        #|

    def no_background(self):
        self.box_block.__class__ = GpuBox
        self.box_block.color = FLO_0000
        #|
    #|
    #|

class BlockCalcButton:
    __slots__ = (
        'w',
        'rna',
        'box_block',
        'box_button',
        'blf_value',
        'is_inside_button',
        'is_trigger_enable',
        'is_repeat',
        'active_index',
        'active_tab')

    def __init__(self, w, ty="Float"):
        self.w = w
        self.is_repeat = True

        self.box_block = GpuBox(COL_block_calc_button_bg)
        self.box_button = [GpuButton()  for _ in range(10)]
        self.rna = []
        self.blf_value = [BlfClipColor(color=COL_box_button_fg) for _ in range(10)]

        self.active_index = None
        self.active_tab = ty
        #|

    def init_bat(self, L, R, T):
        offset_x = SIZE_block[1] + D_SIZE['font_main_dx']
        x = L + offset_x

        h = D_SIZE['widget_full_h']
        widget_spacing = SIZE_widget[3]
        widget_rim = SIZE_border[3]
        T0 = T - widget_spacing
        B0 = T0 - h
        L0 = L + widget_spacing
        R0 = R - widget_spacing
        L0_R0 = R0 + L0
        R1 = floor(L0_R0 / 2 - widget_spacing)
        L1 = R1 + widget_spacing
        L0_R1 = L0 + R1
        L1_R0 = L1 + R0
        depth = h + widget_spacing
        y = T0 - D_SIZE['font_main_dT']
        blfSize(FONT0, D_SIZE['font_main'])

        box_button = self.box_button
        blf_value = self.blf_value
        box_button[0].LRBT_upd(L0, R1, B0, T0, widget_rim)
        blf_value[0].y = y
        box_button[1].LRBT_upd(L1, R0, B0, T0, widget_rim)
        blf_value[1].y = y
        T0 -= depth
        B0 -= depth
        y -= depth
        box_button[2].LRBT_upd(L0, R1, B0, T0, widget_rim)
        blf_value[2].y = y
        box_button[3].LRBT_upd(L1, R0, B0, T0, widget_rim)
        blf_value[3].y = y
        T0 -= depth
        B0 -= depth
        y -= depth
        box_button[4].LRBT_upd(L0, R1, B0, T0, widget_rim)
        blf_value[4].y = y
        box_button[5].LRBT_upd(L1, R0, B0, T0, widget_rim)
        blf_value[5].y = y
        T0 -= depth
        B0 -= depth
        y -= depth
        box_button[6].LRBT_upd(L0, R1, B0, T0, widget_rim)
        blf_value[6].y = y
        box_button[7].LRBT_upd(L1, R0, B0, T0, widget_rim)
        blf_value[7].y = y
        T0 -= depth
        B0 -= depth
        y -= depth
        box_button[8].LRBT_upd(L0, R0, B0, T0, widget_rim)
        blf_value[8].y = y
        T0 -= depth
        B0 -= depth
        y -= depth
        box_button[9].LRBT_upd(L0, R0, B0, T0, widget_rim)
        blf_value[9].y = y

        B = B0 - widget_spacing
        self.box_block.LRBT_upd(L, R, B, T)
        self.update_buttons(self.active_tab)
        return B
        #|
    def r_height(self, width): return 0

    def inside_evt(self):
        pass
        #|
    def outside_evt(self):
        if self.is_repeat:
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>

        if self.active_index is not None:
            self.box_button[self.active_index].set_state_default()
            Admin.REDRAW()
        self.active_index = None
        #|

    def modal(self):
        for r, e in enumerate(self.box_button):
            if e.inbox(MOUSE):
                if self.active_index != r:
                    # <<< 1copy (0block_BlockButtons_outside_button,, ${'self.active_index = None':''}$)
                    if self.active_index is not None:
                        if self.is_repeat:
                            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                            if timer_isreg(timer_button):
                                timer_unreg(timer_button)

                            # >>>
                            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                            if timer_isreg(timer_hold):
                                timer_unreg(timer_hold)

                            # >>>

                        self.box_button[self.active_index].set_state_default()
                        Admin.REDRAW()
                        
                    # >>>

                    e.set_state_focus()
                    Admin.REDRAW()
                    self.active_index = r
                    self.is_trigger_enable = True

                if self.is_trigger_enable is True:
                    if TRIGGER['click']():
                        Admin.REDRAW()
                        self.is_trigger_enable = False
                        e.set_state_press()
                        if hasattr(self.fn, '__len__'): self.fn[r]()
                        else: self.fn()
                        if self.is_repeat: self.reg_repeat_timer()
                        return True
                elif EVT_TYPE[0] == "TIMER_REPORT": pass
                else:
                    if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                        if self.is_repeat:
                            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                            if timer_isreg(timer_button):
                                timer_unreg(timer_button)

                            # >>>
                            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                            if timer_isreg(timer_hold):
                                timer_unreg(timer_hold)

                            # >>>
                        self.is_trigger_enable = True
                        e.set_state_focus()
                        Admin.REDRAW()
                return False

        # /* 0block_BlockButtons_outside_button
        if self.active_index is not None:
            if self.is_repeat:
                # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                if timer_isreg(timer_button):
                    timer_unreg(timer_button)

                # >>>
                # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                if timer_isreg(timer_hold):
                    timer_unreg(timer_hold)

                # >>>

            self.box_button[self.active_index].set_state_default()
            Admin.REDRAW()
            self.active_index = None
        # */
        return False
        #|

    def reg_repeat_timer(self):
        global _timer_button_fn
        _timer_button_fn = self.fn[self.active_index]  if hasattr(self.fn, '__len__') else self.fn

        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    def dxy(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        for e in self.box_button: e.dxy_upd(dx, dy)
        for e in self.blf_value:
            e.x += dx
            e.y += dy
        #|
    def draw_box(self):
        self.box_block.bind_draw()
        for e in self.box_button: e.bind_draw()
        #|
    def draw_blf(self):
        blfSize(FONT0, D_SIZE['font_main'])
        for e in self.blf_value:
            blfColor(FONT0, *e.color)
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def fn(self):

        area_textbox = self.w.w.area_textbox
        area_textbox.calc_text()
        area_textbox.beam_input_replace(self.rna[self.active_index].description)
        area_textbox.calc_text(False)
        if is_value(area_textbox.calc.ans_flo):
            area_textbox.beam_input_replace(self.w.w.area_display.item.blf_title.text)
        #|

    def update_buttons(self, ty):
        rna = self.rna
        rna[:] = r_calc_button_rnas(ty)
        self.active_tab = ty
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_value = self.blf_value

        d2 = (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2
        L0 = self.box_button[0].L
        R0 = self.box_button[0].R
        L9 = self.box_button[9].L
        R9 = self.box_button[9].R
        LR0 = L0 + R0
        LR9 = L9 + R9
        LR1 = self.box_button[1].L + self.box_button[1].R
        clip_R0 = R0 - L0 - d2
        clip_R9 = R9 - L9 - d2
        for r in range(10):
            e = blf_value[r]
            e.unclip_text = rna[r].default
            if r > 7:
                e.text = r_blf_clipping_end(e.unclip_text, 0, clip_R9)
                e.x = floor((LR9 - blfDimen(FONT0, e.text)[0]) / 2)
            else:
                e.text = r_blf_clipping_end(e.unclip_text, 0, clip_R0)
                if r % 2 == 0:
                    e.x = floor((LR0 - blfDimen(FONT0, e.text)[0]) / 2)
                else:
                    e.x = floor((LR1 - blfDimen(FONT0, e.text)[0]) / 2)
        #|

    def upd_data(self): pass
    #|
    #|

class BlockUtil(FnDarkItems):
    __slots__ = (
        'w',
        'items',
        'button0',
        'button_fold',
        'box_block',
        'blf_title',
        'is_fold',
        'init_bat',
        'draw_box',
        'draw_blf',
        'r_height',
        'dxy',
        'focus_element',
        'level',
        'area',
        'box_guideline',
        'box_title',
        'use_anim_slot')

    DEFAULT_FOLD_STATE = False

    def __init__(self, w, items, button0=None, title=""):
        self.w = w

        if hasattr(w, "level"):
            self.level = w.level + 1
            self.area = w.area
            self.use_anim_slot = w.use_anim_slot

            if hasattr(w, "box_block"):
                if isinstance(w.box_block, GpuBox_block):
                    self.box_block = GpuBox(COL_block_even)
                    self.box_title = GpuBox(COL_block_title_even)
                    self.box_guideline = GpuBox(COL_block_guideline1)
                else:
                    self.box_block = GpuBox_block()
                    self.box_title = GpuBox(COL_block_title)
                    self.box_guideline = GpuBox(COL_block_guideline0)
            else:
                if self.level % 2 == 0:
                    self.box_block = GpuBox_block()
                    self.box_title = GpuBox(COL_block_title)
                    self.box_guideline = GpuBox(COL_block_guideline0)
                else:
                    self.box_block = GpuBox(COL_block_even)
                    self.box_title = GpuBox(COL_block_title_even)
                    self.box_guideline = GpuBox(COL_block_guideline1)
        else:
            self.use_anim_slot = True
            self.level = 0
            self.area = w
            self.box_block = GpuBox_block()
            self.box_title = GpuBox(COL_block_title)
            self.box_guideline = GpuBox(COL_block_guideline0)

        self.button0 = button0
        if button0 is not None: button0.w = self
        self.blf_title = Blf(title)
        self.button_fold = ButtonFold(self)
        self.items = items
        self.init_fold()  if BlockUtil.DEFAULT_FOLD_STATE else self.init_unfold()
        #|
    def init_fold(self, recursive=False):
        self.is_fold = True
        self.init_bat = self.i_init_bat_fold
        self.draw_box = self.i_draw_box_fold
        self.draw_blf = self.i_draw_blf_fold
        self.r_height = self.i_r_height_fold
        self.dxy = self.i_dxy_fold
        self.button_fold.box_button = GpuImg_fold()

        if recursive and self.items:
            for e in self.items:
                if hasattr(e, "init_fold"): e.init_fold(recursive=recursive)
        #|
    def init_unfold(self, recursive=False):
        self.is_fold = False
        self.init_bat = self.i_init_bat
        self.draw_box = self.i_draw_box
        self.draw_blf = self.i_draw_blf
        self.r_height = self.i_r_height
        self.dxy = self.i_dxy
        self.button_fold.box_button = GpuImg_unfold()

        if recursive and self.items:
            for e in self.items:
                if hasattr(e, "init_unfold"): e.init_unfold(recursive=recursive)
        #|

    def i_init_bat(self, L, R, T):
        # guideline_width = SIZE_block[7]
        block_gap = SIZE_block[0]
        button_gap = SIZE_button[1]
        h = SIZE_widget[0]

        if self.level == 0: pass
        else:
            L += h // 2

        iconL = L + SIZE_block[1]
        iconR = iconL + h
        T0 = T - SIZE_block[8]
        iconT = T0 - SIZE_border[3]
        iconB = iconT - h

        if self.use_anim_slot is False:
            R0 = R - SIZE_block[2] + SIZE_border[3] + h
        else:
            R0 = R - SIZE_block[2]

        self.button_fold.box_button.LRBT_upd(iconL, iconR, iconB, iconT)
        self.blf_title.x = iconR + SIZE_border[3]
        self.blf_title.y = iconT - D_SIZE['font_main_dT']

        B = ((T0 - D_SIZE['widget_full_h'])  if self.button0 is None else self.button0.init_bat(iconR, R0, T0)) - SIZE_block[9]
        self.box_title.LRBT_upd(L, R, B, T)

        T1 = B - SIZE_block[4]

        if self.items:
            for e in self.items:
                if hasattr(e, "level"):
                    T1 = e.init_bat(L, R, T1) - block_gap
                else:
                    T1 = e.init_bat(iconL, R0, T1) - button_gap

            T1 += block_gap  if hasattr(self.items[-1], "level") else button_gap

        T1 -= SIZE_block[3]
        self.box_block.LRBT_upd(L, R, T1, T)
        self.box_guideline.LRBT_upd(iconL, iconL + SIZE_block[7], T1, B)
        return T1
        #|
    def i_init_bat_fold(self, L, R, T):
        block_gap = SIZE_block[0]
        button_gap = SIZE_button[1]
        h = SIZE_widget[0]

        if self.level == 0: pass
        else:
            L += h // 2

        iconL = L + SIZE_block[1]
        iconR = iconL + h
        T0 = T - SIZE_block[8]
        iconT = T0 - SIZE_border[3]
        iconB = iconT - h

        if self.use_anim_slot is False:
            R0 = R - SIZE_block[2] + SIZE_border[3] + h
        else:
            R0 = R - SIZE_block[2]

        self.button_fold.box_button.LRBT_upd(iconL, iconR, iconB, iconT)
        self.blf_title.x = iconR + SIZE_border[3]
        self.blf_title.y = iconT - D_SIZE['font_main_dT']

        B = ((T0 - D_SIZE['widget_full_h'])  if self.button0 is None else self.button0.init_bat(iconR, R0, T0)) - SIZE_block[9]
        self.box_title.LRBT_upd(L, R, B, T)
        self.box_block.LRBT_upd(L, R, B, T)
        return B
        #|
    def i_r_height(self, width):
        block_gap = SIZE_block[0]
        button_gap = SIZE_button[1]
        width_button = width - SIZE_block[1] - SIZE_block[2]

        if self.items:
            items_h = sum(
                (e.r_height(width) + block_gap)  if hasattr(e, "level") else (e.r_height(width_button) + button_gap)
                for e in self.items
            )
            items_h -= block_gap  if hasattr(self.items[-1], "level") else button_gap
        else:
            items_h = 0

        return items_h + SIZE_block[8] + (D_SIZE['widget_full_h']  if self.button0 is None else self.button0.r_height(width_button - SIZE_widget[0])) + SIZE_block[9] + SIZE_block[4] + SIZE_block[3]
        #|
    def i_r_height_fold(self, width):
        return SIZE_block[8] + (D_SIZE['widget_full_h']  if self.button0 is None else self.button0.r_height(width - SIZE_block[1] - SIZE_block[2] - SIZE_widget[0])) + SIZE_block[9]
        #|

    def r_width_input(self, button):
        if self.level == 0:
            if hasattr(button, "level"):
                return self.w.r_width_input(self)
            else:
                return self.w.r_width_input(self) - SIZE_block[1] - SIZE_block[2]
        else:
            if hasattr(button, "level"):
                return self.w.r_width_input(self) - SIZE_widget[0] // 2
            else:
                return self.w.r_width_input(self) - SIZE_widget[0] // 2 - SIZE_block[1] - SIZE_block[2]
        #|

    def inside(self, mouse): return self.box_block.inbox(mouse)
    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        if self.button0 is not None: self.button0.outside_evt()
        self.button_fold.outside_evt()
        for e in self.items: e.outside_evt()
        #|

    def modal(self):
        if self.button0 is not None and self.button0.inside(MOUSE): e = self.button0
        elif self.button_fold.inside(MOUSE): e = self.button_fold
        elif self.is_fold is False:
            e = None
            for o in self.items:
                if o.inside(MOUSE):
                    e = o
                    break
        else:
            e = None

        if e is None:
            if self.focus_element is not None:
                Admin.REDRAW()
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                Admin.REDRAW()
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['fold_recursive_toggle']():
            self.evt_fold_toggle(recursive=True)
            return True
        if TRIGGER['fold_toggle']():
            self.evt_fold_toggle()
            return True
        return False
        #|

    def to_modal_rm(self):

        # /* 0block_BlockUtil_to_modal_rm
        items = []
        if hasattr(self.w, "evt_fold_all_toggle"):
            items.append(("Unfold All", self.w.evt_unfold_all))
            items.append(("Fold All", self.w.evt_fold_all))
            items.append(("fold_all_toggle", self.w.evt_fold_all_toggle))
        elif hasattr(self, "area") and hasattr(self.area, "evt_fold_all_toggle"):
            area = self.area
            items.append(("Unfold All", area.evt_unfold_all))
            items.append(("Fold All", area.evt_fold_all))
            items.append(("fold_all_toggle", area.evt_fold_all_toggle))

        items.append(("Unfold Recursive", lambda: self.evt_unfold(recursive=True)))
        items.append(("Fold Recursive", lambda: self.evt_fold(recursive=True)))
        items.append(("Unfold", self.evt_unfold))
        items.append(("Fold", self.evt_fold))
        items.append(("fold_recursive_toggle", lambda: self.evt_fold_toggle(recursive=True)))
        items.append(("fold_toggle", self.evt_fold_toggle))

        if hasattr(self.w, "w") and hasattr(self.w.w, "evt_undo"):
            items.append(("redo", self.w.w.evt_redo))
            items.append(("undo", self.w.w.evt_undo))

        DropDownRMKeymap(self, MOUSE, items)
        # */

    def i_dxy(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        self.box_guideline.dxy_upd(dx, dy)
        self.box_title.dxy_upd(dx, dy)
        self.button_fold.box_button.dxy_upd(dx, dy)
        if self.button0 is not None: self.button0.dxy(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy

        for e in self.items: e.dxy(dx, dy)
        #|
    def i_dxy_fold(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        self.box_title.dxy_upd(dx, dy)
        self.button_fold.box_button.dxy_upd(dx, dy)
        if self.button0 is not None: self.button0.dxy(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy
        #|
    def i_draw_box(self):
        self.box_block.bind_draw()
        self.box_guideline.bind_draw()
        self.box_title.bind_draw()
        self.button_fold.box_button.bind_draw()
        if self.button0 is not None: self.button0.draw_box()
        for e in self.items: e.draw_box()
        #|
    def i_draw_box_fold(self):
        self.box_block.bind_draw()
        self.box_title.bind_draw()
        self.button_fold.box_button.bind_draw()
        if self.button0 is not None: self.button0.draw_box()
        #|
    def i_draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *COL_block_fg)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        if self.button0 is not None: self.button0.draw_blf()

        for e in self.items: e.draw_blf()
        #|
    def i_draw_blf_fold(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *COL_block_fg)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        if self.button0 is not None: self.button0.draw_blf()
        #|

    def evt_unfold(self, kill_evt=True, recursive=False):

        if kill_evt: kill_evt_except()
        # Admin.REDRAW()
        self.init_unfold(recursive=recursive)
        e = self.box_block
        self.init_bat(e.L, e.R, e.T)

        self.area.redraw_from_headkey()
        if hasattr(self.area, "upd_data_callback"): self.area.upd_data_callback()
        _last_bool_state[0] = False
        self.area.upd_data()
        #|
    def evt_fold(self, kill_evt=True, recursive=False):

        if kill_evt: kill_evt_except()
        # Admin.REDRAW()
        self.init_fold(recursive=recursive)
        e = self.box_block
        self.init_bat(e.L, e.R, e.T)

        self.area.redraw_from_headkey()
        if hasattr(self.area, "upd_data_callback"): self.area.upd_data_callback()
        _last_bool_state[0] = True
        self.area.upd_data()
        #|
    def evt_fold_toggle(self, kill_evt=True, recursive=False):
        # Admin.REDRAW()
        if self.is_fold:
            self.evt_unfold(kill_evt=kill_evt, recursive=recursive)
        else:
            self.evt_fold(kill_evt=kill_evt, recursive=recursive)
        #|

    def upd_data(self):
        if self.button0 is not None: self.button0.upd_data()
        for e in self.items: e.upd_data()
        #|
    #|
    #|
class BlockUtilHeavy(BlockUtil):
    __slots__ = (
        'headkey',
        'endkey',
        'draw_range')

    def __init__(self, w, items, button0=None, title=""):
        super().__init__(w, items, button0, title)
        self.headkey = -1
        self.endkey = -1
        self.draw_range = range(0)
        #|

    def i_init_bat(self, L, R, T):
        # guideline_width = SIZE_block[7]
        block_gap = SIZE_block[0]
        button_gap = SIZE_button[1]
        h = SIZE_widget[0]

        if self.level == 0: pass
        else:
            L += h // 2

        iconL = L + SIZE_block[1]
        iconR = iconL + h
        T0 = T - SIZE_block[8]
        iconT = T0 - SIZE_border[3]
        iconB = iconT - h

        if self.use_anim_slot is False:
            R0 = R - SIZE_block[2] + SIZE_border[3] + h
        else:
            R0 = R - SIZE_block[2]

        self.button_fold.box_button.LRBT_upd(iconL, iconR, iconB, iconT)
        self.blf_title.x = iconR + SIZE_border[3]
        self.blf_title.y = iconT - D_SIZE['font_main_dT']

        B = ((T0 - D_SIZE['widget_full_h'])  if self.button0 is None else self.button0.init_bat(iconR, R0, T0)) - SIZE_block[9]
        self.box_title.LRBT_upd(L, R, B, T)

        T1 = B - SIZE_block[4]

        if self.items:
            scissor = self.area.scissor
            limB = scissor.y
            limT = limB + scissor.h

            headkey = -1
            endkey = -1
            is_done = False

            for r, e in enumerate(self.items):
                if hasattr(e, "level"):
                    T1 = e.init_bat(L, R, T1) - block_gap
                else:
                    T1 = e.init_bat(iconL, R0, T1) - button_gap

                if is_done is False:
                    if headkey == -1:
                        if T1 >= limT: continue
                        if T1 >= limB:
                            headkey = r
                        else:
                            headkey = r
                            endkey = r
                            is_done = True
                    else:
                        if T1 < limB:
                            endkey = r
                            is_done = True

            if endkey == -1:
                endkey = len(self.items) - 1

            if headkey == -1:
                self.headkey = 0
                self.endkey = 0
                self.draw_range = range(1)
            elif endkey < headkey:
                self.headkey = headkey
                self.endkey = headkey
                self.draw_range = range(headkey, headkey + 1)
            else:
                self.headkey = headkey
                self.endkey = endkey
                self.draw_range = range(headkey, endkey + 1)

            T1 += block_gap  if hasattr(self.items[-1], "level") else button_gap
        else:
            self.headkey = -1
            self.endkey = -1
            self.draw_range = range(0)

        T1 -= SIZE_block[3]
        self.box_block.LRBT_upd(L, R, T1, T)
        self.box_guideline.LRBT_upd(iconL, iconL + SIZE_block[7], T1, B)
        return T1
        #|

    def i_dxy(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        self.box_guideline.dxy_upd(dx, dy)
        self.box_title.dxy_upd(dx, dy)
        self.button_fold.box_button.dxy_upd(dx, dy)
        if self.button0 is not None: self.button0.dxy(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy

        scissor = self.area.scissor
        limB = scissor.y
        limT = limB + scissor.h
        items = self.items

        for r in self.draw_range:
            items[r].dxy(dx, dy)

        if items:
            if dy < 0:
                headkey = self.headkey
                e = items[headkey]
                if hasattr(e, 'box_block'):
                    T = e.box_block.T
                else:
                    if hasattr(e, 'r_T'):
                        T = e.r_T()
                    else:
                        T = e.box_button[0].T  if isinstance(e.box_button, list) else e.box_button.T

                if T < limT:
                    if headkey != 0:
                        L = self.box_block.L
                        R = self.box_block.R
                        h = SIZE_widget[0]
                        block_gap = SIZE_block[0]
                        button_gap = SIZE_button[1]

                        iconL = L + SIZE_block[1]
                        if self.use_anim_slot is False:
                            R0 = R - SIZE_block[2] + SIZE_border[3] + h
                        else:
                            R0 = R - SIZE_block[2]

                        width0 = R - L
                        width1 = R0 - iconL

                        while headkey > 0:
                            headkey -= 1
                            e = items[headkey]
                            if hasattr(e, "level"):
                                T += e.r_height(width0) + block_gap
                                e.init_bat(L, R, T)
                            else:
                                T += e.r_height(width1) + button_gap
                                e.init_bat(iconL, R0, T)

                            e.upd_data()

                            if T >= limT: break

                        self.headkey = headkey

                        for r in range(self.endkey, headkey, -1):
                            e = items[r]
                            if (e.box_block.T  if hasattr(e, 'box_block') else (
                                e.box_button[0].T  if isinstance(e.box_button, list) else e.box_button.T)) < limB: continue

                            self.endkey = r
                            break

                        self.draw_range = range(headkey, self.endkey + 1)
            else:
                endkey = self.endkey
                e = items[endkey]
                if hasattr(e, 'box_block'):
                    B = e.box_block.B
                else:
                    if hasattr(e, 'r_B'):
                        B = e.r_B()
                    else:
                        B = e.box_button[-1].B  if isinstance(e.box_button, list) else e.box_button.B

                if B > limB:
                    maxkey = len(items) - 1
                    if endkey != maxkey:
                        L = self.box_block.L
                        R = self.box_block.R
                        h = SIZE_widget[0]
                        block_gap = SIZE_block[0]
                        button_gap = SIZE_button[1]

                        iconL = L + SIZE_block[1]
                        if self.use_anim_slot is False:
                            R0 = R - SIZE_block[2] + SIZE_border[3] + h
                        else:
                            R0 = R - SIZE_block[2]

                        B -= (block_gap  if hasattr(e, "level") else button_gap)

                        while endkey < maxkey:
                            endkey += 1
                            e = items[endkey]
                            if hasattr(e, "level"):
                                B = e.init_bat(L, R, B) - block_gap
                            else:
                                B = e.init_bat(iconL, R0, B) - button_gap

                            e.upd_data()

                            if B <= limB: break

                        self.endkey = endkey

                        for r in range(self.headkey, endkey + 1):
                            e = items[r]
                            if (e.box_block.B  if hasattr(e, 'box_block') else (
                                e.box_button[-1].B  if isinstance(e.box_button, list) else e.box_button.B)) > limT: continue

                            self.headkey = r
                            break

                        self.draw_range = range(self.headkey, endkey + 1)

        #|

    def i_draw_box(self):
        self.box_block.bind_draw()
        self.box_guideline.bind_draw()
        self.box_title.bind_draw()
        self.button_fold.box_button.bind_draw()
        if self.button0 is not None: self.button0.draw_box()

        items = self.items
        for r in self.draw_range: items[r].draw_box()
        #|
    def i_draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *COL_block_fg)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        if self.button0 is not None: self.button0.draw_blf()

        items = self.items
        for r in self.draw_range: items[r].draw_blf()
        #|

    def upd_data(self):
        if self.button0 is not None: self.button0.upd_data()

        items = self.items
        for r in self.draw_range: items[r].upd_data()
        #|
    #|
    #|
class BlockUtils(BlockUtil):
    __slots__ = 'buttons'

    def __init__(self, w, items, buttons=None, title=""):
        self.w = w
        self.use_anim_slot = True

        if hasattr(w, "level"):
            self.level = w.level + 1
            self.area = w.area

            if hasattr(w, "box_block"):
                if isinstance(w.box_block, GpuBox_block):
                    self.box_block = GpuBox(COL_block_even)
                    self.box_title = GpuBox(COL_block_title_even)
                    self.box_guideline = GpuBox(COL_block_guideline1)
                else:
                    self.box_block = GpuBox_block()
                    self.box_title = GpuBox(COL_block_title)
                    self.box_guideline = GpuBox(COL_block_guideline0)
            else:
                if self.level % 2 == 0:
                    self.box_block = GpuBox_block()
                    self.box_title = GpuBox(COL_block_title)
                    self.box_guideline = GpuBox(COL_block_guideline0)
                else:
                    self.box_block = GpuBox(COL_block_even)
                    self.box_title = GpuBox(COL_block_title_even)
                    self.box_guideline = GpuBox(COL_block_guideline1)
        else:
            self.level = 0
            self.area = w
            self.box_block = GpuBox_block()
            self.box_title = GpuBox(COL_block_title)
            self.box_guideline = GpuBox(COL_block_guideline0)

        self.buttons = []  if buttons is None else buttons
        self.blf_title = Blf(title)
        self.button_fold = ButtonFold(self)
        self.init_fold()  if BlockUtil.DEFAULT_FOLD_STATE else self.init_unfold()
        self.items = items
        #|

    def i_init_bat(self, L, R, T):
        # guideline_width = SIZE_block[7]
        block_gap = SIZE_block[0]
        button_gap = SIZE_button[1]
        h = SIZE_widget[0]

        if self.level == 0: pass
        else:
            L += h // 2

        iconL = L + SIZE_block[1]
        iconR = iconL + h
        T0 = T - SIZE_block[8]
        iconT = T0 - SIZE_border[3]
        iconB = iconT - h

        if self.use_anim_slot is False:
            R0 = R - SIZE_block[2] + SIZE_border[3] + h
        else:
            R0 = R - SIZE_block[2]

        self.button_fold.box_button.LRBT_upd(iconL, iconR, iconB, iconT)
        self.blf_title.x = iconR + SIZE_border[3]
        self.blf_title.y = iconT - D_SIZE['font_main_dT']

        if self.buttons:
            for e in self.buttons:
                T0 = e.init_bat(iconR, R0, T0) - button_gap

            B = T0 + button_gap - SIZE_block[9]
        else:
            B = T0 - D_SIZE['widget_full_h'] - SIZE_block[9]

        self.box_title.LRBT_upd(L, R, B, T)

        T1 = B - SIZE_block[4]

        if self.items:
            for e in self.items:
                if hasattr(e, "level"):
                    T1 = e.init_bat(L, R, T1) - block_gap
                else:
                    T1 = e.init_bat(iconL, R0, T1) - button_gap

            T1 += block_gap  if hasattr(self.items[-1], "level") else button_gap

        T1 -= SIZE_block[3]
        self.box_block.LRBT_upd(L, R, T1, T)
        self.box_guideline.LRBT_upd(iconL, iconL + SIZE_block[7], T1, B)
        return T1
        #|
    def i_init_bat_fold(self, L, R, T):
        block_gap = SIZE_block[0]
        button_gap = SIZE_button[1]
        h = SIZE_widget[0]

        if self.level == 0: pass
        else:
            L += h // 2

        iconL = L + SIZE_block[1]
        iconR = iconL + h
        T0 = T - SIZE_block[8]
        iconT = T0 - SIZE_border[3]
        iconB = iconT - h

        if self.use_anim_slot is False:
            R0 = R - SIZE_block[2] + SIZE_border[3] + h
        else:
            R0 = R - SIZE_block[2]

        self.button_fold.box_button.LRBT_upd(iconL, iconR, iconB, iconT)
        self.blf_title.x = iconR + SIZE_border[3]
        self.blf_title.y = iconT - D_SIZE['font_main_dT']

        if self.buttons:
            for e in self.buttons:
                T0 = e.init_bat(iconR, R0, T0) - button_gap

            B = T0 + button_gap - SIZE_block[9]
        else:
            B = T0 - D_SIZE['widget_full_h'] - SIZE_block[9]

        self.box_title.LRBT_upd(L, R, B, T)
        self.box_block.LRBT_upd(L, R, B, T)
        return B
        #|
    def i_r_height(self, width):
        block_gap = SIZE_block[0]
        button_gap = SIZE_button[1]
        width_button = width - SIZE_block[1] - SIZE_block[2]

        if self.items:
            items_h = sum(
                (e.r_height(width) + block_gap)  if hasattr(e, "level") else (e.r_height(width_button) + button_gap)
                for e in self.items
            )
            items_h -= block_gap  if hasattr(self.items[-1], "level") else button_gap
        else:
            items_h = 0

        if self.buttons:
            width_button -= SIZE_widget[0]
            buttons_h = sum(
                e.r_height(width_button) + button_gap
                for e in self.buttons
            )
            buttons_h -= button_gap
        else:
            buttons_h = D_SIZE['widget_full_h']

        return items_h + SIZE_block[8] + buttons_h + SIZE_block[9] + SIZE_block[4] + SIZE_block[3]
        #|
    def i_r_height_fold(self, width):
        block_gap = SIZE_block[0]
        button_gap = SIZE_button[1]

        if self.buttons:
            width_button = width - SIZE_block[1] - SIZE_block[2] - SIZE_widget[0]
            buttons_h = sum(
                e.r_height(width_button) + button_gap
                for e in self.buttons
            )
            buttons_h -= button_gap
        else:
            buttons_h = D_SIZE['widget_full_h']

        return SIZE_block[8] + buttons_h + SIZE_block[9]
        #|

    def outside_evt(self):
        for e in self.buttons: e.outside_evt()
        self.button_fold.outside_evt()
        for e in self.items: e.outside_evt()
        #|

    def modal(self):
        if self.button_fold.inside(MOUSE): e = self.button_fold
        else:
            e = None
            for o in self.buttons:
                if o.inside(MOUSE):
                    e = o
                    break

            if self.is_fold is False:
                if e is None:
                    for o in self.items:
                        if o.inside(MOUSE):
                            e = o
                            break

        if e is None:
            if self.focus_element is not None:
                Admin.REDRAW()
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                Admin.REDRAW()
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['fold_toggle']():
            self.evt_fold_toggle()
            return True
        return False
        #|

    def i_dxy(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        self.box_guideline.dxy_upd(dx, dy)
        self.box_title.dxy_upd(dx, dy)
        self.button_fold.box_button.dxy_upd(dx, dy)
        for e in self.buttons: e.dxy(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy

        for e in self.items: e.dxy(dx, dy)
        #|
    def i_dxy_fold(self, dx, dy):
        self.box_block.dxy_upd(dx, dy)
        self.box_title.dxy_upd(dx, dy)
        self.button_fold.box_button.dxy_upd(dx, dy)
        for e in self.buttons: e.dxy(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy
        #|
    def i_draw_box(self):
        self.box_block.bind_draw()
        self.box_guideline.bind_draw()
        self.box_title.bind_draw()
        self.button_fold.box_button.bind_draw()
        for e in self.buttons: e.draw_box()
        for e in self.items: e.draw_box()
        #|
    def i_draw_box_fold(self):
        self.box_block.bind_draw()
        self.box_title.bind_draw()
        self.button_fold.box_button.bind_draw()
        for e in self.buttons: e.draw_box()
        #|
    def i_draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *COL_block_fg)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        for e in self.buttons: e.draw_blf()

        for e in self.items: e.draw_blf()
        #|
    def i_draw_blf_fold(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *COL_block_fg)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        for e in self.buttons: e.draw_blf()
        #|

    def upd_data(self):
        for e in self.buttons: e.upd_data()
        for e in self.items: e.upd_data()
        #|
    #|
    #|


class BlockActiveObjectSync:
    __slots__ = (
        'w',
        'items',
        'button0',
        'button1',
        'blf_text',
        'box_block',
        'focus_element',
        'active_object_name',
        'r_object_name',
        'r_object',
        'r_is_sync',
        'set_active_object',
        'set_sync')

    def __init__(self, w, r_object_name, r_object, r_is_sync, set_active_object, set_sync):
        self.w = w
        self.box_block = GpuBox_block()
        self.button0 = ButtonFnImgHover(self, RNA_active_object, self.bufn_object, "GpuImg_OBJECT_DATA")
        self.button1 = ButtonFnImgHover(self, RNA_active_object_sync, self.bufn_object_sync,
            "GpuImg_pin", "GpuImg_unpin")
        self.blf_text = BlfClipColor(color=COL_block_fg)
        self.active_object_name = ""
        self.r_object_name = r_object_name
        self.r_object = r_object
        self.r_is_sync = r_is_sync
        self.set_active_object = set_active_object
        self.set_sync = set_sync
        #|

    def init_bat(self, L, R, T):
        R0 = L + SIZE_widget[0]
        B = self.button0.init_bat(L, R0, T)
        x = R0 + D_SIZE['font_main_dx']
        L0 = R - SIZE_widget[0]
        self.button1.init_bat(L0, R, T)
        self.blf_text.x = x
        self.blf_text.y = B + D_SIZE['font_main_dy']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        self.blf_text.text = r_blf_clipping_end(
            self.blf_text.text, x, L0 - D_SIZE['font_main_dx'])
        self.box_block.LRBT(L, R, B, T)
        return B
        #|
    def r_height(self, width): return SIZE_widget[0]

    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        self.button0.outside_evt()
        self.button1.outside_evt()
        #|

    def modal(self):
        if self.button0.inside(MOUSE): e = self.button0
        elif self.button1.inside(MOUSE): e = self.button1
        else: e = None

        if e is None:
            if self.focus_element is not None:
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['rename']():
            self.evt_rename()
            return True
        return False
        #|

    def to_modal_rm(self):

        items = [
            ("rename", self.evt_rename),
        ]
        DropDownRMKeymap(self, MOUSE, items)
        #|

    def bufn_object(self):

        def write_text(tx, best_item, use_text_output):
            if use_text_output or best_item == None:
                # <<< 1copy (bl_objects_find,, ${'_i_':'i', '_name_':'str(tx)'}$)
                i = bpy.context.view_layer.objects.find(str(tx))
                # >>>
                if i == -1: return
                self.set_active_object(object=(
                    # <<< 1copy (bl_objects,, $$)
                    bpy.context.view_layer.objects
                    # >>>
                )[i])
            else:
                self.set_active_object(object=best_item)

        widget_rim = SIZE_border[3]
        L, R, B, T = self.box_block.r_LRBT()
        title_h = SIZE_title[1] + widget_rim
        T += widget_rim - title_h
        B -= widget_rim - title_h
        DropDownEnum(self, (L, R, B, T), "Object", r_all_objects(),
            input_text="", fixed_width=True, write_text=write_text,
            get_icon=geticon_Object, get_info=getinfo_Object)
        #|
    def bufn_object_sync(self):
        Admin.REDRAW()
        kill_evt_except()
        self.set_sync(not self.button1.is_dark())
        #|
    @ catchBug
    def evt_rename(self):

        ob = self.r_object()
        DropDownEnumRename(None, self.box_block.r_LRBT(), ob, ob)
        #|

    def dxy(self, dx, dy):
        self.box_block.dxy(dx, dy)
        self.button0.dxy(dx, dy)
        self.button1.dxy(dx, dy)
        self.blf_text.x += dx
        self.blf_text.y += dy
        #|
    def draw_box(self):
        self.button0.draw_box()
        self.button1.draw_box()
        #|
    def draw_blf(self):
        e = self.blf_text
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        self.button1.dark()  if self.r_is_sync() else self.button1.light()

        if self.active_object_name == self.r_object_name(): return


        self.active_object_name = self.blf_text.unclip_text = self.blf_text.text = self.r_object_name()
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        self.blf_text.text = r_blf_clipping_end(
            self.blf_text.text, self.blf_text.x, self.button1.box_button.L - D_SIZE['font_main_dx'])
        #|
    #|
    #|
class BlockActiveModifierSync:
    __slots__ = (
        'w',
        'items',
        'button0',
        'button1',
        'button2',
        'button3',
        'blf_text',
        'box_block',
        'focus_element',
        'active_modifier_name',
        'r_modifier_name',
        'r_modifier',
        'r_is_sync',
        'set_active_modifier',
        'set_sync')

    def __init__(self, w, r_modifier_name, r_modifier, r_is_sync, set_active_modifier, set_sync):
        self.w = w
        self.box_block = GpuBox_block()
        self.button0 = ButtonFnImgHover(self, RNA_active_modifier, self.bufn_modifier, "GpuImg_MODIFIER")
        self.button1 = ButtonFnImgHover(self, RNA_active_modifier_sync, self.bufn_modifier_sync,
            "GpuImg_pin", "GpuImg_unpin")
        self.button2 = ButtonFnImgHover(self, RNA_remove_modifier, self.bufn_remove, "GpuImg_REMOVE")
        self.button3 = ButtonFnImgHover(self, RNA_new_modifier, self.bufn_new_modifier, "GpuImg_ADD")
        self.blf_text = BlfClipColor(color=COL_block_fg)
        self.active_modifier_name = ""
        self.r_modifier_name = r_modifier_name
        self.r_modifier = r_modifier
        self.r_is_sync = r_is_sync
        self.set_active_modifier = set_active_modifier
        self.set_sync = set_sync
        #|

    def init_bat(self, L, R, T):
        h = SIZE_widget[0]
        R0 = L + h
        B = self.button0.init_bat(L, R0, T)
        x = R0 + D_SIZE['font_main_dx']
        L0 = R - h
        self.button1.init_bat(L0, R, T)
        R1 = L0 - h // 2
        L1 = R1 - h
        self.button2.init_bat(L1, R1, T)
        R1 = L1
        L1 -= h
        self.button3.init_bat(L1, R1, T)

        self.blf_text.x = x
        self.blf_text.y = B + D_SIZE['font_main_dy']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        self.blf_text.text = r_blf_clipping_end(
            self.blf_text.text, x, L1 - D_SIZE['font_main_dx'])
        self.box_block.LRBT(L, R, B, T)
        return B
        #|
    def r_height(self, width): return SIZE_widget[0]

    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        self.button0.outside_evt()
        self.button1.outside_evt()
        self.button2.outside_evt()
        self.button3.outside_evt()
        #|

    def modal(self):
        if self.button0.inside(MOUSE): e = self.button0
        elif self.button1.inside(MOUSE): e = self.button1
        elif self.button2.inside(MOUSE): e = self.button2
        elif self.button3.inside(MOUSE): e = self.button3
        else: e = None

        if e is None:
            if self.focus_element is not None:
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['rename']():
            self.evt_rename()
            return True
        return False
        #|

    def to_modal_rm(self):

        items = [
            ("rename", self.evt_rename),
        ]
        DropDownRMKeymap(self, MOUSE, items)
        #|

    def bufn_modifier(self):

        oj = self.w.w.active_object
        if not hasattr(oj, "modifiers"): return
        if not oj.modifiers: return

        def write_text(tx, best_item, use_text_output):
            if use_text_output or best_item == None:
                i = oj.modifiers.find(str(tx))
                if i == -1: return
                self.set_active_modifier(object=oj.modifiers[i])
            else:
                self.set_active_modifier(object=best_item)

        widget_rim = SIZE_border[3]
        L, R, B, T = self.box_block.r_LRBT()
        title_h = SIZE_title[1] + widget_rim
        T += widget_rim - title_h
        B -= widget_rim - title_h
        DropDownEnum(self, (L, R, B, T), "Modifier", tuple(oj.modifiers),
            input_text="", fixed_width=True, write_text=write_text,
            get_icon=geticon_Modifier, get_info=None)
        #|
    def bufn_modifier_sync(self):
        Admin.REDRAW()
        kill_evt_except()
        self.set_sync(not self.button1.is_dark())
        #|
    def bufn_new_modifier(self):

        oj = self.w.w.active_object
        if not hasattr(oj, "modifiers"): return

        s = r_library_or_override_message(oj)
        if s:
            report(s)
            return

        box_button = self.button3.box_button
        DropDownNewModifier(self, (box_button.L, box_button.T), oj)
        #|
    def bufn_remove(self, override=None):

        self.w.w.area_mds.evt_del(override=override)
        #|
    @ catchBug
    def evt_rename(self):

        DropDownEnumRename(None, self.box_block.r_LRBT(), self.w.w.active_object, self.r_modifier())
        #|

    def dxy(self, dx, dy):
        self.box_block.dxy(dx, dy)
        self.button0.dxy(dx, dy)
        self.button1.dxy(dx, dy)
        self.button2.dxy(dx, dy)
        self.button3.dxy(dx, dy)
        self.blf_text.x += dx
        self.blf_text.y += dy
        #|
    def draw_box(self):
        self.button0.draw_box()
        self.button1.draw_box()
        self.button2.draw_box()
        self.button3.draw_box()
        #|
    def draw_blf(self):
        e = self.blf_text
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        self.button1.dark()  if self.r_is_sync() else self.button1.light()

        if self.active_modifier_name == self.r_modifier_name(): return


        self.active_modifier_name = self.blf_text.unclip_text = self.blf_text.text = self.r_modifier_name()
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        self.blf_text.text = r_blf_clipping_end(
            self.blf_text.text, self.blf_text.x, self.button3.box_button.L - D_SIZE['font_main_dx'])
        #|
    #|
    #|
class BlockActiveVar:
    __slots__ = (
        'w',
        'items',
        'button0',
        'button1',
        'button2',
        'blf_text',
        'box_block',
        'focus_element',
        'active_var_name',
        'r_var_name',
        'r_var',
        'set_active_var')

    def __init__(self, w, r_var_name, r_var, set_active_var):
        self.w = w
        self.box_block = GpuBox_block()
        self.button0 = ButtonFnImgHover(self, RNA_active_item, self.bufn_var, "GpuImg_VARIABLE")
        self.button1 = ButtonFnImgHover(self, RNA_remove_item, self.bufn_remove, "GpuImg_REMOVE")
        self.button2 = ButtonFnImgHover(self, RNA_new_item, self.bufn_new_var, "GpuImg_ADD")
        self.blf_text = BlfClipColor(color=COL_block_fg)
        self.active_var_name = ""
        self.r_var_name = r_var_name
        self.r_var = r_var
        self.set_active_var = set_active_var
        #|

    def init_bat(self, L, R, T):
        h = SIZE_widget[0]
        R0 = L + h
        B = self.button0.init_bat(L, R0, T)
        x = R0 + D_SIZE['font_main_dx']
        L1 = R - h
        self.button1.init_bat(L1, R, T)
        R1 = L1
        L1 -= h
        self.button2.init_bat(L1, R1, T)

        self.blf_text.x = x
        self.blf_text.y = B + D_SIZE['font_main_dy']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        self.blf_text.text = r_blf_clipping_end(
            self.blf_text.text, x, L1 - D_SIZE['font_main_dx'])
        self.box_block.LRBT(L, R, B, T)
        return B
        #|
    def r_height(self, width): return SIZE_widget[0]

    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        self.button0.outside_evt()
        self.button1.outside_evt()
        self.button2.outside_evt()
        #|

    def modal(self):
        if self.button0.inside(MOUSE): e = self.button0
        elif self.button1.inside(MOUSE): e = self.button1
        elif self.button2.inside(MOUSE): e = self.button2
        else: e = None

        if e is None:
            if self.focus_element is not None:
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['rename']():
            self.evt_rename()
            return True
        return False
        #|

    def to_modal_rm(self):

        items = [
            ("rename", self.evt_rename),
        ]
        DropDownRMKeymap(self, MOUSE, items)
        #|

    def bufn_var(self):

        w = self.w.w
        props = w.props
        fc = w.bars["driver"].button0.check(props.id)
        if not hasattr(fc, "driver"): return
        dr = fc.driver
        if not hasattr(dr, "variables"): return
        if not dr.variables: return

        def write_text(tx, best_item, use_text_output):
            if use_text_output or best_item == None:
                i = dr.variables.find(str(tx))
                if i == -1: return
                self.set_active_var(object=dr.variables[i])
            else:
                self.set_active_var(object=best_item)

        widget_rim = SIZE_border[3]
        L, R, B, T = self.box_block.r_LRBT()
        title_h = SIZE_title[1] + widget_rim
        T += widget_rim - title_h
        B -= widget_rim - title_h
        DropDownEnum(self, (L, R, B, T), "Variable", tuple(dr.variables),
            input_text="", fixed_width=True, write_text=write_text,
            get_icon=geticon_DriverVar, get_info=None)
        #|
    def bufn_remove(self, override=None):

        self.w.w.area_vars.evt_del(override=override)
        #|
    def bufn_new_var(self):

        w = self.w.w
        props = w.props
        fc = w.bars["driver"].button0.check(props.id)
        if not hasattr(fc, "driver"): return
        dr = fc.driver
        if not hasattr(dr, "variables"): return
        dr.variables.new()
        update_scene_push("Add driver variable")
        #|
    @ catchBug
    def evt_rename(self):

        w = self.w.w
        ob = w.active_object
        filt = w.area_vars.filt
        active_index = filt.active_index
        @ catch
        def callback():
            filt.set_active_index(active_index, callback=True)

        DropDownEnumRename(None, self.box_block.r_LRBT(), w.props.id, w.active_var,
            items = ob.variables,
            write_callback = callback)
        #|

    def dxy(self, dx, dy):
        self.box_block.dxy(dx, dy)
        self.button0.dxy(dx, dy)
        self.button1.dxy(dx, dy)
        self.button2.dxy(dx, dy)
        self.blf_text.x += dx
        self.blf_text.y += dy
        #|
    def draw_box(self):
        self.button0.draw_box()
        self.button1.draw_box()
        self.button2.draw_box()
        #|
    def draw_blf(self):
        e = self.blf_text
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        if self.active_var_name == self.r_var_name(): return


        self.active_var_name = self.blf_text.unclip_text = self.blf_text.text = self.r_var_name()
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        self.blf_text.text = r_blf_clipping_end(
            self.blf_text.text, self.blf_text.x, self.button2.box_button.L - D_SIZE['font_main_dx'])
        #|
    #|
    #|

#_c4#_c4#_c4#_c4

class ButtonGroup:
    __slots__ = (
        'w',
        'button0',
        'blf_title',
        'inside',
        'inside_evt',
        'outside_evt',
        'evtkill',
        'r_button_width',
        'r_offset',
        'offset_data')

    def __init__(self, w, button0, title=None):
        self.w = w
        self.button0 = button0
        button0.w = self
        self.blf_title = BlfClipColor(unclip_text=button0.rna.name  if title is None else title,
            color=COL_block_fg)
        self.inside = button0.inside
        self.inside_evt = button0.inside_evt
        self.outside_evt = button0.outside_evt
        #|

    def init_bat(self, LL, RR, TT):
        L = RR - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        if self.button0.rna.type == "BOOLEAN":
            self.evtkill = False
            self.button0.init_bat(L, L + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            B = TT - D_SIZE['widget_full_h']
        else:
            B = self.button0.init_bat(L, RR, TT)

        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        if hasattr(self.button0, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            if hasattr(self.button0.blf_subtype, "__len__"):
                R0 = L - D_SIZE['font_main_title_offset'] - D_SIZE['font_label_dx'] - round(
                    max(blfDimen(FONT0, o.text)[0]  for o in self.button0.blf_subtype))
            else:
                R0 = L - D_SIZE['font_main_title_offset'] - D_SIZE['font_label_dx'] - round(
                    blfDimen(FONT0, self.button0.blf_subtype.text)[0])
        else:
            R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])
        if hasattr(self, "offset_data"):
            e = self.button0.box_button
            self.offset_data = {
                "dL": LL - e.L,
                "dR": RR - e.R,
                "dT": TT - e.T
            }
        return B
        #|
    def set_title_with_check(self, s): # need offset_data
        if self.blf_title.unclip_text == s: return False


        self.blf_title.unclip_text = s
        e = self.offset_data
        o = self.button0.box_button
        self.init_bat(o.L + e["dL"], o.R + e["dR"], o.T + e["dT"])
        return True
        #|
    def r_height(self, width):
        return self.button0.r_height(width)
        #|

    def is_dark(self):
        return True  if self.button0.is_dark() else False
        #|
    def dark(self):
        self.button0.dark()
        self.blf_title.color = COL_block_fg_ignore
        #|
    def light(self):
        self.button0.light()
        self.blf_title.color = COL_block_fg
        #|

    def modal(self): return self.button0.modal()

    def dxy(self, dx, dy):
        self.button0.dxy(dx, dy)
        self.blf_title.x += dx
        self.blf_title.y += dy
        #|
    def draw_box(self):
        self.button0.draw_box()
        #|
    def draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        self.button0.draw_blf()
        #|

    def upd_data(self): return self.button0.upd_data()
    #|
    #|
class ButtonGroupTitle:
    __slots__ = (
        'w',
        'blf_title')

    def __init__(self, w, title=""):
        self.w = w
        self.blf_title = BlfClipColor(unclip_text=title, color=COL_block_fg)
        #|

    def init_bat(self, LL, RR, TT):
        blfSize(FONT0, D_SIZE['font_main'])
        e = self.blf_title
        e.text = e.unclip_text
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        e.x = LL + D_SIZE['font_main_dx']
        return TT - D_SIZE['widget_full_h']
        #|
    def r_height(self, width): return D_SIZE['widget_full_h']
    def is_dark(self): return False
    def dark(self): pass
    def light(self): pass
    def inside(self, mouse): return False
    def inside_evt(self): pass
    def outside_evt(self): pass

    def modal(self): return False

    def dxy(self, dx, dy):
        self.blf_title.x += dx
        self.blf_title.y += dy
        #|
    def draw_box(self): pass
    def draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self): pass
    #|
    #|
class ButtonGroupAlignL(                # ButtonGroup                                           
    ButtonGroup):
    __slots__ = ()

    def init_bat(self, LL, RR, TT):
        L = RR - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        if self.button0.rna.type == "BOOLEAN":
            self.button0.init_bat(L, L + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            B = TT - D_SIZE['widget_full_h']
        else:
            B = self.button0.init_bat(L, RR, TT)

        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        if hasattr(self.button0.box_button, 'R'):
            e.x = (self.button0.box_button[0].R  if isinstance(self.button0.box_button, list) else self.button0.box_button.R) + D_SIZE['font_main_title_offset_R']
        else:
            e.x = self.button0.box_button[-1].R + D_SIZE['font_main_title_offset_R']
        e.text = e.unclip_text
        return B
        #|
    #|
    #|
class ButtonGroupBoolT(                 # ButtonGroup                                           
    ButtonGroup):
    __slots__ = ()

    def init_bat(self, LL, RR, TT):
        LL += D_SIZE['font_main_dx']
        if hasattr(self, "r_offset"): LL += self.r_offset()

        if self.button0.rna.type == "BOOLEAN":
            self.button0.init_bat(LL, LL + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            B = TT - D_SIZE['widget_full_h']
        else:
            B = self.button0.init_bat(LL, RR, TT)

        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        if hasattr(self.button0.box_button, 'R'):
            e.x = (self.button0.box_button[0].R  if isinstance(self.button0.box_button, list) else self.button0.box_button.R) + D_SIZE['font_main_title_offset_R']
        else:
            e.x = self.button0.box_button[-1].R + D_SIZE['font_main_title_offset_R']
        e.text = e.unclip_text
        return B
        #|
    #|
    #|
class ButtonGroupAlignTitleLeft(        # ButtonGroup                                           
    ButtonGroup):
    __slots__ = "aligntitle"

    def init_bat(self, LL, RR, TT):
        blfSize(FONT0, D_SIZE['font_main'])
        e = self.blf_title
        e.text = e.unclip_text
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        e.x = LL + D_SIZE['font_main_dx']
        L = e.x + round(blfDimen(FONT0, self.aligntitle  if hasattr(self, "aligntitle") else e.text)[0]) + D_SIZE['font_main_title_offset_R']
        if self.button0.rna.type == "BOOLEAN":
            self.evtkill = False
            self.button0.init_bat(L, L + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            return TT - D_SIZE['widget_full_h']
        else:
            return self.button0.init_bat(L, RR, TT)
        #|
    #|
    #|
class ButtonGroupHeadL(                 # ButtonGroup                                           
    ButtonGroup):
    __slots__ = ()

    def init_bat(self, LL, RR, TT):
        LL += SIZE_widget[0]
        blfSize(FONT0, D_SIZE['font_main'])
        e = self.blf_title
        e.text = e.unclip_text
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        e.x = LL + D_SIZE['font_main_dx']
        if e.text == "":
            L = LL + D_SIZE['font_main_title_offset_R']
        else:
            L = e.x + round(blfDimen(FONT0, e.text)[0]) + D_SIZE['font_main_title_offset_R']
        if self.button0.rna.type == "BOOLEAN":
            self.evtkill = False
            self.button0.init_bat(L, L + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            return TT - D_SIZE['widget_full_h']
        else:
            button_width = self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width']
            return self.button0.init_bat(L, LL + button_width, TT)
        #|
    #|
    #|
class ButtonGroupLC(                    # ButtonGroup                                           
    ButtonGroup):
    __slots__ = ()

    def init_bat(self, LL, RR, TT):
        L = RR - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        if self.button0.rna.type == "BOOLEAN":
            self.evtkill = False
            self.button0.init_bat(L, L + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            B = TT - D_SIZE['widget_full_h']
        else:
            B = self.button0.init_bat(L, RR, TT)

        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        e.x = LL + D_SIZE['font_main_dx'] + D_SIZE['font_main_title_offset_R']
        if hasattr(self.button0, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            if hasattr(self.button0.blf_subtype, "__len__"):
                R0 = L - D_SIZE['font_main_title_offset'] - D_SIZE['font_label_dx'] - round(
                    max(blfDimen(FONT0, o.text)[0]  for o in self.button0.blf_subtype))
            else:
                R0 = L - D_SIZE['font_main_title_offset'] - D_SIZE['font_label_dx'] - round(
                    blfDimen(FONT0, self.button0.blf_subtype.text)[0])
        else:
            R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        return B
        #|
    #|
    #|
class ButtonGroupAlignLR(               # ButtonGroup                                           
    ButtonGroup):
    __slots__ = 'blf_title_head'

    def __init__(self, w, button0, title=None, title_head=""):
        self.w = w
        self.button0 = button0
        button0.w = self
        self.blf_title = BlfClipColor(unclip_text=button0.rna.name  if title is None else title,
            color=COL_block_fg)
        self.blf_title_head = BlfClipColor(unclip_text=title_head, color=COL_block_fg)
        self.inside = button0.inside
        self.inside_evt = button0.inside_evt
        self.outside_evt = button0.outside_evt
        #|

    def init_bat(self, LL, RR, TT):
        L = RR - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        if self.button0.rna.type == "BOOLEAN":
            self.button0.init_bat(L, L + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            B = TT - D_SIZE['widget_full_h']
            self.evtkill = False
        else:
            B = self.button0.init_bat(L, RR, TT)

        e = self.blf_title_head
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        if hasattr(self.button0, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            if hasattr(self.button0.blf_subtype, "__len__"):
                R0 = L - D_SIZE['font_main_title_offset'] - D_SIZE['font_label_dx'] - round(
                    max(blfDimen(FONT0, o.text)[0]  for o in self.button0.blf_subtype))
            else:
                R0 = L - D_SIZE['font_main_title_offset'] - D_SIZE['font_label_dx'] - round(
                    blfDimen(FONT0, self.button0.blf_subtype.text)[0])
        else:
            R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])

        e = self.blf_title
        e.y = self.blf_title_head.y
        e.x = (self.button0.box_button[0].R  if isinstance(self.button0.box_button, list) else self.button0.box_button.R) + D_SIZE['font_main_title_offset_R']
        e.text = e.unclip_text
        return B
        #|

    def dxy(self, dx, dy):
        self.button0.dxy(dx, dy)
        self.blf_title.x += dx
        self.blf_title.y += dy
        self.blf_title_head.x += dx
        self.blf_title_head.y += dy
        #|
    def draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        e = self.blf_title_head
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        self.button0.draw_blf()
        #|
    #|
    #|
class ButtonGroupFull(                  # ButtonGroup                                           
    ButtonGroup):
    __slots__ = ()

    def init_bat(self, LL, RR, TT):
        LL += D_SIZE['font_main_dx']
        L = RR - D_SIZE['widget_width']
        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        if hasattr(self.button0, "blf_subtype"):
            blfSize(FONT0, D_SIZE['font_label'])
            if hasattr(self.button0.blf_subtype, "__len__"):
                width_subtype = round(max(blfDimen(FONT0, o.text)[0]  for o in self.button0.blf_subtype))
            else:
                width_subtype = round(blfDimen(FONT0, self.button0.blf_subtype.text)[0])
            R0 = L - D_SIZE['font_main_title_offset'] - width_subtype
        else:
            width_subtype = 0
            R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL, R0)
        e.x = LL

        if width_subtype == 0:
            B = self.button0.init_bat(
                LL + round(blfDimen(FONT0, e.text)[0]) + D_SIZE['font_main_title_offset'], RR, TT)
        else:
            B = self.button0.init_bat(width_subtype + D_SIZE['font_label_dx'] +
                LL + round(blfDimen(FONT0, e.text)[0]) + D_SIZE['font_main_title_offset'], RR, TT)
        return B
        #|
    #|
    #|
class ButtonGroupTwo:
    __slots__ = (
        'w',
        'button0',
        'button1',
        'blf_title',
        'focus_element',
        'evtkill')

    def __init__(self, w, button0, button1, title=""):
        self.w = w
        self.button0 = button0
        self.button1 = button1
        button0.w = self
        button1.w = self
        self.blf_title = BlfClipColor(unclip_text=title, color=COL_block_fg)
        #|

    def init_bat(self, LL, RR, TT):
        L = RR - D_SIZE['widget_width']

        # /* 0block_ButtonGroupTwo_init_bat
        if self.button0.rna.type == "BOOLEAN":
            self.button0.init_bat(L, L + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            B = TT - D_SIZE['widget_full_h']
        else:
            B = self.button0.init_bat(L, RR, TT)

        R1 = self.button0.box_button.L - SIZE_widget[3]
        if self.button1.rna.type == "BOOLEAN":
            self.button1.init_bat(R1 - D_SIZE['widget_bool_full_h'], R1, TT - D_SIZE['widget_bool_dT'])
            B1 = TT - D_SIZE['widget_full_h']
        else:
            B1 = self.button1.init_bat(R1 - D_SIZE['widget_width'], R1, TT)

        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        R0 = self.button1.box_button.L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])
        return min(B, B1)
        # */
    def r_height(self, width):
        return max(self.button0.r_height(D_SIZE['widget_width']), self.button1.r_height(D_SIZE['widget_width']))
        #|

    def is_dark(self):
        return self.button0.is_dark()
        #|
    def dark(self):
        self.button0.dark()
        self.button1.dark()
        self.blf_title.color = COL_block_fg_ignore
        #|
    def light(self):
        self.button0.light()
        self.button1.light()
        self.blf_title.color = COL_block_fg
        #|

    def inside(self, mouse):
        if self.button0.inside(mouse):
            self.evtkill = False  if hasattr(self.button0, "evtkill") and self.button0.evtkill == False else True
            return True
        if self.button1.inside(mouse):
            self.evtkill = False  if hasattr(self.button1, "evtkill") and self.button1.evtkill == False else True
            return True
        return False
        #|
    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        self.button0.outside_evt()
        self.button1.outside_evt()
        #|

    def modal(self):
        if self.button0.inside(MOUSE): e = self.button0
        elif self.button1.inside(MOUSE): e = self.button1
        else: e = None

        if e is None:
            if self.focus_element is not None:
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True
        return False
        #|

    def dxy(self, dx, dy):
        self.button0.dxy(dx, dy)
        self.button1.dxy(dx, dy)
        self.blf_title.x += dx
        self.blf_title.y += dy
        #|
    def draw_box(self):
        self.button0.draw_box()
        self.button1.draw_box()
        #|
    def draw_blf(self):
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        self.button0.draw_blf()
        self.button1.draw_blf()
        #|

    def upd_data(self):
        self.button0.upd_data()
        self.button1.upd_data()
        #|

    @property
    def box_button(self):
        return self.button1.box_button
        #|
    #|
    #|
class ButtonGroupTwoHalf(ButtonGroupTwo):
    __slots__ = ()

    def init_bat(self, LL, RR, TT):
        L = RR - D_SIZE['widget_width'] // 2

        # <<< 1copy (0block_ButtonGroupTwo_init_bat,, ${"R1 - D_SIZE['widget_width']":"RR - D_SIZE['widget_width']"}$)
        if self.button0.rna.type == "BOOLEAN":
            self.button0.init_bat(L, L + D_SIZE['widget_bool_full_h'], TT - D_SIZE['widget_bool_dT'])
            B = TT - D_SIZE['widget_full_h']
        else:
            B = self.button0.init_bat(L, RR, TT)

        R1 = self.button0.box_button.L - SIZE_widget[3]
        if self.button1.rna.type == "BOOLEAN":
            self.button1.init_bat(R1 - D_SIZE['widget_bool_full_h'], R1, TT - D_SIZE['widget_bool_dT'])
            B1 = TT - D_SIZE['widget_full_h']
        else:
            B1 = self.button1.init_bat(RR - D_SIZE['widget_width'], R1, TT)

        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        R0 = self.button1.box_button.L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])
        return min(B, B1)
        # >>>
        #|
    #|
    #|
class ButtonGroupY:
    __slots__ = (
        'w',
        'buttons',
        'focus_element',
        'gap',
        'evtkill',
        'r_button_width')

    def __init__(self, w, buttons, gap=0):
        self.w = w
        self.buttons = buttons
        self.gap = gap
        #|

    def init_bat(self, LL, RR, TT):
        gap = self.gap()  if callable(self.gap) else self.gap
        for button in self.buttons:
            TT = button.init_bat(LL, RR, TT) - gap
        return TT + gap
        #|
    def r_height(self, width):
        gap = self.gap()  if callable(self.gap) else self.gap
        return sum(button.r_height(width)  for button in self.buttons) + (len(self.buttons) - 1) * gap
        #|
    def r_width_input(self, button):
        return self.w.r_width_input(self)
        #|

    def dark(self):
        for e in self.buttons:
            if hasattr(e, "dark"): e.dark()
        #|
    def light(self):
        for e in self.buttons:
            if hasattr(e, "light"): e.light()
        #|

    def inside(self, mouse):
        for button in self.buttons:
            if button.inside(mouse):
                self.evtkill = False  if hasattr(button, "evtkill") and button.evtkill == False else True
                return True
        return False
        #|
    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        for button in self.buttons:
            button.outside_evt()
        #|

    def modal(self):
        e = None
        for button in self.buttons:
            if button.inside(MOUSE):
                e = button
                break

        if e is None:
            if self.focus_element is not None:
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True
        return False
        #|

    def dxy(self, dx, dy):
        for e in self.buttons: e.dxy(dx, dy)
        #|
    def draw_box(self):
        for e in self.buttons: e.draw_box()
        #|
    def draw_blf(self):
        for e in self.buttons: e.draw_blf()
        #|

    def upd_data(self):
        for e in self.buttons: e.upd_data()
        #|
    #|
    #|
class ButtonGroupArray(                 # ButtonGroup                                           
    ButtonGroup):
    __slots__ = ()

    def __init__(self, w, button0, title=None):
        self.w = w
        self.button0 = button0
        button0.w = self
        self.blf_title = BlfClipColor(unclip_text=""  if title is None else title,
            color=COL_block_fg)
        self.inside = button0.inside
        self.inside_evt = button0.inside_evt
        self.outside_evt = button0.outside_evt
        #|

    def init_bat(self, LL, RR, TT):
        h = SIZE_widget[0]
        widget_rim = SIZE_border[3]
        L = RR - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])
        B = self.button0.init_bat(L, RR, TT)

        e = self.blf_title
        e.y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])
        return B
        #|
    #|
    #|

class ButtonSplit:
    __slots__ = (
        'w',
        'button0',
        'button1',
        'focus_element',
        'factor',
        'gap',
        'evtkill')

    def __init__(self, w, button0, button1, gap=0, factor=0.5):
        self.w = w
        self.gap = gap
        self.factor = factor
        self.button0 = button0
        self.button1 = button1
        button0.w = self
        button1.w = self
        #|

    def init_bat(self, LL, RR, TT):
        gap = self.gap()  if callable(self.gap) else self.gap
        R0 = round(LL + (RR - LL - gap) * self.factor)
        return min(self.button0.init_bat(LL, R0, TT), self.button1.init_bat(R0 + gap, RR, TT))
        #|
    def r_height(self, width):
        return max(self.button0.r_height(width), self.button1.r_height(width))
        #|

    def dark(self):
        if hasattr(self.button0, "dark"): self.button0.dark()
        if hasattr(self.button1, "dark"): self.button1.dark()
        #|
    def light(self):
        if hasattr(self.button0, "light"): self.button0.light()
        if hasattr(self.button1, "light"): self.button1.light()
        #|

    def inside(self, mouse):
        if self.button0.inside(mouse):
            self.evtkill = False  if hasattr(self.button0, "evtkill") and self.button0.evtkill == False else True
            return True
        if self.button1.inside(mouse):
            self.evtkill = False  if hasattr(self.button1, "evtkill") and self.button1.evtkill == False else True
            return True
        return False
        #|
    def inside_evt(self):
        self.focus_element = None
        #|
    def outside_evt(self):
        self.button0.outside_evt()
        self.button1.outside_evt()
        #|

    def modal(self):
        if self.button0.inside(MOUSE): e = self.button0
        elif self.button1.inside(MOUSE): e = self.button1
        else: e = None

        if e is None:
            if self.focus_element is not None:
                self.focus_element.outside_evt()
                self.focus_element = None
        else:
            if self.focus_element != e:
                if self.focus_element is not None: self.focus_element.outside_evt()
                self.focus_element = e
                e.inside_evt()

            if e.modal(): return True
        return False
        #|

    def dxy(self, dx, dy):
        self.button0.dxy(dx, dy)
        self.button1.dxy(dx, dy)
        #|
    def draw_box(self):
        self.button0.draw_box()
        self.button1.draw_box()
        #|
    def draw_blf(self):
        self.button0.draw_blf()
        self.button1.draw_blf()
        #|

    def upd_data(self):
        self.button0.upd_data()
        self.button1.upd_data()
        #|

    @property
    def box_button(self):
        return self.button1.box_button
        #|
    #|
    #|
class ButtonOverlay(                    # ButtonSplit                                           
    ButtonSplit):
    __slots__ = ()

    def __init__(self, w, button0, button1):
        self.w = w
        self.button0 = button0
        self.button1 = button1
        button0.w = self
        button1.w = self
        #|

    def init_bat(self, LL, RR, TT):
        return min(self.button0.init_bat(LL, RR, TT), self.button1.init_bat(LL, RR, TT))
        #|

    def r_width_input(self, button):
        return self.w.r_width_input(self)
        #|
    #|
    #|
class ButtonOverlayTitle(ButtonOverlay):
    __slots__ = ()

    GROUP_INFO = None

    def init_bat(self, LL, RR, TT):
        B1 = self.button1.init_bat(LL, RR, TT)
        self.button0.init_bat(LL, self.button1.box_button.L, TT)
        return B1
        #|
    #|
    #|
class ButtonJoinColumn(ButtonGroupY):
    __slots__ = ()

    def get(self):
        return [e.get()  for e in self.buttons]
        #|
    def set(self, v, index, refresh=True, undo_push=True):
        buttons = self.buttons

        if isinstance(index, int):
            buttons[index].set(v, refresh=refresh, undo_push=undo_push)
        else:
            i = index[0]
            for v in v:
                buttons[i].set(v, refresh=refresh, undo_push=undo_push)
                i += 1
        #|

    def to_modal_join_column(self, _self):

        buttons = self.buttons
        le = len(buttons)
        max_index = le - 1
        lookup = {e: r  for r, e in enumerate(buttons)}

        end_trigger = r_end_trigger('click')
        mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")
        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _xy = [0, 0]
        _value_data = {'confirm': True, 'start_index': lookup[_self]}
        _th_drag = P.th_drag
        _h = SIZE_widget[0]
        color_act = COL_box_val_active
        _self.box_button.color = color_act

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                _value_data["confirm"] = None
                w_head.fin()
                _self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if abs(_xy[0]) >= _th_drag:
                _xy[0] = 0
                mouseloop()
                _REDRAW()
                W_HEAD.remove(w_head)
                _self.to_modal_drag_pre(override=(end_trigger, mouseloop_end, mouseloop, r_dxy_mouse))
                return
            elif abs(_xy[1]) >= _th_drag:
                _xy[0] = 0
                _xy[1] = 0
                _REDRAW()
                w_head.modal = modal_drag_pre_array
                _value_data["end_index"] = _value_data["start_index"]

            mouseloop()

        def modal_drag_pre_array():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                _value_data["confirm"] = None
                w_head.fin()

                if _value_data["end_index"] == _value_data["start_index"]:
                    buttons[_value_data["start_index"]].to_dropdown()
                else:
                    i0 = _value_data["start_index"]
                    i1 = _value_data["end_index"]
                    if i0 > i1:
                        i0, i1 = i1, i0
                    u = buttons[_value_data["end_index"]]
                    o = u.blf_value
                    DropDownVal(self, u.box_button.r_LRBT(), o.text, o.unclip_text, u.rna, range(i0, i1 + 1))
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy



            if _xy[1] < - _h:

                d = (- _xy[1]) // _h
                _xy[1] += _h * d
                _xy[0] = 0
                ind = min(_value_data["end_index"] + d, max_index)
            elif _xy[1] > _h:

                d = _xy[1] // _h
                _xy[1] -= _h * d
                _xy[0] = 0
                ind = max(0, _value_data["end_index"] - d)
            else:

                ind = _value_data["end_index"]

            if ind != _value_data["end_index"]:

                i0 = _value_data["start_index"]
                i1 = ind
                _value_data["end_index"] = ind

                if i0 > i1:
                    i0, i1 = i1, i0

                for r in range(i0):
                    buttons[r].box_button.color = COL_box_val_ignore  if buttons[r].isdark is True else COL_box_val
                for r in range(i0, i1 + 1):
                    buttons[r].box_button.color = color_act
                for r in range(i1 + 1, le):
                    buttons[r].box_button.color = COL_box_val_ignore  if buttons[r].isdark is True else COL_box_val
                _REDRAW()

            if abs(_xy[0]) >= _h:

                _xy[0] = 0
                _REDRAW()
                i0 = _value_data["start_index"]
                ind = _value_data["end_index"]
                init_ind = ind

                if i0 > ind:
                    i0, ind = ind, i0
                _value_data["array_range"] = range(i0, ind + 1)
                _value_data["array_index"] = i0, ind + 1
                _le = len(_value_data["array_range"])
                _index_ = _value_data["array_index"]
                _blf_value_fo = buttons[init_ind].blf_value

                _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
                _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
                _set = self.set
                _initvalue = self.get()

                if _self.rna.type == "INT":
                    _valbox_drag_fac = P.valbox_drag_fac_int

                    _soft_min = _self.rna.soft_min
                    _soft_max = _self.rna.soft_max
                    _soft_value = [0, 0]
                    _soft_threshold = max(1, round(2000 * _valbox_drag_fac))
                    _soft_step = max(1, round(800 * _valbox_drag_fac))

                    def modal_drag_array():
                        _REDRAW()

                        if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                            _value_data["confirm"] = False
                            w_head.fin()

                            _set(_initvalue, (0, le), undo_push=False)
                            return
                        if end_trigger():
                            w_head.fin()
                            _set([_blf_value_fo.unclip_text] * _le, _index_, undo_push=False)
                            update_scene_push("Multiple drag modal")
                            return

                        dx, dy = r_dxy_mouse()
                        if _TRIGGER_drag_fast(): dx *= 10
                        elif _TRIGGER_drag_slow(): dx *= 0.1

                        _xy[0] += dx * _valbox_drag_fac
                        travel = _xy[0]
                        if travel >= 1:
                            dx = floor(travel)
                            _xy[0] -= dx
                        elif travel <= -1:
                            dx = ceil(travel)
                            _xy[0] -= dx
                        else:
                            mouseloop()
                            return

                        try:
                            _v = _blf_value_fo.unclip_text + dx
                            if _soft_value[1] >= _soft_threshold:
                                if _v < _soft_max:
                                    _soft_value[1] -= _soft_step
                                    if _soft_value[1] < 0: _soft_value[1] = 0
                            else:
                                if _v > _soft_max:
                                    _soft_value[1] += _v - _soft_max
                                    _soft_value[0] = 0
                                    _v = _soft_max
                                else:
                                    if _soft_value[0] >= _soft_threshold:
                                        if _v > _soft_min:
                                            _soft_value[0] -= _soft_step
                                            if _soft_value[0] < 0: _soft_value[0] = 0
                                    else:
                                        if _v < _soft_min:
                                            _soft_value[0] += _soft_min - _v
                                            _soft_value[1] = 0
                                            _v = _soft_min
                        except:
                            mouseloop()
                            return

                        _set([_v] * _le, _index_, undo_push=False)
                        if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
                        mouseloop()
                else:
                    _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (_self.step  if hasattr(_self, "step") else _self.rna.step) * 0.01)

                    _soft_min = _self.rna.soft_min
                    _soft_max = _self.rna.soft_max
                    _soft_value = [0.0, 0.0]
                    _soft_threshold = 1000.0 * _valbox_drag_fac

                    def modal_drag_array():
                        _REDRAW()

                        if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                            _value_data["confirm"] = False
                            w_head.fin()

                            _set(_initvalue, (0, le), undo_push=False)
                            return
                        if end_trigger():
                            w_head.fin()
                            _set([_blf_value_fo.unclip_text] * _le, _index_, undo_push=False)
                            update_scene_push("Multiple drag modal")
                            return

                        dx, dy = r_dxy_mouse()
                        if _TRIGGER_drag_fast():
                            dx *= _valbox_drag_fac * 10
                        elif _TRIGGER_drag_slow():
                            dx *= _valbox_drag_fac * 0.1
                        else:
                            dx *= _valbox_drag_fac

                        try:
                            _v = _blf_value_fo.unclip_text + dx

                            if _soft_value[1] >= _soft_threshold:
                                if _v < _soft_max:
                                    _soft_value[1] /= 2.0
                            else:
                                if _v > _soft_max:
                                    _soft_value[1] += _v - _soft_max
                                    _soft_value[0] = 0.0
                                    _v = _soft_max
                                else:
                                    if _soft_value[0] >= _soft_threshold:
                                        if _v > _soft_min:
                                            _soft_value[0] /= 2.0
                                    else:
                                        if _v < _soft_min:
                                            _soft_value[0] += _soft_min - _v
                                            _soft_value[1] = 0.0
                                            _v = _soft_min
                        except:
                            mouseloop()
                            return

                        _set([_v] * _le, _index_, undo_push=False)
                        if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
                        mouseloop()

                _set([_blf_value_fo.unclip_text] * _le, _index_, undo_push=False)
                if _blf_value_fo.unclip_text > _soft_max:
                    _soft_value[1] = _soft_threshold
                elif _blf_value_fo.unclip_text < _soft_min:
                    _soft_value[0] = _soft_threshold

                w_head.modal = modal_drag_array

            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>

            for e in buttons:
                if e.isdark is True:
                    e.box_button.color = COL_box_val_ignore
                else:
                    e.box_button.color = COL_box_val_fo  if e is _self else COL_box_val

                if hasattr(e, "end_modal_drag_callback"): e.end_modal_drag_callback()

            mouseloop_end()
            kill_evt_except()
            _REDRAW()
            MODAL_DRAG_STATE[0] = -1

        w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    #|
    #|

#_c4#_c4#_c4#_c4

def r_calc_button_rnas(ty):
    return [RnaButton(str(r), str(r), e[1], e[0])  for r, e in enumerate(CALC_EXP[ty])]
    #|


class Layout:
    __slots__ = (
        'w',
        'items')

    def __init__(self, w):
        self.w = w
        items = w.items  if hasattr(w, "items") else w.buttons
        items.clear()
        self.items = items
        #|

    def set_fold_state(self, boo):
        BlockUtil.DEFAULT_FOLD_STATE = boo
        #|

    def new_block(self, title=None):
        if title is None:
            e = Blocks(self.w)
            e.buttons = []
        else:
            if isinstance(title, str):
                e = BlockUtil(self.w, [], Title(title))
            elif isinstance(title, list):
                e = BlockUtils(self.w, [], title)
            else:
                e = BlockUtil(self.w, [], title)

        self.items.append(e)
        return Layout(e)
        #|

    def sep(self, factor=1.0):
        self.items.append(ButtonSep(factor))
        #|
    def split(self, group0, group1, gap=0, factor=0.5, append=True):
        group = ButtonSplit(self.w, group0, group1, gap=gap, factor=factor)
        if append: self.items.append(group)
        return group
        #|
    def overlay(self, group0, group1, append=True):
        group = ButtonOverlay(self.w, group0, group1)
        if append: self.items.append(group)
        return group
        #|
    def title(self, title=""):
        group = ButtonGroupTitle(self.w, title)
        self.items.append(group)
        return group
        #|

    def prop(self, pp, rna, title=None, align=None, set_callback=None, option=None, append=True, use_push=None):
        ty = rna.type
        if ty == "FLOAT":
            if rna.is_array:
                if rna.subtype == "STRING_VECTOR":
                    button0 = EdStringVector(None, rna, pp)
                    group = ButtonGroup(self.w, button0, title=title)
                    group.r_button_width = lambda: round(D_SIZE['widget_width'] * 1.7)
                else:
                    button0 = EdFloatVector(None, rna, pp)
                    group = ButtonGroup(self.w, button0, title=title)

                    button0.to_modal_drag_callfront = disable_auto_upd
                    button0.end_modal_drag_callback = enable_auto_upd
            else:
                button0 = EdFloat(None, rna, pp)
                group = ButtonGroup(self.w, button0, title=title)

                button0.to_modal_drag_callfront = disable_auto_upd
                button0.end_modal_drag_callback = enable_auto_upd
        elif ty == "BOOLEAN":
            button0 = EdBool(None, rna, pp)

            if align is None:
                group = ButtonGroup(self.w, button0, title=title)
            elif align == "R":
                group = ButtonGroupAlignL(self.w, button0, title=title)
            elif align == "L":
                group = ButtonGroupAlignTitleLeft(self.w, button0, title=title)
            elif align == "T":
                group = ButtonGroupBoolT(self.w, button0, title=title)
            else:
                group = ButtonGroup(self.w, button0, title=title)
        elif ty == "INT":
            if rna.is_array:
                button0 = EdIntVector(None, rna, pp)
                group = ButtonGroup(self.w, button0, title=title)

                button0.to_modal_drag_callfront = disable_auto_upd
                button0.end_modal_drag_callback = enable_auto_upd
            else:
                button0 = EdInt(None, rna, pp)
                group = ButtonGroup(self.w, button0, title=title)

                button0.to_modal_drag_callfront = disable_auto_upd
                button0.end_modal_drag_callback = enable_auto_upd
        elif ty == "STRING":
            if option is None:
                button0 = EdString(None, rna, pp)
            else:
                if "r_armature" in option:
                    button0 = EdBone(None, rna, pp, option["r_armature"])
                else:
                    button0 = EdString(None, rna, pp)

            if align is None:
                group = ButtonGroup(self.w, button0, title=title)
            else:
                group = ButtonGroupAlignTitleLeft(self.w, button0, title=title)
        elif ty == "ENUM":
            if hasattr(rna, "icon"):
                rna_icon = rna.icon
                if isinstance(rna_icon, dict):
                    button0 = EdEnumIcon(None, rna, pp, rna_icon,
                        rna.icon_default  if hasattr(rna, "icon_default") else None)
                else:
                    at = f"ENUM_{rna_icon}"
                    if hasattr(self, at):
                        button0 = getattr(self, at)(rna, pp, option)
                    else:
                        button0 = EdEnum(None, rna, pp)
            else:
                button0 = EdEnum(None, rna, pp)

            if align is None:
                group = ButtonGroup(self.w, button0, title=title)
            else:
                group = ButtonGroupAlignTitleLeft(self.w, button0, title=title)
        elif ty == "RNABUTTON":
            if use_push:
                def localfn():
                    pp()
                    ed_undo_push(message=f'{rna.name}')
                button0 = Edfn(None, rna, localfn)
            else:
                button0 = Edfn(None, rna, pp)

            if align is None:
                group = ButtonGroup(self.w, button0, title=title)
            elif align == "HL":
                group = ButtonGroupHeadL(self.w, button0, title=title)
            elif align == "LC":
                group = ButtonGroupLC(self.w, button0, title=title)
            else:
                TODO
        elif ty == "POINTER":
            button0 = EdID(None, rna, pp)
            group = ButtonGroup(self.w, button0, title=title)
        else:

            TODO

        # /* 0block_Layout_prop_end
        button0.poll = poll_hard_disable
        if set_callback is None:
            button0.set_callback = update_data
        elif set_callback is True:
            button0.set_callback = lambda: button0.upd_data()
        elif set_callback is False: pass
        else:
            _option = {"button": button0}
            if option is not None:
                _option.update(option)

            if hasattr(button0, "active_index"):
                button0.set_callback = lambda: set_callback(_option, button0.get(button0.active_index))
            else:
                button0.set_callback = lambda: set_callback(_option, button0.get())


        if append: self.items.append(group)
        if use_push is not None: button0.use_push = use_push
        return group
        # */
    def prop_boolflag(self, pp, li_rna, li_name=None, title=None, align=None, set_callback=None, option=None, append=True, use_push=None):
        button0 = EdBoolflag(None, li_rna, pp, title=li_name)

        group = ButtonGroupArray(self.w, button0, title=title)

        button0.poll = poll_hard_disable
        if set_callback is None:
            button0.set_callback = update_data
        else:
            _option = {"button": button0}
            if option is not None:
                _option.update(option)

            button0.set_callback = lambda: set_callback(_option, button0.get(button0.focus_index))

        if append: self.items.append(group)
        if use_push is not None: button0.use_push = use_push
        return group
        #|

    def ENUM_idtype(self, rna, pp, option):
        return EdEnumIDType(None, rna, pp)
        #|
    def ENUM_driver_path(self, rna, pp, option):
        return EdEnumDriverPath(None, rna, pp, option["r_ID"])
        #|
    def ENUM_variable_type(self, rna, pp, option):
        return EdEnumVariableType(None, rna, pp)
        #|

    @staticmethod
    def no_background(button0):
        cls = button0.__class__
        class NewCls(cls):
            __slots__ = ()

            def draw_box(self): pass

        button0.__class__ = NewCls
        #|
    @staticmethod
    def wrap_inout_evt(button0, inevt, outevt):
        class LocalWrapInoutEvt(button0.__class__):
            __slots__ = ()

            def inside_evt(self):
                super().inside_evt()
                inevt()
            def outside_evt(self):
                super().outside_evt()
                outevt()

        button0.__class__ = LocalWrapInoutEvt
        #|
    #|
    #|

def wrapButtonFn(fn, ob=None, evtkill=True, push_message="", update=True):
    if evtkill: kill_evt_except()
    try:
        if ob is None: pass
        elif r_library_editable(ob) is False: return

        fn()
        if push_message:
            ed_undo_push(message=push_message)
        if update is True:
            update_scene()
    except Exception as ex:
        DropDownOk(None, MOUSE, input_text=f'Failed.\n{ex}')
    #|

#_c4#_c4#_c4#_c4
def ui_poll_library(ob, is_report=True):
    if hasattr(ob, "is_editable") and not ob.is_editable:
        if is_report:
            report(r_library_or_override_message(ob))
        return False
    return True
    #|
def r_mouse_index(self, index):
    if index is None:
        if hasattr(self, "array_length"):
            if hasattr(self.focus_element, "__len__"):
                return self.focus_element[0]
    return index
    #|

def c_pass(self): pass
def c_r_height_int(self, width): return D_SIZE['widget_full_h']
def c_r_height_vec(self, width): return D_SIZE['widget_full_h'] + (self.array_length - 1) * SIZE_widget[0]
def c_r_height_xy(self, width): return D_SIZE['widget_full_h'] * ceil(len(self.box_button) / self.row_length)
def c_r_default_value(self): return self.rna.default
def c_r_default_value_vec(self): return self.rna.default_array
def c_r_default_value_comb(self, index): return self.rna[index].default

def c_set_ui_state_link(self):
    self.overridden_state = 0
    self.isdarkhard = True
    self.dark()
    #|
def c_set_ui_state_link_STR(self):
    self.overridden_state = 0
    self.isdarkhard = True
    self.box_anim.__class__ = GpuImgNull
    self.dark()
    #|
def c_set_ui_state_default(self):
    self.overridden_state = 0
    self.isdarkhard = self.isdarkhard_prev
    if self.isdark is True:
        self.upd_anim_button = self.i_upd_anim_button_dark
    else:
        self.upd_anim_button = self.i_upd_anim_button

    self.light()
    #|
def c_set_ui_state_default_STR(self):
    self.overridden_state = 0
    self.isdarkhard = self.isdarkhard_prev
    if self.isdark is True:
        self.upd_anim_button = self.i_upd_anim_button_dark
    else:
        self.upd_anim_button = self.i_upd_anim_button

    self.box_anim.__class__ = GpuImgNull
    self.light()
    #|
def c_set_ui_state_overridden(self):
    if self.rna.is_overridable:
        self.overridden_state = 1
        self.isdarkhard = self.isdarkhard_prev
        if self.isdark is True:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.light()
    else:
        self.set_ui_state_link()
    #|
def c_set_ui_state_overridden_comb(self):
    if self.rna[0].is_overridable:
        self.overridden_state = 1
        self.isdarkhard = self.isdarkhard_prev
        if self.isdark is True:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.light()
    else:
        self.set_ui_state_link()
    #|

def c_inside(self, mouse):
    if self.box_button.B <= mouse[1] < self.box_button.T:
        if self.box_button.L <= mouse[0] < self.box_anim.R: return True
    return False
    #|
def c_inside_vec(self, mouse):
    if self.box_button.B <= mouse[1] < self.box_button.T:
        if self.box_button.L <= mouse[0] < self.box_anim[0].R: return True
    return False
    #|
def c_inside_bool(self, mouse):
    if self.box_anim.B <= mouse[1] < self.box_anim.T:
        if self.box_button.L <= mouse[0] < self.box_anim.R: return True
    return False
    #|
def c_inside_bool_vec(self, mouse):
    x, y = mouse
    for box_button, box_anim in zip(self.box_button, self.box_anim):
        if box_anim.B <= y < box_anim.T:
            if box_button.L <= x < box_anim.R: return True
    return False
    #|

def c_inside_evt(self):
    self.focus_element = -1
    self.is_trigger_anim_enable = True
    if hasattr(self, 'inside_callback'):
        self.inside_callback()
    #|
def c_inside_evt_bool(self):
    self.focus_element = -1
    self.is_trigger_anim_enable = True
    self.is_trigger_enable = True
    #|
def c_outside_evt(self):
    if hasattr(self, 'outside_callback'):
        self.outside_callback()
    self.focus_element = -1
    self.focus_empty()
    #|

def c_init_bat_anim_BuInt(self, LL, RR, TT):
    # /* 0blockBuIntInitBatAnim
    widget_rim = SIZE_border[3]
    R2 = RR - SIZE_widget[0]
    R1 = R2 - widget_rim
    L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

    B = TT - D_SIZE['widget_full_h']
    self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

    B0 = B + widget_rim
    blf_y = B0 + D_SIZE['font_main_dy']
    #_REF_0#
    #_REF_1#
    self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
    self.blf_value.y = blf_y

    e = self.blf_title
    e.y = blf_y
    R0 = L - D_SIZE['font_main_title_offset']
    # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
    blfSize(FONT0, D_SIZE['font_main'])
    blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
    # >>>
    e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
    e.x = R0 - round(blfDimen(FONT0, e.text)[0])

    self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
    # */
    return B
    #|
def c_init_bat_anim_BuEnum(self, LL, RR, TT):
    # /* 0blockBuEnumInitBatAnim
    widget_rim = SIZE_border[3]
    R2 = RR - SIZE_widget[0]
    R1 = R2 - widget_rim
    L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

    B = TT - D_SIZE['widget_full_h']
    self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

    L9, R9, B9, T9 = self.box_button.inner
    self.box_icon_arrow.LRBT_upd(R9 - SIZE_widget[0], R9, B9, T9)

    blf_y = B9 + D_SIZE['font_main_dy']
    self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
    self.blf_value.y = blf_y

    e = self.blf_title
    e.y = blf_y
    R0 = L - D_SIZE['font_main_title_offset']
    # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
    blfSize(FONT0, D_SIZE['font_main'])
    blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
    # >>>
    e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
    e.x = R0 - round(blfDimen(FONT0, e.text)[0])

    self.box_anim.LRBT_upd(R2, RR, B9, T9)
    # */
    return B
    #|
def c_init_bat_anim_BuEnumIcon(self, LL, RR, TT):
    # <<< 1copy (0blockBuEnumInitBatAnim,, $$)
    widget_rim = SIZE_border[3]
    R2 = RR - SIZE_widget[0]
    R1 = R2 - widget_rim
    L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

    B = TT - D_SIZE['widget_full_h']
    self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

    L9, R9, B9, T9 = self.box_button.inner
    self.box_icon_arrow.LRBT_upd(R9 - SIZE_widget[0], R9, B9, T9)

    blf_y = B9 + D_SIZE['font_main_dy']
    self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
    self.blf_value.y = blf_y

    e = self.blf_title
    e.y = blf_y
    R0 = L - D_SIZE['font_main_title_offset']
    # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
    blfSize(FONT0, D_SIZE['font_main'])
    blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
    # >>>
    e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
    e.x = R0 - round(blfDimen(FONT0, e.text)[0])

    self.box_anim.LRBT_upd(R2, RR, B9, T9)
    # >>>

    self.box_icon.LRBT_upd(L9, L9 + SIZE_widget[0], B9, T9)
    self.blf_value.x += SIZE_widget[0]
    return B
    #|
def c_init_bat_anim_BuEnumIcon_FULL(self, LL, RR, TT):
    widget_rim = SIZE_border[3]
    R2 = RR - SIZE_widget[0]
    R1 = R2 - widget_rim

    blf_title = self.blf_title
    if blf_title.unclip_text:
        blfSize(FONT0, D_SIZE['font_main'])
        if hasattr(self, "r_button_width"):
            blf_title.x = LL + D_SIZE['font_main_title_offset'] + self.r_button_width()
        else:
            blf_title.x = LL + D_SIZE['font_main_title_offset']

        L = blf_title.x + round(blfDimen(FONT0, blf_title.unclip_text)[0]) + D_SIZE['font_main_title_offset']
    else:
        if hasattr(self, "r_button_width"):
            L = LL + widget_rim + widget_rim + self.r_button_width()
        else:
            L = LL + widget_rim + widget_rim
        blf_title.x = L

    B = TT - D_SIZE['widget_full_h']
    self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)
    L9, R9, B9, T9 = self.box_button.inner
    self.box_icon_arrow.LRBT_upd(R9 - SIZE_widget[0], R9, B9, T9)
    self.box_icon.LRBT_upd(L9, L9 + SIZE_widget[0], B9, T9)

    B0 = B + widget_rim
    blf_y = B0 + D_SIZE['font_main_dy']
    self.blf_value.x = L9 + SIZE_widget[0] + D_SIZE['font_main_dx']
    self.blf_value.y = blf_y

    blf_title.y = blf_y

    self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
    if hasattr(self, "upd_match_button"):
        self.upd_match_button()
    return B
    #|
def c_init_bat_anim_title_offset_inv_BuEnumIcon(self, LL, RR, TT):
    # <<< 1copy (0blockBuEnumInitBatAnim,, ${
    #     "R0 = L - D_SIZE['font_main_title_offset']": "R0 = L - D_SIZE['font_main_title_offset'] - D_SIZE['widget_full_h'] - SIZE_widget[0] - D_SIZE['font_main_dx'] * 2"
    # }$)
    widget_rim = SIZE_border[3]
    R2 = RR - SIZE_widget[0]
    R1 = R2 - widget_rim
    L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

    B = TT - D_SIZE['widget_full_h']
    self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

    L9, R9, B9, T9 = self.box_button.inner
    self.box_icon_arrow.LRBT_upd(R9 - SIZE_widget[0], R9, B9, T9)

    blf_y = B9 + D_SIZE['font_main_dy']
    self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
    self.blf_value.y = blf_y

    e = self.blf_title
    e.y = blf_y
    R0 = L - D_SIZE['font_main_title_offset'] - D_SIZE['widget_full_h'] - SIZE_widget[0] - D_SIZE['font_main_dx'] * 2
    # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
    blfSize(FONT0, D_SIZE['font_main'])
    blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
    # >>>
    e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
    e.x = R0 - round(blfDimen(FONT0, e.text)[0])

    self.box_anim.LRBT_upd(R2, RR, B9, T9)
    # >>>

    L0 = L + widget_rim
    self.box_icon.LRBT_upd(L0, L0 + SIZE_widget[0], B9, T9)
    self.blf_value.x += SIZE_widget[0]
    return B
    #|


def c_set_text(self, text):
    self.blf_title.unclip_text = text
    RR = self.box_button.R + SIZE_widget[0] + SIZE_border[3]
    self.init_bat(RR - self.w.r_width_input(self), RR, self.box_button.T)
    self.upd_data()
    #|
def c_tag_clipping_dirty(self):
    self.blf_value.unclip_text = self.blf_value.text = ""
    #|
def c_drag_untag(self):
    self.to_modal_drag_callfront = disable_auto_upd
    self.end_modal_drag_callback = enable_auto_upd
    #|


@ catch
def c_evt_area_copy(self, index=None, is_report=True):

    kill_evt_except()
    index = r_mouse_index(self, index)
    ty = self.rna.type
    if ty == "INT":
        if hasattr(self, "array_length"):
            if index is None:
                self.evt_area_cut()
                return

            v = self.get()[index]
        else:
            v = self.get()

        s = value_to_display(v)
    elif ty == "FLOAT":
        if hasattr(self, "array_length"):
            if index is None or hasattr(self, "color_value"):
                self.evt_area_cut()
                return

            v = self.get()[index]
        else:
            v = self.get()

        v = v / r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format)
        s = value_to_display(v)
    elif ty in {"BOOLEAN"}:
        if hasattr(self, "array_length"):
            if index is None:
                self.evt_area_cut()
                return

            v = self.get()[index]
        else:
            v = self.get()

        s = "1"  if v else "0"
    elif ty == "ENUM":
        v = self.get()
        if v == None: s = "None"
        elif isinstance(v, set):
            ls = [e.name  for e in self.enum_items  if e.identifier in v]
            s = str(ls).replace("[", "{").replace("]", "}")
        else:
            s = self.enum_items[v].name  if v in self.enum_items else v
    elif ty == "POINTER":
        v = self.get()
        s = v.name  if hasattr(v, "name") else ""
    else:
        s = f'{self.get()}'

    bpy.context.window_manager.clipboard = s
    if is_report: report("Copy to Clipboard")
    #|
@ catch
def c_evt_area_cut(self, index=None, is_report=True):

    v = self.get()
    ty = self.rna.type

    if hasattr(self, "array_length"):
        kill_evt_except()
        if ty == "INT":
            s = ", ".join(value_to_display(v)  for v in self.get())
        elif ty == "FLOAT":
            if hasattr(self, "text_format"):
                fac = r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format)
                s = ", ".join(value_to_display(v / fac)  for v in self.get())
            else:
                s = ", ".join(value_to_display(v)  for v in self.get())
        elif ty == "BOOLEAN":
            s = ", ".join(value_to_display("1"  if v else "0")  for v in self.get())

        bpy.context.window_manager.clipboard = s
        if is_report: report("Copy Array to Clipboard")
    else:
        if ty in {"ENUM", "POINTER"}:
            kill_evt_except()
            if hasattr(v, "name"):
                v = r_ID_dp(v)

            bpy.context.window_manager.clipboard = f'{v}'
            if is_report: report("Copy Identifier to Clipboard")
        else:
            c_evt_area_copy(self, is_report=is_report)
    #|
@ catch
def c_evt_area_paste(self, index=None, is_report=True):

    kill_evt_except()
    if self.isdark is True and self.isdarkhard is True: return

    s = bpy.context.window_manager.clipboard
    index = r_mouse_index(self, index)

    s_strip = s.strip()
    if s_strip.startswith(";") and not s_strip.startswith(";;"):
        try:
            if hasattr(self, "array_length"):
                self.set(s, 0  if index is None else index)
            else:
                self.set(s)
        except:
            if is_report: report("Invalid Input")
        return

    ty = self.rna.type
    if ty in {"INT", "FLOAT"}:
        try:
            if s.startswith("#"):
                if hasattr(self, "array_length"):
                    self.set(s, 0  if index is None else index)
                else:
                    self.set(s)
                return

            array = calc_vec(s)

            if ty == "INT":
                if hasattr(self, "array_length"):
                    ll = len(array)
                    if ll == 1 and index is not None:
                        self.set(int(round_dec(array[0])), index)
                    else:
                        if ll > self.array_length:
                            array = array[ : self.array_length]
                        self.set([int(round_dec(v))  for v in array], (0, ll))
                else:
                    self.set(int(round_dec(array[0])))
            else:
                if hasattr(self, "text_format"): pass
                else:
                    self.set([float(v)  for v in array], (0, len(array)))
                    return

                fac = r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format)
                if hasattr(self, "array_length"):
                    ll = len(array)
                    if ll == 1 and index is not None:
                        self.set(float(array[0] * fac), index)
                    else:
                        if ll > self.array_length:
                            array = array[ : self.array_length]
                        self.set([float(v * fac)  for v in array], (0, ll))
                else:
                    self.set(array[0] * r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, self.text_format))
        except:
            if is_report: report("Invalid Input")
            return
    elif ty == "BOOLEAN":
        if s in {'True', 'true', '1', '1.0'}:
            if hasattr(self, "array_length"):
                self.set(True, 0  if index is None else index)
            else:
                self.set(True)
            return
        elif s in {'False', 'false', '0', '0.0'}:
            if hasattr(self, "array_length"):
                self.set(False, 0  if index is None else index)
            else:
                self.set(False)
            return

        try:
            if s.startswith("#"):
                if hasattr(self, "array_length"):
                    self.set(s, 0  if index is None else index)
                else:
                    self.set(s)
                return

            array = calc_vec(s)

            if hasattr(self, "array_length"):
                ll = len(array)
                if ll == 1 and index is not None:
                    self.set(bool(array[0]), index)
                else:
                    if ll > self.array_length:
                        array = array[ : self.array_length]
                    self.set([bool(v)  for v in array], (0, ll))
            else:
                self.set(bool(array[0]))
        except:
            if is_report: report("Invalid Input")
            return
    else:
        try: self.set(s)
        except:
            if is_report: report("Invalid Input")
            return
    #|
@ catch
def c_evt_area_reset_single(self, index=None, is_report=True):

    kill_evt_except()
    if self.isdark is True and self.isdarkhard is True: return

    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    if is_value_overridden(pp, pp.id_data, (self.identifier_escape  if hasattr(self, 'identifier_escape') else self.identifier), index=r_mouse_index(self, index)):
        self.evt_remove_override(index=index, is_report=is_report)
        return

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        if index is None:
            c_evt_area_reset_all(self, is_report=is_report)
            return

        self.set(self.r_default_value()[index], index)
    else:
        self.set(self.r_default_value())
    #|
@ catch
def c_evt_area_reset_all(self, index=None, is_report=True):

    kill_evt_except()
    if self.isdark is True and self.isdarkhard is True: return

    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    if is_value_overridden(pp, pp.id_data, (self.identifier_escape  if hasattr(self, 'identifier_escape') else self.identifier), index=r_mouse_index(self, index)):
        self.evt_remove_override(index=-1, is_report=is_report)
        return

    v = self.get()
    if hasattr(self, "array_length"):
        self.set(self.r_default_value(), (0, self.array_length))
    else:
        self.set(self.r_default_value())
    #|
@ catch
def c_evt_area_format(self, index=None, is_report=True):

    kill_evt_except()
    if self.isdark is True and self.isdarkhard is True: return

    ty = self.rna.type
    if ty == "FLOAT":
        unit = self.unit  if hasattr(self, "unit") else self.rna.unit
        if unit == "ROTATION":
            if self.text_format.__name__.find("deg") == -1:
                self.text_format = UnitSystem.rs_format_deg
            else:
                self.text_format = UnitSystem.format_float

            self.pp = self.r_pp()
            if not self.pp: return
            v = self.get()

            if self.rna.is_array:
                for e, v in zip(self.blf_value, v):
                    e.unclip_text = v
                    e.text = self.text_format(v)
            else:
                self.blf_value.unclip_text = v
                self.blf_value.text = self.text_format(v)
            Admin.REDRAW()
    #|

@ catch
def c_evt_area_detail(self, is_report=True):

    kill_evt_except()
    Detail(Detail.r_rna_info(self.rna))
    #|

@ catch
def c_evt_remove_from_keying_set(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    # <<< 1copy (0defassignDP,, $$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
    else:
        dp = pp.path_from_id(self.identifier)
    # >>>

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        success, s = r_remove_from_keying_set(ob, dp, index="all"  if index in {None, -1} else index)
    else:
        success, s = r_remove_from_keying_set(ob, dp)
    if s:
        DropDownOk(None, MOUSE, input_text=s)
    #|
@ catch
def c_evt_add_to_keying_set(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if not self.rna.is_animatable:
        if is_report:
            report(f'Property {self.identifier} cannot be animated')
        return

    # <<< 1copy (0defassignDP,, $$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
    else:
        dp = pp.path_from_id(self.identifier)
    # >>>

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        success, s = r_add_to_keying_set(ob, dp, index="all"  if index in {None, -1} else index)
    else:
        success, s = r_add_to_keying_set(ob, dp)
    if s:
        DropDownOk(None, MOUSE, input_text=s)
    #|
@ catch
def c_evt_copy_full_data_path(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data

    try:
        dp = r_dpf_with(pp, ob, self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier)
    except:
        dp = self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        if index is not None:
            dp += f'[{index}]'

    bpy.context.window_manager.clipboard = dp
    if is_report:
        report("Full Data Path is copied to the clipboard")
    #|
@ catch
def c_evt_copy_data_path(self, index=None, is_report=True, full=False):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data

    dp = r_dp_with(pp, ob, self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier)
    if dp.startswith("<"):
        dp = self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        if index is not None:
            dp += f'[{index}]'

    bpy.context.window_manager.clipboard = dp
    if is_report:
        report("Data Path is copied to the clipboard")
    #|
@ catch
def c_evt_paste_full_data_path_as_driver(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return
    # if self.overridden_state != 0:
    #     if is_report: report("Overridden data cannot be animated")
    #     return

    if not self.rna.is_animatable:
        if is_report:
            report(f'Property {self.identifier} cannot be animated')
        return

    # <<< 1copy (0defassignDP,, $$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
    else:
        dp = pp.path_from_id(self.identifier)
    # >>>

    fdp = bpy.context.window_manager.clipboard.strip()
    if not fdp.startswith("bpy.data."):
        if is_report:
            report("Invalid Path")
        return

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        if index is None:
            def endfn(data):
                if data["is_confirm"] is False or not data["indexes"]: return

                fails = []
                for r in data["indexes"]:
                    fc = r_action_fc(ob, dp, index=r)
                    if fc:
                        fails.append(f'Index {r} already has keyframe')
                        continue

                    success, ex = paste_full_data_path_as_driver_safe(
                        fdp,
                        r_driver_fc(ob, dp, index=r),
                        "",
                        ob,
                        self.rna,
                        pp,
                        index = r,
                        update_push = False)

                    if success is False:
                        fails.append(f'Index {r} failed: {ex}')

                if fails and is_report:
                    DropDownOk(None, MOUSE, input_text='\n'.join(fails))

                update_scene_push("Paste Full Path as Driver to index(es)")
                upd_link_data()
                #|

            call_dd_index_dialog(MOUSE,
                index_range = self.vec_range,
                endfn = endfn,
                title = "Paste Driver(s)",
                text = "Paste full data path as driver to index")
            return
        else:
            fc = r_action_fc(ob, dp, index=index)
    else:
        fc = r_action_fc(ob, dp)
    if fc:
        if is_report:
            report("Unable to add driver when keyframe already exists")
        return

    if hasattr(self, "array_length"):
        dr_index = 0  if index is None else index
        dr = r_driver_fc(ob, dp, index=dr_index)
    else:
        dr_index = None
        dr = r_driver_fc(ob, dp)

    success, ex = paste_full_data_path_as_driver_safe(
        fdp,
        dr,
        "",
        ob,
        self.rna,
        pp,
        index = dr_index)

    if success is False:
        if is_report:
            DropDownOk(None, MOUSE, input_text=f'Failed to add Driver.\n{ex}')
    #|
@ catch
def c_evt_delete_driver(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if r_library_editable(ob) is False:
        if is_report:
            report(r_library_or_override_message(ob))
        return

    if self.rna.is_animatable:
        # <<< 1copy (0defassignDP,, $$)
        if hasattr(self, "identifier_escape"):
            dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
        else:
            dp = pp.path_from_id(self.identifier)
        # >>>

        if hasattr(self, "array_length"):
            index = r_mouse_index(self, index)
            if index is None:
                drs = [r_driver_fc(ob, dp, index=r)  for r in self.vec_range]
                if any(drs): pass
                else:
                    if is_report:
                        report("Driver not found")
                    return

                def endfn(data):
                    if data["is_confirm"] is False or not data["indexes"]: return

                    fails = []
                    drivers = ob.animation_data.drivers
                    remove_indexes = data["indexes"]

                    for r, dr in enumerate(drs):
                        if dr and r in remove_indexes:
                            try:
                                drivers.remove(dr)
                            except Exception as ex:
                                fails.append(f'Index {r} failed: {ex}')

                    if fails and is_report:
                        DropDownOk(None, MOUSE, input_text='\n'.join(fails))

                    update_scene_push("Delete Drivers from index(es)")
                    self.set(self.get()[0], 0, undo_push=False)

                call_dd_index_dialog(MOUSE,
                    index_range = self.vec_range,
                    dark_indexes = {r  for r, e in enumerate(drs)  if not e},
                    endfn = endfn,
                    title = "Delete Driver(s)",
                    text = "Delete Drivers from index(es)")
                return
            else:
                dr = r_driver_fc(ob, dp, index=index)
                if dr is None:
                    if is_report:
                        report("Driver not found")
                    return
        else:
            dr = r_driver_fc(ob, dp)
            if dr is None:
                if is_report:
                    report("Driver not found")
                return

        ob.animation_data.drivers.remove(dr)
        update_scene_push("Delete Driver")
        if hasattr(self, "array_length"):
            self.set(self.get()[0], 0, undo_push=False)
        else:
            self.set(self.get(), undo_push=False)
    #|
@ catch
def c_evt_add_driver(self, index=None, is_report=True, exp="var", replace=False, use_editor=False):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return
    # if self.overridden_state != 0:
    #     if is_report: report("Overridden data cannot be animated")
    #     return

    is_array = hasattr(self, "array_length")

    # <<< 1copy (0defassignDP,, $$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
    else:
        dp = pp.path_from_id(self.identifier)
    # >>>
    if is_array:
        index = r_mouse_index(self, index)
        if index is None:
            fcs = [r_action_fc(ob, dp, index=r)  for r in self.vec_range]
            if all(fcs):
                if is_report:
                    report("All indexes already have keyframes")
                return

            def endfn(data):
                if data["is_confirm"] is False or not data["indexes"]: return

                fails = []
                add_indexes = data["indexes"]

                for r, fc in enumerate(fcs):
                    if fc or r not in add_indexes: continue

                    success, ex = add_new_driver(ob, self.rna, pp, index=r, exp=exp, update_push=False)
                    if success is False:
                        fails.append(f'Index {r} failed: {ex}')

                if fails and is_report:
                    DropDownOk(None, MOUSE, input_text='\n'.join(fails))

                update_scene_push("Add Drivers from index(es)")

            call_dd_index_dialog(MOUSE,
                index_range = self.vec_range,
                dark_indexes = {r  for r, e in enumerate(fcs)  if e},
                endfn = endfn,
                title = "Add Driver(s)",
                text = "Add Drivers from index(es)")
            return

        fc = r_action_fc(ob, dp, index=index)
    else:
        fc = r_action_fc(ob, dp)
    if fc:
        if is_report:
            report("Unable to add driver when keyframe already exists")
        return

    if is_array:
        dr = r_driver_fc(ob, dp, index=index)
    else:
        dr = r_driver_fc(ob, dp)
    if dr:
        if not replace:
            if use_editor:
                open_driver_editor_from(ob, dp, index=index)
            return

        ob.animation_data.drivers.remove(dr)

    if is_array:
        success, ex = add_new_driver(ob, self.rna, pp, index=index, exp=exp)
    else:
        success, ex = add_new_driver(ob, self.rna, pp, exp=exp)

    if success is False:
        DropDownOk(None, MOUSE, input_text=f'Failed to add Driver.\n{ex}')
    elif use_editor and P.is_open_driver_editor:
        open_driver_editor_from(ob, dp, index=index)
    #|
@ catch
def c_evt_clear_keyframe(self, index=None, is_report=True, evtkill=True):

    if evtkill: kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    # <<< 1copy (0defassignDP,, $$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
    else:
        dp = pp.path_from_id(self.identifier)
    # >>>

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        if index is None:
            fcs = [r_action_fc(ob, dp, index=r)  for r in self.vec_range]
            s = ""
            if any(fcs):
                for fc in fcs:
                    if fc:
                        success, ex = clear_keyframe(ob, fc, update_push=False)
                        if success is False:
                            s += f'{ex}\n'

                update_scene_push("Clear Keyframe (Array)")
                if s and is_report:
                    DropDownOk(None, MOUSE, input_text=f'Failed to Clear Keyframe(s).\n{s}')
            else:
                if is_report:
                    report("Keyframe not found")
            return
        else:
            fc = r_action_fc(ob, dp, index=index)
            if not fc:
                if is_report:
                    report("Keyframe not found")
                return
    else:
        fc = r_action_fc(ob, dp)
        if not fc:
            if is_report:
                report("Keyframe not found")
            return

    success, ex = clear_keyframe(ob, fc)

    if success is False:
        if is_report:
            DropDownOk(None, MOUSE, input_text=f'Failed to Clear Keyframe.\n{ex}')
    #|
@ catch
def c_evt_delete_keyframe(self, index=None, is_report=True, evtkill=True):

    if evtkill: kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    # <<< 1copy (0defassignDP,, $$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
    else:
        dp = pp.path_from_id(self.identifier)
    # >>>

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        if index is None:
            fcs = [r_action_fc(ob, dp, index=r)  for r in self.vec_range]
            if not any(fcs):
                if is_report:
                    report("Keyframe not found")
                return

            s = ""
            for r, fc in enumerate(fcs):
                if fc:
                    success, ex = del_keyframe(ob, self.rna, pp, index=r, update_push=False)
                    if success is False:
                        s += f'{ex}\n'

            update_scene_push("Clear Keyframe (Array)")
            if s and is_report:
                DropDownOk(None, MOUSE, input_text=f'Failed to Delete Keyframe(s).\n{s}')
            return
        else:
            fc = r_action_fc(ob, dp, index=index)
            if not fc:
                if is_report:
                    report("Keyframe not found")
                return

            success, ex = del_keyframe(ob, self.rna, pp, index=index)
    else:
        fc = r_action_fc(ob, dp)
        if not fc:
            if is_report:
                report("Keyframe not found")
            return

        success, ex = del_keyframe(ob, self.rna, pp)

    if success is False:
        if is_report:
            DropDownOk(None, MOUSE, input_text=f'Failed to Delete Keyframe.\n{ex}')
    #|
@ catch
def c_evt_insert_keyframe(self, index=None, is_report=True, evtkill=True):

    if evtkill: kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return
    # if self.overridden_state != 0:
    #     if is_report: report("Overridden data cannot be animated")
    #     return

    # <<< 1copy (0defassignDP,, $$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
    else:
        dp = pp.path_from_id(self.identifier)
    # >>>

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)
        if index is None:
            drs = [r_driver_fc(ob, dp, index=r)  for r in self.vec_range]
            if all(drs):
                if is_report:
                    report("All indexes already have drivers")
                return

            fails = []

            for r, dr in enumerate(drs):
                if dr: continue
                success, ex = add_new_keyframe(ob, self.rna, pp, index=r, update_push=False)
                if success is False:
                    fails.append(f'Index {r} failed: {ex}')

            if fails and is_report:
                DropDownOk(None, MOUSE, input_text='\n'.join(fails))

            update_scene_push("Add Drivers from index(es)")
            return

        if r_driver_fc(ob, dp, index=index):
            if is_report:
                report("Unable to Insert Keyframe when Driver already exists")
            return

        success, ex = add_new_keyframe(ob, self.rna, pp, index=index)
    else:
        if r_driver_fc(ob, dp):
            if is_report:
                report("Unable to Insert Keyframe when Driver already exists")
            return

        success, ex = add_new_keyframe(ob, self.rna, pp)

    if success is False:
        if is_report:
            DropDownOk(None, MOUSE, input_text=f'Failed to add Keyframe.\n{ex}')
    #|
@ catch
def c_evt_remove_override(self, index=None, is_report=True, evtkill=True):

    if evtkill: kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    dp = r_dp_with(pp, ob, self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier)

    success, v_ref = r_override_value(ob, dp)
    if success is False: return

    if hasattr(self, "array_length"):
        index = r_mouse_index(self, index)

        if index in {None, -1}:
            self.set(v_ref, (0, self.array_length), undo_push=False)

            for e in ob.override_library.properties:
                if e.rna_path == dp:
                    ob.override_library.properties.remove(e)
                    break

            update_scene_push("Remove array override")
        else:
            self.set(v_ref[index], index, undo_push=False)

            if self.get()[:] == v_ref[:]:
                for e in ob.override_library.properties:
                    if e.rna_path == dp:
                        ob.override_library.properties.remove(e)
                        break

            update_scene_push("Remove override")
    else:
        self.set(v_ref, undo_push=False)

        for e in ob.override_library.properties:
            if e.rna_path == dp:
                ob.override_library.properties.remove(e)
                break

        update_scene_push("Remove override")
    #|

@ catch
def c_evt_batch(self):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report=True) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if not hasattr(pp, "bl_rna"): return
    rnas = pp.bl_rna.properties
    if "show_on_cage" not in rnas: return

    button_width_2 = round(D_SIZE['widget_width'] * 1.5)
    md_type = pp.type
    is_comb = hasattr(self.rna, "__len__")
    if is_comb:
        index = self.focus_element[0]
        current_value = self.get(index)
        attr = (self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier)[index]
        dpf = r_dpf_with(pp, ob, attr)
    else:
        current_value = self.get()
        attr = self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier
        dpf = r_dpf_with(pp, ob, attr)

    self_object = ob

    ppp = SimpleNamespace()
    ppp.Use_code = False
    ppp.Affect_selected_objects = True
    ppp.Affect_self_object = False
    ppp.Only_same_type = True
    ppp.Only_same_name = False

    ppp.show_on_cage = False
    ppp.show_in_editmode = False
    ppp.show_viewport = False
    ppp.show_render = False
    ppp.use_apply_on_spline = False

    for at in getattr(ModAttr, md_type, []): setattr(ppp, at, False)
    # for at in getattr(ModRefAttr, md_type, []): setattr(ppp, at, False)
    for at in getattr(ModArrayAttr, md_type, []):
        for r in range(rnas[at].array_length): setattr(ppp, f'{at}{r}', False)

    if hasattr(self, "array_length") and not is_comb:
        if hasattr(self, "focus_element") and self.focus_element != -1:
            index = self.focus_element[0]  if isinstance(self.focus_element, tuple) else self.focus_element
        else:
            index = 0

        setattr(ppp, f'{attr}{index}', True)
        datapath = f'{dpf}[{index}]'
    else:
        setattr(ppp, attr, True)
        datapath = dpf

    def button_fn_cancel(button=None):
        ddw.fin_from_area()
        #|
    def button_fn_run(button=None):


        if ppp.Use_code:
            a0 = ddw.areas[0]
            success, message = eval_batch_operation(self_object, pp, a0.tex.as_string())
            if success:
                ddw.fin_from_area()
                update_scene_push("MD Batch Operation")
                if message: DropDownOk(None, MOUSE, input_text=message)
            else:
                update_scene_push("MD Batch Operation")
                DropDownOk(None, MOUSE, input_text=message)
        else:
            ddw.fin_from_area()

            success, message = eval_batch_operation(self_object, pp,
                r_code_batch_operation(self_object, ppp, datapath, current_value))

            if success:
                update_scene_push("MD Batch Operation")
                if message: DropDownOk(None, MOUSE, input_text=message)
            else:
                update_scene_push("MD Batch Operation")
                DropDownOk(None, MOUSE, input_text=message)
        #|
    def button_set_callback(v=None):
        if ppp.Use_code:
            if bb0_items[0].is_dark() is False:
                for e in bb0_items:
                    if hasattr(e, "dark"): e.dark()
                for e in bb1_items:
                    if hasattr(e, "dark"): e.dark()
                for e in bb2_items:
                    if hasattr(e, "dark"): e.dark()
            return

        if bb0_items[0].is_dark() is True:
            for e in bb0_items:
                if hasattr(e, "light"): e.light()
            for e in bb1_items:
                if hasattr(e, "light"): e.light()
            for e in bb2_items:
                if hasattr(e, "light"): e.light()

        a0 = ddw.areas[0]
        a0.evt_del_all(undo_push=False, evtkill=False)
        a0.beam_input_unpush(r_code_batch_operation(self_object, ppp, datapath, current_value))
        #|
    def r_button_width(): return button_width_2

    gap = SIZE_button[1]
    BlockUtil.DEFAULT_FOLD_STATE = False

    area_items = []
    button_run = ButtonFn(None, RNA_run, button_fn_run)
    button_cancel = ButtonFn(None, RNA_cancel, button_fn_cancel)

    ddw = DropDownInfoUtil(self, MOUSE,
        [ButtonSplit(None, button_run, button_cancel, gap)],
        area_items = area_items,
        title = "Batch Operation",
        input_text = r_code_batch_operation(self_object, ppp, datapath, current_value),
        font_id=FONT1, row_count=11, width_fac=4.0, block_size=14)

    area_tab = ddw.r_area_tab()

    b0 = Blocks(area_tab)
    bb0 = BlockUtil(b0, None, Title("Effects"))
    bb0.area = area_tab
    bb1 = BlockUtil(b0, None, Title("Visibility"))
    bb1.area = area_tab
    bb2 = BlockUtil(b0, None, Title("Attributes"))
    bb2.area = area_tab
    g_use_code = ButtonGroupAlignTitleLeft(b0, ButtonBoolTemp(None, RnaBool("Use_code", "Override Code"), ppp))
    g_use_code.button0.set_callback = button_set_callback
    b0.buttons = [g_use_code, bb0, bb1, bb2]

    bb0_items = [
        ButtonGroupAlignL(bb0, ButtonBoolTemp(None, RnaBool("Affect_selected_objects", "Selected Objects"), ppp)),
        ButtonGroupAlignL(bb0, ButtonBoolTemp(None, RnaBool("Affect_self_object", "Self Object"), ppp)),
        ButtonSep(3),
        ButtonGroupAlignLR(bb0, ButtonBoolTemp(None, RnaBool("Only_same_type", "Same Modifier Type"), ppp), title_head="Only"),
        ButtonGroupAlignL(bb0, ButtonBoolTemp(None, RnaBool("Only_same_name", "Same Modifier Name"), ppp)),
    ]
    for r in {0, 1, 3, 4}:
        e = bb0_items[r]
        e.r_button_width = r_button_width
        e.button0.set_callback = button_set_callback
    bb0.items = bb0_items

    bb1_items = [
        ButtonGroupAlignLR(bb1, ButtonBoolTemp(None, RnaBool("show_on_cage", "On Cage"), ppp), title_head = "Show"),
        ButtonGroupAlignL(bb1, ButtonBoolTemp(None, RnaBool("show_in_editmode", "Edit Mode"), ppp)),
        ButtonGroupAlignL(bb1, ButtonBoolTemp(None, RnaBool("show_viewport", "Viewport"), ppp)),
        ButtonGroupAlignL(bb1, ButtonBoolTemp(None, RnaBool("show_render", "Render"), ppp)),
        ButtonSep(3),
        ButtonGroupAlignL(bb1, ButtonBoolTemp(None, RnaBool("use_apply_on_spline", "Apply on Spline"), ppp)),
    ]
    for r in {0, 1, 2, 3, 5}:
        e = bb1_items[r]
        e.r_button_width = r_button_width
        e.button0.set_callback = button_set_callback
    bb1.items = bb1_items
    bb2_items = []
    for at in getattr(ModAttr, md_type, []):
        e = ButtonGroupAlignL(bb2, ButtonBoolTemp(None, RnaBool(at, rnas[at].name), ppp))
        e.r_button_width = r_button_width
        e.button0.set_callback = button_set_callback
        bb2_items.append(e)

    bb2_items.append(ButtonSep(3))
    # for at in getattr(ModRefAttr, md_type, []):
    #     e = ButtonGroupAlignL(bb2, ButtonBoolTemp(None, RnaBool(at, rnas[at].name), ppp))
    #     e.r_button_width = r_button_width
    #     e.button0.set_callback = button_set_callback
    #     bb2_items.append(e)

    bb2_items.append(ButtonSep(3))
    for at in getattr(ModArrayAttr, md_type, []):
        r = 0
        e = ButtonGroupAlignLR(bb2, ButtonBoolTemp(None, RnaBool(f'{at}{r}', f'{rnas[at].name} [{r}]'), ppp), title=str(r), title_head=rnas[at].name)
        e.r_button_width = r_button_width
        e.button0.set_callback = button_set_callback
        bb2_items.append(e)

        for r in range(1, rnas[at].array_length):
            e = ButtonGroupAlignL(bb2, ButtonBoolTemp(None, RnaBool(f'{at}{r}', f'{rnas[at].name} [{r}]'), ppp), title=str(r))
            e.r_button_width = r_button_width
            e.button0.set_callback = button_set_callback
            bb2_items.append(e)

        bb2_items.append(ButtonSep(3))

    bb2.items = bb2_items

    area_items.append(b0)
    area_tab.init_items_tab()
    #|


@ catch
def c_evt_area_copy_COMB(self, index=None, is_report=True):

    kill_evt_except()
    if index is None: index = self.focus_element[0]

    s = "1"  if self.get(index) else "0"
    bpy.context.window_manager.clipboard = s
    if is_report: report("Copy to Clipboard")
    #|
@ catch
def c_evt_area_cut_COMB(self, index=None, is_report=True):

    kill_evt_except()

    s = ", ".join(("1"  if self.get(r) else "0")  for r, _ in enumerate(self.rna))
    bpy.context.window_manager.clipboard = s
    if is_report: report("Copy List to Clipboard")
    #|
@ catch
def c_evt_area_paste_COMB(self, index=None, is_report=True):

    kill_evt_except()
    if self.isdark is True and self.isdarkhard is True: return

    s = bpy.context.window_manager.clipboard.strip()
    if not s:
        if is_report: report("Clipboard is Empty")
        return

    if s.startswith(";") and not s.startswith(";;"):
        try:
            if index is None: index = self.focus_element[0]
            self.set(s, index)
        except:
            if is_report: report("Invalid Input")
        return
    if s.startswith("#"):
        if index is None: index = self.focus_element[0]
        self.set(s, index)
        return

    if s in {'True', 'true', '1', '1.0'}:
        if index is None: index = self.focus_element[0]
        self.set(True, index)
        return
    elif s in {'False', 'false', '0', '0.0'}:
        if index is None: index = self.focus_element[0]
        self.set(False, index)
        return

    for v, r in zip(calc_vec(s), range(len(self.rna))):
        self.set(v, r, undo_push=False)

    update_scene_push(f'Paste list : {self.blf_title.text}')
    #|
@ catch
def c_evt_area_reset_single_COMB(self, index=None, is_report=True):

    kill_evt_except()
    if self.isdark is True and self.isdarkhard is True: return

    pp = self.r_pp()
    self.pp = pp
    if not pp: return

    if index is None: index = self.focus_element[0]

    if is_value_overridden(pp, pp.id_data, (self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier)[index]):
        self.evt_remove_override(index=index, is_report=is_report)
        return

    self.set(self.r_default_value(index), index)
    #|
@ catch
def c_evt_area_reset_all_COMB(self, index=None, is_report=True):

    kill_evt_except()
    if self.isdark is True and self.isdarkhard is True: return

    pp = self.r_pp()
    self.pp = pp
    if not pp: return

    if any(is_value_overridden(pp, pp.id_data, ident)  for ident in self.identifier):
        self.evt_remove_override(index=-1, is_report=is_report)
        return

    for r in range(len(self.rna)):
        self.set(self.r_default_value(r), r, undo_push=False)

    update_scene_push(f'Reset list : {self.blf_title.text}')
    #|
@ catch
def c_evt_area_format_COMB(self, index=None, is_report=True):

    kill_evt_except()
    #|
@ catch
def c_evt_area_detail_COMB(self, is_report=True):

    kill_evt_except()
    Detail(Detail.r_rna_info(self.rna[self.focus_element[0]]))
    #|
@ catch
def c_evt_remove_from_keying_set_COMB(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if index in {None, -1}: index = self.focus_element[0]

    # <<< 1copy (0defassignDP,, ${'.identifier)':'.identifier[index])', 'self.identifier_escape':'self.identifier_escape[index]'}$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape[index]}'
    else:
        dp = pp.path_from_id(self.identifier[index])
    # >>>

    success, s = r_remove_from_keying_set(ob, dp)
    if s:
        DropDownOk(None, MOUSE, input_text=s)
    #|
@ catch
def c_evt_add_to_keying_set_COMB(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if index in {None, -1}: index = self.focus_element[0]

    if not self.rna[index].is_animatable:
        if is_report:
            report(f'Property {self.identifier[index]} cannot be animated')
        return

    # <<< 1copy (0defassignDP,, ${'.identifier)':'.identifier[index])', 'self.identifier_escape':'self.identifier_escape[index]'}$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape[index]}'
    else:
        dp = pp.path_from_id(self.identifier[index])
    # >>>

    success, s = r_add_to_keying_set(ob, dp)
    if s:
        DropDownOk(None, MOUSE, input_text=s)
    #|
@ catch
def c_evt_copy_full_data_path_COMB(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data

    if index is None: index = self.focus_element[0]

    dp = r_dpf_with(pp, ob, self.identifier[index])

    bpy.context.window_manager.clipboard = dp
    if is_report:
        report("Full Data Path is copied to the clipboard")
    #|
@ catch
def c_evt_copy_data_path_COMB(self, index=None, is_report=True, full=False):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data

    if index is None: index = self.focus_element[0]

    dp = r_dp_with(pp, ob, self.identifier[index])

    bpy.context.window_manager.clipboard = dp
    if is_report:
        report("Data Path is copied to the clipboard")
    #|
@ catch
def c_evt_paste_full_data_path_as_driver_COMB(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return
    # if self.overridden_state != 0:
    #     if is_report: report("Overridden data cannot be animated")
    #     return

    if index is None: index = self.focus_element[0]

    if not self.rna[index].is_animatable:
        if is_report:
            report(f'Property {self.identifier[index]} cannot be animated')
        return

    # <<< 1copy (0defassignDP,, ${'.identifier)':'.identifier[index])', 'self.identifier_escape':'self.identifier_escape[index]'}$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape[index]}'
    else:
        dp = pp.path_from_id(self.identifier[index])
    # >>>

    fdp = bpy.context.window_manager.clipboard.strip()
    if not fdp.startswith("bpy.data."):
        if is_report:
            report("Invalid Path")
        return

    fc = r_action_fc(ob, dp)
    if fc:
        if is_report:
            report("Unable to add driver when keyframe already exists")
        return

    dr_index = None
    dr = r_driver_fc(ob, dp)

    success, ex = paste_full_data_path_as_driver_safe(
        fdp,
        dr,
        "",
        ob,
        self.rna[index],
        pp,
        index = dr_index)

    if success is False:
        if is_report:
            DropDownOk(None, MOUSE, input_text=f'Failed to add Driver.\n{ex}')
    #|
@ catch
def c_evt_delete_driver_COMB(self, index=None, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if r_library_editable(ob) is False:
        if is_report:
            report(r_library_or_override_message(ob))
        return

    if index is None: index = self.focus_element[0]

    if self.rna[index].is_animatable:
        # <<< 1copy (0defassignDP,, ${'.identifier)':'.identifier[index])', 'self.identifier_escape':'self.identifier_escape[index]'}$)
        if hasattr(self, "identifier_escape"):
            dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape[index]}'
        else:
            dp = pp.path_from_id(self.identifier[index])
        # >>>

        dr = r_driver_fc(ob, dp)
        if dr is None:
            if is_report:
                report("Driver not found")
            return

        ob.animation_data.drivers.remove(dr)
        update_scene_push("Delete Driver")
        self.set(self.get(index), index, undo_push=False)
    #|
@ catch
def c_evt_add_driver_COMB(self, index=None, is_report=True, exp="var", replace=False, use_editor=False):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return
    # if self.overridden_state != 0:
    #     if is_report: report("Overridden data cannot be animated")
    #     return

    if index is None: index = self.focus_element[0]

    # <<< 1copy (0defassignDP,, ${'.identifier)':'.identifier[index])', 'self.identifier_escape':'self.identifier_escape[index]'}$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape[index]}'
    else:
        dp = pp.path_from_id(self.identifier[index])
    # >>>
    fc = r_action_fc(ob, dp)
    if fc:
        if is_report:
            report("Unable to add driver when keyframe already exists")
        return

    dr = r_driver_fc(ob, dp)
    if dr:
        if not replace:
            if use_editor:
                open_driver_editor_from(ob, dp)
            return

        ob.animation_data.drivers.remove(dr)

    success, ex = add_new_driver(ob, self.rna[index], pp, exp=exp)

    if success is False:
        DropDownOk(None, MOUSE, input_text=f'Failed to add Driver.\n{ex}')
    elif use_editor and P.is_open_driver_editor:
        open_driver_editor_from(ob, dp)
    #|
@ catch
def c_evt_clear_keyframe_COMB(self, index=None, is_report=True, evtkill=True):

    if evtkill: kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if index is None: index = self.focus_element[0]

    # <<< 1copy (0defassignDP,, ${'.identifier)':'.identifier[index])', 'self.identifier_escape':'self.identifier_escape[index]'}$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape[index]}'
    else:
        dp = pp.path_from_id(self.identifier[index])
    # >>>

    fc = r_action_fc(ob, dp)
    if not fc:
        if is_report:
            report("Keyframe not found")
        return

    success, ex = clear_keyframe(ob, fc)

    if success is False:
        if is_report:
            DropDownOk(None, MOUSE, input_text=f'Failed to Clear Keyframe.\n{ex}')
    #|
@ catch
def c_evt_delete_keyframe_COMB(self, index=None, is_report=True, evtkill=True):

    if evtkill: kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if index is None: index = self.focus_element[0]

    # <<< 1copy (0defassignDP,, ${'.identifier)':'.identifier[index])', 'self.identifier_escape':'self.identifier_escape[index]'}$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape[index]}'
    else:
        dp = pp.path_from_id(self.identifier[index])
    # >>>

    fc = r_action_fc(ob, dp)
    if not fc:
        if is_report:
            report("Keyframe not found")
        return

    success, ex = del_keyframe(ob, self.rna[index], pp)

    if success is False:
        if is_report:
            DropDownOk(None, MOUSE, input_text=f'Failed to Delete Keyframe.\n{ex}')
    #|
@ catch
def c_evt_insert_keyframe_COMB(self, index=None, is_report=True, evtkill=True):

    if evtkill: kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return
    # if self.overridden_state != 0:
    #     if is_report: report("Overridden data cannot be animated")
    #     return

    if index is None: index = self.focus_element[0]

    # <<< 1copy (0defassignDP,, ${'.identifier)':'.identifier[index])', 'self.identifier_escape':'self.identifier_escape[index]'}$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape[index]}'
    else:
        dp = pp.path_from_id(self.identifier[index])
    # >>>

    if r_driver_fc(ob, dp):
        if is_report:
            report("Unable to Insert Keyframe when Driver already exists")
        return

    success, ex = add_new_keyframe(ob, self.rna[index], pp)

    if success is False:
        if is_report:
            DropDownOk(None, MOUSE, input_text=f'Failed to add Keyframe.\n{ex}')
    #|
@ catch
def c_evt_remove_override_COMB(self, index=None, is_report=True, evtkill=True):

    if evtkill: kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if index in {None, -1}:
        any_success = False

        for r in range(len(self.rna)):
            dp = r_dp_with(pp, ob, self.identifier[r])
            success, v_ref = r_override_value(ob, dp)
            if success is False: continue

            any_success = True
            self.set(v_ref, r, undo_push=False)

            for e in ob.override_library.properties:
                if e.rna_path == dp:
                    ob.override_library.properties.remove(e)
                    break

        if any_success:
            update_scene_push("Remove list override")
    else:
        if index is None: index = self.focus_element[0]
        dp = r_dp_with(pp, ob, self.identifier[index])

        success, v_ref = r_override_value(ob, dp)
        if success is False: return

        self.set(v_ref, index, undo_push=False)

        for e in ob.override_library.properties:
            if e.rna_path == dp:
                ob.override_library.properties.remove(e)
                break

        update_scene_push("Remove override")
    #|

@ catch
def c_evt_edit_default_value(self, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return

    if hasattr(self.rna, "data") and hasattr(self.rna.data, "default_value_path"):
        default_value_path = self.rna.data.default_value_path
        if isinstance(default_value_path, tuple):
            true_ids = {"id", "editor"}
            default_value_path = default_value_path[1]
        else:
            true_ids = {"id", "general"}

        m.D_EDITOR["SettingEditor"].open_search(default_value_path, true_ids=true_ids)
    #|
@ catch
def c_evt_attr_toggle(self, is_report=True):

    kill_evt_except()
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    if self.rna.use_attribute:
        identifier = self.identifier[ : -15]
    else:
        identifier = self.identifier

    with bpy.context.temp_override(object=ob):
        bpy.ops.object.geometry_nodes_input_attribute_toggle(
            input_name=identifier, modifier_name=pp.name)
    update_scene_push("Input Attribute Toggle")
    #|


def c_to_modal_rm(self):

    pp = self.r_pp()
    self.pp = pp
    if not pp: return

    identifier = self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier
    ty = self.rna.type
    override_name = {}
    override_icon = {}

    if hasattr(self.rna, "data") and hasattr(self.rna.data, "default_value_path"):
        rna_data = self.rna.data
        items = [
            ("dd_paste", self.evt_area_paste),
            ("dd_copy", self.evt_area_copy),
            ("valbox_reset_single", self.evt_area_reset_single),
            ("detail", self.evt_area_detail),
        ]
        items.append(("Edit Default Value", lambda: c_evt_edit_default_value(self)))
        DropDownRMKeymap(self, MOUSE, items, title=self.rna.name, override_name=override_name, override_icon=override_icon)
        return

    if ty in {"ENUM", "POINTER"}:
        items = [("dd_cut", self.evt_area_cut)]
        override_name["dd_cut"] = "Copy Identifier"
    else:
        items = []

    if self.rna.is_animatable:
        if self.isdark is True and self.isdarkhard is True:
            items += [
                ("dd_copy", self.evt_area_copy),
                ("detail", self.evt_area_detail),
                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
            ]
        elif self.overridden_state == 0:
            items += [
                ("dd_paste", self.evt_area_paste),
                ("dd_copy", self.evt_area_copy),
                ("valbox_reset_single", self.evt_area_reset_single),
                ("detail", self.evt_area_detail),

                ("ui_remove_from_keying_set", self.evt_remove_from_keying_set),
                ("ui_add_to_keying_set", self.evt_add_to_keying_set),
                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
                ("ui_paste_full_data_path_as_driver", self.evt_paste_full_data_path_as_driver),
                ("ui_delete_driver", self.evt_delete_driver),
                ("ui_add_driver", lambda: self.evt_add_driver(use_editor=True)),
                ("ui_clear_keyframe", self.evt_clear_keyframe),
                ("ui_delete_keyframe", self.evt_delete_keyframe),
                ("ui_insert_keyframe", self.evt_insert_keyframe),
            ]
        else: #OVerride
            items += [
                ("dd_paste", self.evt_area_paste),
                ("dd_copy", self.evt_area_copy),
                ("valbox_reset_single", self.evt_area_reset_single),
                ("detail", self.evt_area_detail),

                ("ui_remove_from_keying_set", self.evt_remove_from_keying_set),
                ("ui_add_to_keying_set", self.evt_add_to_keying_set),
                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
                ("ui_paste_full_data_path_as_driver", self.evt_paste_full_data_path_as_driver),
                ("ui_delete_driver", self.evt_delete_driver),
                ("ui_add_driver", lambda: self.evt_add_driver(use_editor=True)),
                ("ui_clear_keyframe", self.evt_clear_keyframe),
                ("ui_delete_keyframe", self.evt_delete_keyframe),
                ("ui_insert_keyframe", self.evt_insert_keyframe),
            ]
            if is_value_overridden(pp, pp.id_data, identifier, index=None):
                override_icon["valbox_reset_single"] = GpuImg_reset_override
                override_name["valbox_reset_single"] = "Remove Override"
    else:
        if self.isdark is True and self.isdarkhard is True:
            items += [
                ("dd_copy", self.evt_area_copy),
                ("detail", self.evt_area_detail),
                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
            ]
        elif self.overridden_state == 0:
            items += [
                ("dd_paste", self.evt_area_paste),
                ("dd_copy", self.evt_area_copy),
                ("valbox_reset_single", self.evt_area_reset_single),
                ("detail", self.evt_area_detail),

                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
            ]
        else: #OVerride
            items += [
                ("dd_paste", self.evt_area_paste),
                ("dd_copy", self.evt_area_copy),
                ("valbox_reset_single", self.evt_area_reset_single),
                ("detail", self.evt_area_detail),

                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
            ]
            if is_value_overridden(pp, pp.id_data, identifier, index=None):
                override_icon["valbox_reset_single"] = GpuImg_reset_override
                override_name["valbox_reset_single"] = "Remove Override"

    if hasattr(self.rna, "subtype") and self.rna.subtype == "ANGLE":
        items.append(("ui_format_toggle", self.evt_area_format))
    if hasattr(self, "evt_attr_toggle"):
        items.append(("ui_attr_toggle", self.evt_attr_toggle))
    items.append(("ui_batch", self.evt_batch))

    if ty == "POINTER":
        ob = self.get()
        is_lib_editable = r_library_editable(ob)
        idtype = r_id_type(ob)

        if hasattr(ob, "visible_get"):
            items.append(("ui_jump_to_target", self.evt_jump_to_target))
        if hasattr(ob, "asset_data") and idtype in S_ALLOW_ASSET and is_lib_editable:
            items.append(("ui_mark_asset", self.evt_mark_asset))
            if ob.asset_data:
                override_name["ui_mark_asset"] = "Clear Asset"
            else:
                override_name["ui_mark_asset"] = "Mark as Asset"
                override_icon["ui_mark_asset"] = GpuImg_ASSET_MANAGER
        if idtype in S_ALLOW_PREVIEW:
            items.append(("dd_preview", self.evt_area_preview))

    append_rm_item_operator(items, self.rna)

    DropDownRMKeymap(self, MOUSE, items, title=self.rna.name, override_name=override_name, override_icon=override_icon)
    #|
def c_to_modal_rm_vec(self):

    pp = self.r_pp()
    self.pp = pp
    if not pp: return

    if not hasattr(self, "focus_element"): return
    index = r_mouse_index(self, None)
    identifier = self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier

    override_name = {
        "dd_cut": "Copy Array",
    }
    override_icon = {
        "dd_cut": GpuImg_copy_array,
    }

    if self.rna.is_animatable:
        if self.isdarkhard is True:
            items = [
                ("dd_cut", self.evt_area_cut),
                ("dd_copy", lambda: self.evt_area_copy(index=index)),
                ("detail", self.evt_area_detail),
                ("ui_copy_full_data_path", lambda: self.evt_copy_full_data_path(index=index)),
                ("ui_copy_data_path", lambda: self.evt_copy_data_path(index=index)),
            ]
        elif self.overridden_state == 0:
            items = [
                ("dd_paste", lambda: self.evt_area_paste(index=index)),
                ("dd_cut", self.evt_area_cut),
                ("dd_copy", lambda: self.evt_area_copy(index=index)),
                ("valbox_reset_all", self.evt_area_reset_all),
                ("valbox_reset_single", lambda: self.evt_area_reset_single(index=index)),
                ("detail", self.evt_area_detail),

                ("ui_remove_from_keying_set_all", lambda: self.evt_remove_from_keying_set(index=-1)),
                ("ui_add_to_keying_set_all", lambda: self.evt_add_to_keying_set(index=-1)),
                ("ui_remove_from_keying_set", lambda: self.evt_remove_from_keying_set(index=index)),
                ("ui_add_to_keying_set", lambda: self.evt_add_to_keying_set(index=index)),
                ("ui_copy_full_data_path", lambda: self.evt_copy_full_data_path(index=index)),
                ("ui_copy_data_path", lambda: self.evt_copy_data_path(index=index)),
                ("ui_paste_full_data_path_as_driver", lambda: self.evt_paste_full_data_path_as_driver(index=index)),
                ("ui_delete_driver", lambda: self.evt_delete_driver(index=index)),
                ("ui_add_driver", lambda: self.evt_add_driver(index=index, use_editor=True)),
                ("ui_clear_keyframe", lambda: self.evt_clear_keyframe(index=index)),
                ("ui_delete_keyframe", lambda: self.evt_delete_keyframe(index=index)),
                ("ui_insert_keyframe", lambda: self.evt_insert_keyframe(index=index)),
            ]
        else: #OVerride
            items = [
                ("dd_paste", lambda: self.evt_area_paste(index=index)),
                ("dd_cut", self.evt_area_cut),
                ("dd_copy", lambda: self.evt_area_copy(index=index)),
                ("valbox_reset_all", self.evt_area_reset_all),
                ("valbox_reset_single", lambda: self.evt_area_reset_single(index=index)),
                ("detail", self.evt_area_detail),

                ("ui_remove_from_keying_set_all", lambda: self.evt_remove_from_keying_set(index=-1)),
                ("ui_add_to_keying_set_all", lambda: self.evt_add_to_keying_set(index=-1)),
                ("ui_remove_from_keying_set", lambda: self.evt_remove_from_keying_set(index=index)),
                ("ui_add_to_keying_set", lambda: self.evt_add_to_keying_set(index=index)),
                ("ui_copy_full_data_path", lambda: self.evt_copy_full_data_path(index=index)),
                ("ui_copy_data_path", lambda: self.evt_copy_data_path(index=index)),
                ("ui_paste_full_data_path_as_driver", lambda: self.evt_paste_full_data_path_as_driver(index=index)),
                ("ui_delete_driver", lambda: self.evt_delete_driver(index=index)),
                ("ui_add_driver", lambda: self.evt_add_driver(index=index, use_editor=True)),
                ("ui_clear_keyframe", lambda: self.evt_clear_keyframe(index=index)),
                ("ui_delete_keyframe", lambda: self.evt_delete_keyframe(index=index)),
                ("ui_insert_keyframe", lambda: self.evt_insert_keyframe(index=index)),
            ]
            if is_value_overridden(pp, pp.id_data, identifier, index=index):
                override_icon["valbox_reset_single"] = GpuImg_reset_override
                override_name["valbox_reset_single"] = "Remove Override"
            if is_value_overridden(pp, pp.id_data, identifier, index=None):
                override_name["valbox_reset_all"] = "Remove Array Override"
    else:
        if self.isdarkhard is True:
            items = [
                ("dd_cut", self.evt_area_cut),
                ("dd_copy", lambda: self.evt_area_copy(index=index)),
                ("detail", self.evt_area_detail),
                ("ui_copy_full_data_path", lambda: self.evt_copy_full_data_path(index=index)),
                ("ui_copy_data_path", lambda: self.evt_copy_data_path(index=index)),
            ]
        elif self.overridden_state == 0:
            items = [
                ("dd_paste", lambda: self.evt_area_paste(index=index)),
                ("dd_cut", self.evt_area_cut),
                ("dd_copy", lambda: self.evt_area_copy(index=index)),
                ("valbox_reset_all", self.evt_area_reset_all),
                ("valbox_reset_single", lambda: self.evt_area_reset_single(index=index)),
                ("detail", self.evt_area_detail),

                ("ui_copy_full_data_path", lambda: self.evt_copy_full_data_path(index=index)),
                ("ui_copy_data_path", lambda: self.evt_copy_data_path(index=index)),
            ]
        else: #OVerride
            items = [
                ("dd_paste", lambda: self.evt_area_paste(index=index)),
                ("dd_cut", self.evt_area_cut),
                ("dd_copy", lambda: self.evt_area_copy(index=index)),
                ("valbox_reset_all", self.evt_area_reset_all),
                ("valbox_reset_single", lambda: self.evt_area_reset_single(index=index)),
                ("detail", self.evt_area_detail),

                ("ui_copy_full_data_path", lambda: self.evt_copy_full_data_path(index=index)),
                ("ui_copy_data_path", lambda: self.evt_copy_data_path(index=index)),
            ]
            if is_value_overridden(pp, pp.id_data, identifier, index=index):
                override_icon["valbox_reset_single"] = GpuImg_reset_override
                override_name["valbox_reset_single"] = "Remove Override"
            if is_value_overridden(pp, pp.id_data, identifier, index=None):
                override_name["valbox_reset_all"] = "Remove Array Override"

    if hasattr(self.rna, "subtype") and self.rna.subtype == "ANGLE":
        items.append(("ui_format_toggle", self.evt_area_format))
    if hasattr(self, "evt_attr_toggle"):
        items.append(("ui_attr_toggle", self.evt_attr_toggle))
    items.append(("ui_batch", self.evt_batch))
    append_rm_item_operator(items, self.rna)

    DropDownRMKeymap(self, MOUSE, items, title=self.rna.name, override_name=override_name, override_icon=override_icon)
    #|
def c_to_modal_rm_COMB(self):

    pp = self.r_pp()
    self.pp = pp
    if not pp: return

    if hasattr(self, "focus_element") and isinstance(self.focus_element, tuple): pass
    else: return

    index = self.focus_element[0]
    identifier = self.identifier_escape  if hasattr(self, "identifier_escape") else self.identifier
    rna = self.rna[index]

    override_name = {}
    override_icon = {}
    items = []

    if rna.is_animatable:
        if self.isdark is True and self.isdarkhard is True:
            items += [
                ("dd_copy", self.evt_area_copy),
                ("detail", self.evt_area_detail),
                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
            ]
        elif self.overridden_state == 0:
            items += [
                ("dd_paste", self.evt_area_paste),
                ("dd_copy", self.evt_area_copy),
                ("valbox_reset_single", self.evt_area_reset_single),
                ("detail", self.evt_area_detail),

                ("ui_remove_from_keying_set", self.evt_remove_from_keying_set),
                ("ui_add_to_keying_set", self.evt_add_to_keying_set),
                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
                ("ui_paste_full_data_path_as_driver", self.evt_paste_full_data_path_as_driver),
                ("ui_delete_driver", self.evt_delete_driver),
                ("ui_add_driver", lambda: self.evt_add_driver(use_editor=True)),
                ("ui_clear_keyframe", self.evt_clear_keyframe),
                ("ui_delete_keyframe", self.evt_delete_keyframe),
                ("ui_insert_keyframe", self.evt_insert_keyframe),
            ]
        else: #OVerride
            items += [
                ("dd_paste", self.evt_area_paste),
                ("dd_copy", self.evt_area_copy),
                ("valbox_reset_single", self.evt_area_reset_single),
                ("detail", self.evt_area_detail),

                ("ui_remove_from_keying_set", self.evt_remove_from_keying_set),
                ("ui_add_to_keying_set", self.evt_add_to_keying_set),
                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
                ("ui_paste_full_data_path_as_driver", self.evt_paste_full_data_path_as_driver),
                ("ui_delete_driver", self.evt_delete_driver),
                ("ui_add_driver", lambda: self.evt_add_driver(use_editor=True)),
                ("ui_clear_keyframe", self.evt_clear_keyframe),
                ("ui_delete_keyframe", self.evt_delete_keyframe),
                ("ui_insert_keyframe", self.evt_insert_keyframe),
            ]
            if is_value_overridden(pp, pp.id_data, identifier[index], index=None):
                override_icon["valbox_reset_single"] = GpuImg_reset_override
                override_name["valbox_reset_single"] = "Remove Override"
    else:
        if self.isdark is True and self.isdarkhard is True:
            items += [
                ("dd_copy", self.evt_area_copy),
                ("detail", self.evt_area_detail),
                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
            ]
        elif self.overridden_state == 0:
            items += [
                ("dd_paste", self.evt_area_paste),
                ("dd_copy", self.evt_area_copy),
                ("valbox_reset_single", self.evt_area_reset_single),
                ("detail", self.evt_area_detail),

                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
            ]
        else: #OVerride
            items += [
                ("dd_paste", self.evt_area_paste),
                ("dd_copy", self.evt_area_copy),
                ("valbox_reset_single", self.evt_area_reset_single),
                ("detail", self.evt_area_detail),

                ("ui_copy_full_data_path", self.evt_copy_full_data_path),
                ("ui_copy_data_path", self.evt_copy_data_path),
            ]
            if is_value_overridden(pp, pp.id_data, identifier[index], index=None):
                override_icon["valbox_reset_single"] = GpuImg_reset_override
                override_name["valbox_reset_single"] = "Remove Override"

    items.append(("ui_batch", self.evt_batch))
    append_rm_item_operator(items, rna)

    DropDownRMKeymap(self, MOUSE, items, title=rna.name, override_name=override_name, override_icon=override_icon)
    #|

@ catch
def c_bufn_keyframe(self, is_report=True):

    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, is_report) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    # <<< 1copy (0defassignDP,, $$)
    if hasattr(self, "identifier_escape"):
        dp = f'{self.ui_anim_data.r_dph()}{self.identifier_escape}'
    else:
        dp = pp.path_from_id(self.identifier)
    # >>>

    is_array = hasattr(self, "array_length")
    index = r_mouse_index(self, None)  if is_array else None

    if hasattr(ob, "override_library") and hasattr(ob.override_library, "reference"):
        ref = ob.override_library.reference
        v_ref = ref.path_resolve(dp)
        if is_array:
            if v_ref[index] != self.get()[index]:
                self.evt_remove_override(index=index, is_report=is_report, evtkill=False)
                return
        else:
            if v_ref != self.get():
                self.evt_remove_override(is_report=is_report, evtkill=False)
                return

    if not self.rna.is_animatable: return

    dr = r_driver_fc(ob, dp, index=index)
    if dr:
        DropDownYesNo(None, MOUSE, lambda: self.evt_delete_driver(index=index, is_report=is_report), input_text="Do you want to delete the Driver?")
    else:
        fc = r_action_fc(ob, dp, index=index)
        if fc:
            kp = fc.keyframe_points
            ind_E = len(kp) -1
            r = bpy.context.scene.frame_current
            if bin_search(0, ind_E, r, lambda x: kp[x].co[0], lambda x: None) == None:
                self.evt_insert_keyframe(index=index, is_report=is_report, evtkill=False)
            else:
                self.evt_delete_keyframe(index=index, is_report=is_report, evtkill=False)
        else:
            self.evt_insert_keyframe(index=index, is_report=is_report, evtkill=False)
    #|
def c_bufn_keyframe_group(self):

    self.focus_element = -1
    pp = self.r_pp()
    self.pp = pp
    if not pp: return
    ob = pp.id_data
    if ui_poll_library(ob, True) is False: return

    if self.isdark is True and self.isdarkhard is True: return

    DDKeyframeGroup(self)
    #|

def c_get(self):
    # <<< 1copy (0defuiGet,, $$)
    return getattr(self.pp, self.identifier)
    # >>>
    #|
def c_set(self, v, refresh=True, undo_push=True):
    # <<< 1copy (0defuiSet,, $$)
    # <<< 1copy (0defuiSetDriverEval,, $$)
    if isinstance(v, str):
        # v = v.strip()
        if v.startswith("#"):
            v = v[1 : ]
            if v.startswith("#"): pass
            else:
                self.evt_add_driver(exp=v, replace=True)
                return
        elif v.startswith(";"):
            v = v[1 : ]
            if v.startswith(";"): pass
            else:
                v = bpyeval(v)
    # >>>

    setattr(self.pp, self.identifier, v)

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_data()

    if undo_push:
        ed_undo_push(message=f'{self.rna.name} : {getattr(self.pp, self.identifier)}')
    # >>>
    #|
def c_set_vec(self, v, index, refresh=True, undo_push=True):
    # <<< 1copy (0defuiSetvec,, $$)
    if isinstance(index, int):
        if isinstance(v, str):
            v = v.strip()
            if v.startswith("#"):
                self.evt_add_driver(index=index, exp=v[1 :], replace=True)
                return
            elif v.startswith(";"):
                v = v[1 : ]
                if v.startswith(";"): pass
                else:
                    v = bpyeval(v)
    else:
        if isinstance(v[0], str) and v[0].startswith("#"):
            i = index[0]
            for v in v:
                self.evt_add_driver(index=i, exp=v[1 :], replace=True)
                i += 1
            return

    array = getattr(self.pp, self.identifier)

    if isinstance(index, int): array[index] = v
    else:
        l = list(array)
        l[index[0] : index[1]] = v
        array[:] = l
        # crash when array is EULER
        # array[index[0] : index[1]] = v

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_data()

    if undo_push:
        s = ", ".join(f"{v:.4f}"  for v in getattr(self.pp, self.identifier))
        ed_undo_push(message=f'{self.rna.name} : {s}')
    # >>>
    #|
def c_set_str(self, v, refresh=True, undo_push=True):
    # <<< 1copy (0defuiSetStr,, $$)
    if isinstance(v, str):
        if v.startswith(";"):
            v = v[1 : ]
            if v.startswith(";"): pass
            else:
                v = bpyeval(v)

    setattr(self.pp, self.identifier, v)

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_data()

    if undo_push:
        ed_undo_push(message=f'{self.rna.name} : {getattr(self.pp, self.identifier)}')
    # >>>
    #|
def c_get_comb(self, index):
    # <<< 1copy (0defuiGetComb,, $$)
    return getattr(self.pp, self.identifier[index])
    # >>>
    #|
def c_set_comb(self, v, index, refresh=True, undo_push=True):
    # <<< 1copy (0defuiSetComb,, $$)
    if isinstance(v, str):
        v = v.strip()
        if v.startswith("#"):
            self.evt_add_driver(index=index, exp=v[1 :], replace=True)
            return
        elif v.startswith(";"):
            v = v[1 : ]
            if v.startswith(";"): pass
            else:
                v = bpyeval(v)

    setattr(self.pp, self.identifier[index], v)

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_data()

    if undo_push:
        ed_undo_push(message=f'{self.rna[index].name} : {getattr(self.pp, self.identifier[index])}')
    # >>>
    #|



def c_dark_anim(self):
    self.box_anim.__class__ = GpuImg_keyframe_false_dark  if self.rna.is_animatable else GpuImgNull
    #|
def c_dark_anim_vec(self):
    if self.rna.is_animatable:
        for e in self.box_anim:
            e.__class__ = GpuImg_keyframe_false_dark
    else:
        for e in self.box_anim:
            e.__class__ = GpuImgNull
    #|

class FakeValue:
    __slots__ = ()

    value = "nan"
    #|
    #|
class FakeValue0:
    __slots__ = ()

    value = 0
    #|
    #|
# <<< 1copy (0defui_c_upd_button_keyframe,, $$)
def c_upd_button_keyframe_VAL_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == self.get():
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == self.get():
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_VAL(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == self.get():
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == self.get():
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_VAL_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'self.get()':'v'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == v:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == v:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_VAL_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'self.get()':'v'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == v:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == v:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>

def c_upd_button_keyframe_VAL_vec_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
        dp_index = dp  if r == 0 else (dp, r)
        if dp_index in self.ui_anim_data.drivers:
            if button.__class__ is GpuImg_driver_true_dark: pass
            else:
                button.__class__ = GpuImg_driver_true_dark
            continue

        if dp_index in self.ui_anim_data.fcurves:
            fc = self.ui_anim_data.fcurves[dp_index]
            if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                if fc.evaluate(FRAME_CURRENT) == v:
                    if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_even_dark
                else:
                    if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_odd_dark
            else:
                if fc.evaluate(FRAME_CURRENT) == v:
                    if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_even_dark
                else:
                    if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_odd_dark
            continue

        if button.__class__ is GpuImg_keyframe_false_dark: pass
        else:
            button.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_VAL_vec(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
        dp_index = dp  if r == 0 else (dp, r)
        if dp_index in self.ui_anim_data.drivers:
            if button.__class__ is GpuImg_driver_true: pass
            else:
                button.__class__ = GpuImg_driver_true
            continue

        if dp_index in self.ui_anim_data.fcurves:
            fc = self.ui_anim_data.fcurves[dp_index]
            if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                if fc.evaluate(FRAME_CURRENT) == v:
                    if button.__class__ is GpuImg_keyframe_next_false_even: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_even
                else:
                    if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_odd
            else:
                if fc.evaluate(FRAME_CURRENT) == v:
                    if button.__class__ is GpuImg_keyframe_current_true_even: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_even
                else:
                    if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_odd
            continue

        if button.__class__ is GpuImg_keyframe_false: pass
        else:
            button.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_VAL_vec_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_ov_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    ref = getattr(self.ui_anim_data.pp_ref, self.identifier, None)

    if ref is None:
        for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
            dp_index = dp  if r == 0 else (dp, r)
            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true_dark: pass
                else:
                    button.__class__ = GpuImg_driver_true_dark
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd_dark
                else:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd_dark
                continue

            if button.__class__ is GpuImg_keyframe_false_dark: pass
            else:
                button.__class__ = GpuImg_keyframe_false_dark
    else:
        for button, v, r, v_ref in zip(self.box_anim, self.get(), self.vec_range, ref):
            dp_index = dp  if r == 0 else (dp, r)

            if v == v_ref: pass
            else:
                if button.__class__ is GpuImg_driver_ref_dark: pass
                else:

                    button.__class__ = GpuImg_driver_ref_dark
                continue

            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true_dark: pass
                else:
                    button.__class__ = GpuImg_driver_true_dark
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd_dark
                else:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd_dark
                continue

            if button.__class__ is GpuImg_keyframe_false_dark: pass
            else:
                button.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_VAL_vec_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_ov_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    ref = getattr(self.ui_anim_data.pp_ref, self.identifier, None)

    if ref is None:
        for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
            dp_index = dp  if r == 0 else (dp, r)
            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true: pass
                else:
                    button.__class__ = GpuImg_driver_true
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_next_false_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd
                else:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_current_true_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd
                continue

            if button.__class__ is GpuImg_keyframe_false: pass
            else:
                button.__class__ = GpuImg_keyframe_false
    else:
        for button, v, r, v_ref in zip(self.box_anim, self.get(), self.vec_range, ref):
            dp_index = dp  if r == 0 else (dp, r)

            if v == v_ref: pass
            else:
                if button.__class__ is GpuImg_driver_ref: pass
                else:

                    button.__class__ = GpuImg_driver_ref
                continue

            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true: pass
                else:
                    button.__class__ = GpuImg_driver_true
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_next_false_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd
                else:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_current_true_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd
                continue

            if button.__class__ is GpuImg_keyframe_false: pass
            else:
                button.__class__ = GpuImg_keyframe_false
    # >>>

def c_upd_button_keyframe_BOOL_vec_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_dark,, $$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_dark,, ${'== v:':'== (1  if v else 0):'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
        dp_index = dp  if r == 0 else (dp, r)
        if dp_index in self.ui_anim_data.drivers:
            if button.__class__ is GpuImg_driver_true_dark: pass
            else:
                button.__class__ = GpuImg_driver_true_dark
            continue

        if dp_index in self.ui_anim_data.fcurves:
            fc = self.ui_anim_data.fcurves[dp_index]
            if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                    if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_even_dark
                else:
                    if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_odd_dark
            else:
                if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                    if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_even_dark
                else:
                    if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_odd_dark
            continue

        if button.__class__ is GpuImg_keyframe_false_dark: pass
        else:
            button.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_vec(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_dark,, ${'_dark':''}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec,, ${'== v:':'== (1  if v else 0):'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
        dp_index = dp  if r == 0 else (dp, r)
        if dp_index in self.ui_anim_data.drivers:
            if button.__class__ is GpuImg_driver_true: pass
            else:
                button.__class__ = GpuImg_driver_true
            continue

        if dp_index in self.ui_anim_data.fcurves:
            fc = self.ui_anim_data.fcurves[dp_index]
            if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                    if button.__class__ is GpuImg_keyframe_next_false_even: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_even
                else:
                    if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_odd
            else:
                if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                    if button.__class__ is GpuImg_keyframe_current_true_even: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_even
                else:
                    if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_odd
            continue

        if button.__class__ is GpuImg_keyframe_false: pass
        else:
            button.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_vec_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_ov_dark,, $$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_ov_dark,, ${'== v:':'== (1  if v else 0):'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    ref = getattr(self.ui_anim_data.pp_ref, self.identifier, None)

    if ref is None:
        for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
            dp_index = dp  if r == 0 else (dp, r)
            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true_dark: pass
                else:
                    button.__class__ = GpuImg_driver_true_dark
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd_dark
                else:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd_dark
                continue

            if button.__class__ is GpuImg_keyframe_false_dark: pass
            else:
                button.__class__ = GpuImg_keyframe_false_dark
    else:
        for button, v, r, v_ref in zip(self.box_anim, self.get(), self.vec_range, ref):
            dp_index = dp  if r == 0 else (dp, r)

            if v == v_ref: pass
            else:
                if button.__class__ is GpuImg_driver_ref_dark: pass
                else:

                    button.__class__ = GpuImg_driver_ref_dark
                continue

            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true_dark: pass
                else:
                    button.__class__ = GpuImg_driver_true_dark
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd_dark
                else:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd_dark
                continue

            if button.__class__ is GpuImg_keyframe_false_dark: pass
            else:
                button.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_vec_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_ov,, ${'== v:':'== (1  if v else 0):'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    ref = getattr(self.ui_anim_data.pp_ref, self.identifier, None)

    if ref is None:
        for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
            dp_index = dp  if r == 0 else (dp, r)
            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true: pass
                else:
                    button.__class__ = GpuImg_driver_true
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_next_false_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd
                else:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_current_true_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd
                continue

            if button.__class__ is GpuImg_keyframe_false: pass
            else:
                button.__class__ = GpuImg_keyframe_false
    else:
        for button, v, r, v_ref in zip(self.box_anim, self.get(), self.vec_range, ref):
            dp_index = dp  if r == 0 else (dp, r)

            if v == v_ref: pass
            else:
                if button.__class__ is GpuImg_driver_ref: pass
                else:

                    button.__class__ = GpuImg_driver_ref
                continue

            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true: pass
                else:
                    button.__class__ = GpuImg_driver_true
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_next_false_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd
                else:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_current_true_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd
                continue

            if button.__class__ is GpuImg_keyframe_false: pass
            else:
                button.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>

def c_upd_button_keyframe_BOOL_vec_flag_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_flag_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    dps = [dp  if r == 0 else (dp, r)  for r in self.vec_range]

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True
        v = self.get()

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if v[r] else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_BOOL_vec_flag(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_flag_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    dps = [dp  if r == 0 else (dp, r)  for r in self.vec_range]

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True
        v = self.get()

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if v[r] else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_BOOL_vec_flag_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_flag_ov_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    dps = [dp  if r == 0 else (dp, r)  for r in self.vec_range]
    pp_ref = self.ui_anim_data.pp_ref
    v = self.get()

    if pp_ref:
        for r, attr in enumerate(self.identifier):
            if getattr(pp_ref, attr) == v[r]: pass
            else:
                if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_driver_ref_dark
                return

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if v[r] else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_BOOL_vec_flag_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_flag_ov_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    dps = [dp  if r == 0 else (dp, r)  for r in self.vec_range]
    pp_ref = self.ui_anim_data.pp_ref
    v = self.get()

    if pp_ref:
        for r, attr in enumerate(self.identifier):
            if getattr(pp_ref, attr) == v[r]: pass
            else:
                if self.box_anim.__class__ is GpuImg_driver_ref: pass
                else:

                    self.box_anim.__class__ = GpuImg_driver_ref
                return

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if v[r] else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>

def c_upd_button_keyframe_COLOR_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_COLOR_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if self.array_length == 3:
        dp_indexes = [dp, (dp, 1), (dp, 2)]
    else:
        dp_indexes = [dp, (dp, 1), (dp, 2), (dp, 3)]

    if any(dp_index in self.ui_anim_data.drivers  for dp_index in dp_indexes):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp_index in self.ui_anim_data.fcurves  for dp_index in dp_indexes):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for dp_index, v in zip(dp_indexes, self.get()):
            if dp_index in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp_index].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if abs(fcurves[dp_index].evaluate(FRAME_CURRENT) - v) > 0.0000001:
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_COLOR(self):
    # <<< 1copy (0defc_upd_button_keyframe_COLOR_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if self.array_length == 3:
        dp_indexes = [dp, (dp, 1), (dp, 2)]
    else:
        dp_indexes = [dp, (dp, 1), (dp, 2), (dp, 3)]

    if any(dp_index in self.ui_anim_data.drivers  for dp_index in dp_indexes):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp_index in self.ui_anim_data.fcurves  for dp_index in dp_indexes):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for dp_index, v in zip(dp_indexes, self.get()):
            if dp_index in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp_index].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if abs(fcurves[dp_index].evaluate(FRAME_CURRENT) - v) > 0.0000001:
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_COLOR_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_COLOR_ov_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if self.array_length == 3:
        dp_indexes = [dp, (dp, 1), (dp, 2)]
    else:
        dp_indexes = [dp, (dp, 1), (dp, 2), (dp, 3)]

    v_ref = getattr(self.ui_anim_data.pp_ref, self.identifier, None)
    if v_ref is None: pass
    else:
        if list(v_ref) == list(self.get()): pass
        else:
            if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
            else:

                self.box_anim.__class__ = GpuImg_driver_ref_dark
            return

    if any(dp_index in self.ui_anim_data.drivers  for dp_index in dp_indexes):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp_index in self.ui_anim_data.fcurves  for dp_index in dp_indexes):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = False
        is_all_match = True

        for dp_index, v in zip(dp_indexes, self.get()):
            if dp_index in fcurves:
                if is_current_keyframe is False:
                    if bin_search_fc_anim(fcurves[dp_index].keyframe_points, FRAME_CURRENT) is None: pass
                    else:
                        is_current_keyframe = True

                if is_all_match is True:
                    if abs(fcurves[dp_index].evaluate(FRAME_CURRENT) - v) > 0.0000001:
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_COLOR_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_COLOR_ov_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if self.array_length == 3:
        dp_indexes = [dp, (dp, 1), (dp, 2)]
    else:
        dp_indexes = [dp, (dp, 1), (dp, 2), (dp, 3)]

    v_ref = getattr(self.ui_anim_data.pp_ref, self.identifier, None)
    if v_ref is None: pass
    else:
        if list(v_ref) == list(self.get()): pass
        else:
            if self.box_anim.__class__ is GpuImg_driver_ref: pass
            else:

                self.box_anim.__class__ = GpuImg_driver_ref
            return

    if any(dp_index in self.ui_anim_data.drivers  for dp_index in dp_indexes):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp_index in self.ui_anim_data.fcurves  for dp_index in dp_indexes):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = False
        is_all_match = True

        for dp_index, v in zip(dp_indexes, self.get()):
            if dp_index in fcurves:
                if is_current_keyframe is False:
                    if bin_search_fc_anim(fcurves[dp_index].keyframe_points, FRAME_CURRENT) is None: pass
                    else:
                        is_current_keyframe = True

                if is_all_match is True:
                    if abs(fcurves[dp_index].evaluate(FRAME_CURRENT) - v) > 0.0000001:
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>

def c_upd_button_keyframe_BOOL_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_dark,, $$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'self.get()':'(1  if self.get() else 0)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == (1  if self.get() else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == (1  if self.get() else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_dark,, ${'_dark':''}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'self.get()':'(1  if self.get() else 0)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == (1  if self.get() else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == (1  if self.get() else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_dark,, ${'self.get()':'v'}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'v':'(1  if v else 0)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_BOOL,, ${'self.get()':'v'}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'v':'(1  if v else 0)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>
    # >>>

def c_upd_button_keyframe_BOOLFLAG_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOLFLAG_dark,, $$)
    dph = self.ui_anim_data.dph
    if dph: dph += "."

    dps = [f'{dph}{attr}'  for attr in self.identifier]

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if self.get(r) else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_BOOLFLAG(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOLFLAG_dark,, ${'_dark':''}$)
    dph = self.ui_anim_data.dph
    if dph: dph += "."

    dps = [f'{dph}{attr}'  for attr in self.identifier]

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if self.get(r) else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_BOOLFLAG_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOLFLAG_ov_dark,, $$)
    dph = self.ui_anim_data.dph
    if dph: dph += "."

    dps = [f'{dph}{attr}'  for attr in self.identifier]
    pp_ref = self.ui_anim_data.pp_ref

    if pp_ref:
        for r, attr in enumerate(self.identifier):
            if getattr(pp_ref, attr) == self.get(r): pass
            else:
                if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_driver_ref_dark
                return

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if self.get(r) else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_BOOLFLAG_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOLFLAG_ov_dark,, ${'_dark':''}$)
    dph = self.ui_anim_data.dph
    if dph: dph += "."

    dps = [f'{dph}{attr}'  for attr in self.identifier]
    pp_ref = self.ui_anim_data.pp_ref

    if pp_ref:
        for r, attr in enumerate(self.identifier):
            if getattr(pp_ref, attr) == self.get(r): pass
            else:
                if self.box_anim.__class__ is GpuImg_driver_ref: pass
                else:

                    self.box_anim.__class__ = GpuImg_driver_ref
                return

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if self.get(r) else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>

def c_upd_button_keyframe_STR_dark(self):
    pass
def c_upd_button_keyframe_STR_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_STR_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>

    if self.box_anim.__class__ is GpuImgNull: pass
    else:

        self.box_anim.__class__ = GpuImgNull
    # >>>
def c_upd_button_keyframe_STR_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_STR_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>

    if self.box_anim.__class__ is GpuImgNull: pass
    else:

        self.box_anim.__class__ = GpuImgNull
    # >>>

def c_upd_button_keyframe_ENUM_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUM_dark,, $$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'self.get()':'float(self.enum_items.get(self.get(), FakeValue).value)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(self.get(), FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(self.get(), FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_ENUM(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUM_dark,, ${'_dark':''}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'self.get()':'float(self.enum_items.get(self.get(), FakeValue).value)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(self.get(), FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(self.get(), FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>
def c_upd_button_keyframe_ENUM_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUM_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'self.get()':'float(self.enum_items.get(v, FakeValue).value)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(v, FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(v, FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_ENUM_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUM_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'self.get()':'float(self.enum_items.get(v, FakeValue).value)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(v, FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(v, FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>

def c_upd_button_keyframe_ENUMFLAG_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            v = self.get()
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            v = self.get()
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_ENUMFLAG(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            v = self.get()
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            v = self.get()
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_ENUMFLAG_ov_dark(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_dark,, ${'v = self.get()': ''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_ENUMFLAG_ov(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == getattr(self.ui_anim_data.pp_ref, self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG,, ${'v = self.get()': ''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}.{self.identifier}'
    else:
        dp = self.identifier

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>

# >>>
# <<< 1copy (0defui_c_upd_button_keyframe,, ${
#     '(self):': '_cprop(self):',
#     "dp = f'{self.ui_anim_data.dph}.{self.identifier}'": "dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'",
#     'dp = self.identifier': 'dp = self.identifier_escape',
#     'getattr(self.ui_anim_data.pp_ref, self.identifier,': 'self.ui_anim_data.pp_ref.get(self.identifier,',
#     'getattr(pp_ref, attr)': 'pp_ref.get(attr, type)',
# }$)
def c_upd_button_keyframe_VAL_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == self.get():
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == self.get():
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_VAL_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == self.get():
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == self.get():
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_VAL_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'self.get()':'v'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == v:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == v:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_VAL_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'self.get()':'v'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == v:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == v:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>

def c_upd_button_keyframe_VAL_vec_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
        dp_index = dp  if r == 0 else (dp, r)
        if dp_index in self.ui_anim_data.drivers:
            if button.__class__ is GpuImg_driver_true_dark: pass
            else:
                button.__class__ = GpuImg_driver_true_dark
            continue

        if dp_index in self.ui_anim_data.fcurves:
            fc = self.ui_anim_data.fcurves[dp_index]
            if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                if fc.evaluate(FRAME_CURRENT) == v:
                    if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_even_dark
                else:
                    if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_odd_dark
            else:
                if fc.evaluate(FRAME_CURRENT) == v:
                    if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_even_dark
                else:
                    if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_odd_dark
            continue

        if button.__class__ is GpuImg_keyframe_false_dark: pass
        else:
            button.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_VAL_vec_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
        dp_index = dp  if r == 0 else (dp, r)
        if dp_index in self.ui_anim_data.drivers:
            if button.__class__ is GpuImg_driver_true: pass
            else:
                button.__class__ = GpuImg_driver_true
            continue

        if dp_index in self.ui_anim_data.fcurves:
            fc = self.ui_anim_data.fcurves[dp_index]
            if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                if fc.evaluate(FRAME_CURRENT) == v:
                    if button.__class__ is GpuImg_keyframe_next_false_even: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_even
                else:
                    if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_odd
            else:
                if fc.evaluate(FRAME_CURRENT) == v:
                    if button.__class__ is GpuImg_keyframe_current_true_even: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_even
                else:
                    if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_odd
            continue

        if button.__class__ is GpuImg_keyframe_false: pass
        else:
            button.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_VAL_vec_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_ov_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    ref = self.ui_anim_data.pp_ref.get(self.identifier, None)

    if ref is None:
        for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
            dp_index = dp  if r == 0 else (dp, r)
            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true_dark: pass
                else:
                    button.__class__ = GpuImg_driver_true_dark
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd_dark
                else:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd_dark
                continue

            if button.__class__ is GpuImg_keyframe_false_dark: pass
            else:
                button.__class__ = GpuImg_keyframe_false_dark
    else:
        for button, v, r, v_ref in zip(self.box_anim, self.get(), self.vec_range, ref):
            dp_index = dp  if r == 0 else (dp, r)

            if v == v_ref: pass
            else:
                if button.__class__ is GpuImg_driver_ref_dark: pass
                else:

                    button.__class__ = GpuImg_driver_ref_dark
                continue

            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true_dark: pass
                else:
                    button.__class__ = GpuImg_driver_true_dark
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd_dark
                else:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd_dark
                continue

            if button.__class__ is GpuImg_keyframe_false_dark: pass
            else:
                button.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_VAL_vec_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_ov_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    ref = self.ui_anim_data.pp_ref.get(self.identifier, None)

    if ref is None:
        for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
            dp_index = dp  if r == 0 else (dp, r)
            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true: pass
                else:
                    button.__class__ = GpuImg_driver_true
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_next_false_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd
                else:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_current_true_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd
                continue

            if button.__class__ is GpuImg_keyframe_false: pass
            else:
                button.__class__ = GpuImg_keyframe_false
    else:
        for button, v, r, v_ref in zip(self.box_anim, self.get(), self.vec_range, ref):
            dp_index = dp  if r == 0 else (dp, r)

            if v == v_ref: pass
            else:
                if button.__class__ is GpuImg_driver_ref: pass
                else:

                    button.__class__ = GpuImg_driver_ref
                continue

            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true: pass
                else:
                    button.__class__ = GpuImg_driver_true
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_next_false_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd
                else:
                    if fc.evaluate(FRAME_CURRENT) == v:
                        if button.__class__ is GpuImg_keyframe_current_true_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd
                continue

            if button.__class__ is GpuImg_keyframe_false: pass
            else:
                button.__class__ = GpuImg_keyframe_false
    # >>>

def c_upd_button_keyframe_BOOL_vec_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_dark,, $$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_dark,, ${'== v:':'== (1  if v else 0):'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
        dp_index = dp  if r == 0 else (dp, r)
        if dp_index in self.ui_anim_data.drivers:
            if button.__class__ is GpuImg_driver_true_dark: pass
            else:
                button.__class__ = GpuImg_driver_true_dark
            continue

        if dp_index in self.ui_anim_data.fcurves:
            fc = self.ui_anim_data.fcurves[dp_index]
            if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                    if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_even_dark
                else:
                    if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_odd_dark
            else:
                if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                    if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_even_dark
                else:
                    if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_odd_dark
            continue

        if button.__class__ is GpuImg_keyframe_false_dark: pass
        else:
            button.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_vec_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_dark,, ${'_dark':''}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec,, ${'== v:':'== (1  if v else 0):'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
        dp_index = dp  if r == 0 else (dp, r)
        if dp_index in self.ui_anim_data.drivers:
            if button.__class__ is GpuImg_driver_true: pass
            else:
                button.__class__ = GpuImg_driver_true
            continue

        if dp_index in self.ui_anim_data.fcurves:
            fc = self.ui_anim_data.fcurves[dp_index]
            if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                    if button.__class__ is GpuImg_keyframe_next_false_even: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_even
                else:
                    if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                    else:

                        button.__class__ = GpuImg_keyframe_next_false_odd
            else:
                if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                    if button.__class__ is GpuImg_keyframe_current_true_even: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_even
                else:
                    if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                    else:

                        button.__class__ = GpuImg_keyframe_current_true_odd
            continue

        if button.__class__ is GpuImg_keyframe_false: pass
        else:
            button.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_vec_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_ov_dark,, $$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_ov_dark,, ${'== v:':'== (1  if v else 0):'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    ref = self.ui_anim_data.pp_ref.get(self.identifier, None)

    if ref is None:
        for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
            dp_index = dp  if r == 0 else (dp, r)
            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true_dark: pass
                else:
                    button.__class__ = GpuImg_driver_true_dark
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd_dark
                else:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd_dark
                continue

            if button.__class__ is GpuImg_keyframe_false_dark: pass
            else:
                button.__class__ = GpuImg_keyframe_false_dark
    else:
        for button, v, r, v_ref in zip(self.box_anim, self.get(), self.vec_range, ref):
            dp_index = dp  if r == 0 else (dp, r)

            if v == v_ref: pass
            else:
                if button.__class__ is GpuImg_driver_ref_dark: pass
                else:

                    button.__class__ = GpuImg_driver_ref_dark
                continue

            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true_dark: pass
                else:
                    button.__class__ = GpuImg_driver_true_dark
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd_dark
                else:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even_dark
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd_dark
                continue

            if button.__class__ is GpuImg_keyframe_false_dark: pass
            else:
                button.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_vec_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_vec_ov,, ${'== v:':'== (1  if v else 0):'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    ref = self.ui_anim_data.pp_ref.get(self.identifier, None)

    if ref is None:
        for button, v, r in zip(self.box_anim, self.get(), self.vec_range):
            dp_index = dp  if r == 0 else (dp, r)
            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true: pass
                else:
                    button.__class__ = GpuImg_driver_true
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_next_false_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd
                else:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_current_true_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd
                continue

            if button.__class__ is GpuImg_keyframe_false: pass
            else:
                button.__class__ = GpuImg_keyframe_false
    else:
        for button, v, r, v_ref in zip(self.box_anim, self.get(), self.vec_range, ref):
            dp_index = dp  if r == 0 else (dp, r)

            if v == v_ref: pass
            else:
                if button.__class__ is GpuImg_driver_ref: pass
                else:

                    button.__class__ = GpuImg_driver_ref
                continue

            if dp_index in self.ui_anim_data.drivers:
                if button.__class__ is GpuImg_driver_true: pass
                else:
                    button.__class__ = GpuImg_driver_true
                continue

            if dp_index in self.ui_anim_data.fcurves:
                fc = self.ui_anim_data.fcurves[dp_index]
                if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_next_false_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_even
                    else:
                        if button.__class__ is GpuImg_keyframe_next_false_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_next_false_odd
                else:
                    if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                        if button.__class__ is GpuImg_keyframe_current_true_even: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_even
                    else:
                        if button.__class__ is GpuImg_keyframe_current_true_odd: pass
                        else:

                            button.__class__ = GpuImg_keyframe_current_true_odd
                continue

            if button.__class__ is GpuImg_keyframe_false: pass
            else:
                button.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>

def c_upd_button_keyframe_BOOL_vec_flag_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_flag_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    dps = [dp  if r == 0 else (dp, r)  for r in self.vec_range]

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True
        v = self.get()

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if v[r] else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_BOOL_vec_flag_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_flag_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    dps = [dp  if r == 0 else (dp, r)  for r in self.vec_range]

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True
        v = self.get()

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if v[r] else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_BOOL_vec_flag_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_flag_ov_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    dps = [dp  if r == 0 else (dp, r)  for r in self.vec_range]
    pp_ref = self.ui_anim_data.pp_ref
    v = self.get()

    if pp_ref:
        for r, attr in enumerate(self.identifier):
            if pp_ref.get(attr, type) == v[r]: pass
            else:
                if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_driver_ref_dark
                return

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if v[r] else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_BOOL_vec_flag_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_vec_flag_ov_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    dps = [dp  if r == 0 else (dp, r)  for r in self.vec_range]
    pp_ref = self.ui_anim_data.pp_ref
    v = self.get()

    if pp_ref:
        for r, attr in enumerate(self.identifier):
            if pp_ref.get(attr, type) == v[r]: pass
            else:
                if self.box_anim.__class__ is GpuImg_driver_ref: pass
                else:

                    self.box_anim.__class__ = GpuImg_driver_ref
                return

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if v[r] else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>

def c_upd_button_keyframe_COLOR_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_COLOR_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if self.array_length == 3:
        dp_indexes = [dp, (dp, 1), (dp, 2)]
    else:
        dp_indexes = [dp, (dp, 1), (dp, 2), (dp, 3)]

    if any(dp_index in self.ui_anim_data.drivers  for dp_index in dp_indexes):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp_index in self.ui_anim_data.fcurves  for dp_index in dp_indexes):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for dp_index, v in zip(dp_indexes, self.get()):
            if dp_index in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp_index].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if abs(fcurves[dp_index].evaluate(FRAME_CURRENT) - v) > 0.0000001:
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_COLOR_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_COLOR_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if self.array_length == 3:
        dp_indexes = [dp, (dp, 1), (dp, 2)]
    else:
        dp_indexes = [dp, (dp, 1), (dp, 2), (dp, 3)]

    if any(dp_index in self.ui_anim_data.drivers  for dp_index in dp_indexes):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp_index in self.ui_anim_data.fcurves  for dp_index in dp_indexes):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for dp_index, v in zip(dp_indexes, self.get()):
            if dp_index in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp_index].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if abs(fcurves[dp_index].evaluate(FRAME_CURRENT) - v) > 0.0000001:
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_COLOR_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_COLOR_ov_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if self.array_length == 3:
        dp_indexes = [dp, (dp, 1), (dp, 2)]
    else:
        dp_indexes = [dp, (dp, 1), (dp, 2), (dp, 3)]

    v_ref = self.ui_anim_data.pp_ref.get(self.identifier, None)
    if v_ref is None: pass
    else:
        if list(v_ref) == list(self.get()): pass
        else:
            if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
            else:

                self.box_anim.__class__ = GpuImg_driver_ref_dark
            return

    if any(dp_index in self.ui_anim_data.drivers  for dp_index in dp_indexes):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp_index in self.ui_anim_data.fcurves  for dp_index in dp_indexes):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = False
        is_all_match = True

        for dp_index, v in zip(dp_indexes, self.get()):
            if dp_index in fcurves:
                if is_current_keyframe is False:
                    if bin_search_fc_anim(fcurves[dp_index].keyframe_points, FRAME_CURRENT) is None: pass
                    else:
                        is_current_keyframe = True

                if is_all_match is True:
                    if abs(fcurves[dp_index].evaluate(FRAME_CURRENT) - v) > 0.0000001:
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_COLOR_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_COLOR_ov_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if self.array_length == 3:
        dp_indexes = [dp, (dp, 1), (dp, 2)]
    else:
        dp_indexes = [dp, (dp, 1), (dp, 2), (dp, 3)]

    v_ref = self.ui_anim_data.pp_ref.get(self.identifier, None)
    if v_ref is None: pass
    else:
        if list(v_ref) == list(self.get()): pass
        else:
            if self.box_anim.__class__ is GpuImg_driver_ref: pass
            else:

                self.box_anim.__class__ = GpuImg_driver_ref
            return

    if any(dp_index in self.ui_anim_data.drivers  for dp_index in dp_indexes):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp_index in self.ui_anim_data.fcurves  for dp_index in dp_indexes):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = False
        is_all_match = True

        for dp_index, v in zip(dp_indexes, self.get()):
            if dp_index in fcurves:
                if is_current_keyframe is False:
                    if bin_search_fc_anim(fcurves[dp_index].keyframe_points, FRAME_CURRENT) is None: pass
                    else:
                        is_current_keyframe = True

                if is_all_match is True:
                    if abs(fcurves[dp_index].evaluate(FRAME_CURRENT) - v) > 0.0000001:
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>

def c_upd_button_keyframe_BOOL_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_dark,, $$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'self.get()':'(1  if self.get() else 0)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == (1  if self.get() else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == (1  if self.get() else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_dark,, ${'_dark':''}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'self.get()':'(1  if self.get() else 0)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == (1  if self.get() else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == (1  if self.get() else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_dark,, ${'self.get()':'v'}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'v':'(1  if v else 0)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
    # >>>
def c_upd_button_keyframe_BOOL_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOL_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_BOOL,, ${'self.get()':'v'}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'v':'(1  if v else 0)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == (1  if v else 0):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>
    # >>>

def c_upd_button_keyframe_BOOLFLAG_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOLFLAG_dark,, $$)
    dph = self.ui_anim_data.dph
    if dph: dph += "."

    dps = [f'{dph}{attr}'  for attr in self.identifier]

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if self.get(r) else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_BOOLFLAG_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOLFLAG_dark,, ${'_dark':''}$)
    dph = self.ui_anim_data.dph
    if dph: dph += "."

    dps = [f'{dph}{attr}'  for attr in self.identifier]

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if self.get(r) else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_BOOLFLAG_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOLFLAG_ov_dark,, $$)
    dph = self.ui_anim_data.dph
    if dph: dph += "."

    dps = [f'{dph}{attr}'  for attr in self.identifier]
    pp_ref = self.ui_anim_data.pp_ref

    if pp_ref:
        for r, attr in enumerate(self.identifier):
            if pp_ref.get(attr, type) == self.get(r): pass
            else:
                if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_driver_ref_dark
                return

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if self.get(r) else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_BOOLFLAG_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_BOOLFLAG_ov_dark,, ${'_dark':''}$)
    dph = self.ui_anim_data.dph
    if dph: dph += "."

    dps = [f'{dph}{attr}'  for attr in self.identifier]
    pp_ref = self.ui_anim_data.pp_ref

    if pp_ref:
        for r, attr in enumerate(self.identifier):
            if pp_ref.get(attr, type) == self.get(r): pass
            else:
                if self.box_anim.__class__ is GpuImg_driver_ref: pass
                else:

                    self.box_anim.__class__ = GpuImg_driver_ref
                return

    if any(dp in self.ui_anim_data.drivers  for dp in dps):
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if any(dp in self.ui_anim_data.fcurves  for dp in dps):
        fcurves = self.ui_anim_data.fcurves
        is_current_keyframe = True
        is_all_match = True

        for r, dp in enumerate(dps):
            if dp in fcurves:
                if is_current_keyframe is True:
                    if bin_search_fc_anim(fcurves[dp].keyframe_points, FRAME_CURRENT) is None:
                        is_current_keyframe = False

                if is_all_match is True:
                    if fcurves[dp].evaluate(FRAME_CURRENT) != (1  if self.get(r) else 0):
                        is_all_match = False

        if is_current_keyframe is False:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if is_all_match is True:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>

def c_upd_button_keyframe_STR_dark_cprop(self):
    pass
def c_upd_button_keyframe_STR_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_STR_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>

    if self.box_anim.__class__ is GpuImgNull: pass
    else:

        self.box_anim.__class__ = GpuImgNull
    # >>>
def c_upd_button_keyframe_STR_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_STR_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>

    if self.box_anim.__class__ is GpuImgNull: pass
    else:

        self.box_anim.__class__ = GpuImgNull
    # >>>

def c_upd_button_keyframe_ENUM_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUM_dark,, $$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'self.get()':'float(self.enum_items.get(self.get(), FakeValue).value)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(self.get(), FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(self.get(), FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_ENUM_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUM_dark,, ${'_dark':''}$)
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'self.get()':'float(self.enum_items.get(self.get(), FakeValue).value)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(self.get(), FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(self.get(), FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>
def c_upd_button_keyframe_ENUM_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUM_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_VAL_dark,, ${'self.get()':'float(self.enum_items.get(v, FakeValue).value)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(v, FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(v, FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_ENUM_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUM_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_VAL,, ${'self.get()':'float(self.enum_items.get(v, FakeValue).value)'}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(v, FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            if fc.evaluate(FRAME_CURRENT) == float(self.enum_items.get(v, FakeValue).value):
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>

def c_upd_button_keyframe_ENUMFLAG_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_dark,, $$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            v = self.get()
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            v = self.get()
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
def c_upd_button_keyframe_ENUMFLAG_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_dark,, ${'_dark':''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            v = self.get()
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            v = self.get()
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
def c_upd_button_keyframe_ENUMFLAG_ov_dark_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_ov_dark,, $$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref_dark: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref_dark
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_dark,, ${'v = self.get()': ''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true_dark: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true_dark
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd_dark
        else:
            
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even_dark
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd_dark: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd_dark
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false_dark: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false_dark
    # >>>
    # >>>
def c_upd_button_keyframe_ENUMFLAG_ov_cprop(self):
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG_ov_dark,, ${'_dark':''}$)
    # <<< 1copy (0defuiUpdAnimRef,, $$)
    v = self.get()
    if v == self.ui_anim_data.pp_ref.get(self.identifier, type): pass
    else:
        if self.box_anim.__class__ is GpuImg_driver_ref: pass
        else:

            self.box_anim.__class__ = GpuImg_driver_ref
        return
    # >>>
    # <<< 1copy (0defc_upd_button_keyframe_ENUMFLAG,, ${'v = self.get()': ''}$)
    if self.ui_anim_data.dph:
        dp = f'{self.ui_anim_data.dph}{self.identifier_escape}'
    else:
        dp = self.identifier_escape

    if dp in self.ui_anim_data.drivers:
        if self.box_anim.__class__ is GpuImg_driver_true: pass
        else:
            self.box_anim.__class__ = GpuImg_driver_true
        return

    if dp in self.ui_anim_data.fcurves:
        fc = self.ui_anim_data.fcurves[dp]
        if bin_search_fc_anim(fc.keyframe_points, FRAME_CURRENT) is None:
            
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_next_false_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_next_false_odd
        else:
            
            enum_items = self.enum_items
            if v:
                try: evaluate_value = float(sum(enum_items.get(ident, FakeValue0).value  for ident in v))
                except: evaluate_value = 0.0
            else:
                evaluate_value = 0.0
            if fc.evaluate(FRAME_CURRENT) == evaluate_value:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_even: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_even
            else:
                if self.box_anim.__class__ is GpuImg_keyframe_current_true_odd: pass
                else:

                    self.box_anim.__class__ = GpuImg_keyframe_current_true_odd
        return

    if self.box_anim.__class__ is GpuImg_keyframe_false: pass
    else:
        self.box_anim.__class__ = GpuImg_keyframe_false
    # >>>
    # >>>

# >>>



def c_upd_icon_StrSearch(self, ob=""):
    if self.pollred is True and self.isdark is False:
        enumitems = self.enum_items()
        s = self.blf_value.unclip_text
        if hasattr(enumitems, "foreach_get"):
            self.blf_value.color = COL_box_text_fg  if s in enumitems else COL_box_val_fg_error
        elif hasattr(enumitems, "__getitem__"):
            self.blf_value.color = COL_box_text_fg  if any(e.name == s  for e in enumitems) else COL_box_val_fg_error

    if self.blf_value.unclip_text:
        if self.isdark is True:
            self.box_icon_arrow.__class__ = GpuImg_delete_dark
            self.box_icon.__class__ = GpuImg_stop_dark
        else:
            self.box_icon_arrow.__class__ = GpuImg_delete
            self.box_icon.__class__ = self.box_icon_cls
    else:
        if self.isdark is True:
            self.box_icon_arrow.__class__ = GpuImgNull
            self.box_icon.__class__ = GpuImg_stop_dark
        else:
            self.box_icon_arrow.__class__ = GpuImg_unfold
            self.box_icon.__class__ = self.box_icon_cls
    #|
def c_upd_icon_StrFile(self, ob=0):
    if self.isdark is True:
        self.box_icon_arrow.__class__ = GpuImgNull
    else:
        self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER
    #|


def c_dxy_anim_hover(self, dx, dy):
    self.i_dxy(dx, dy)
    if hasattr(self, "focus_element"):
        if self.focus_element != -1:
            self.focus_element = -1
            self.box_hover.LRBT_upd(0, 0, 0, 0)
    #|
def c_dxy_BuEnumIcon(self, dx, dy):
    # <<< 1copy (0defuiStrDxy,, $$)
    self.box_button.dxy_upd(dx, dy)
    self.box_anim.dxy_upd(dx, dy)

    self.blf_value.x += dx
    self.blf_value.y += dy
    self.blf_title.x += dx
    self.blf_title.y += dy
    # >>>
    self.box_icon_arrow.dxy_upd(dx, dy)
    self.box_icon.dxy_upd(dx, dy)
    #|


def c_draw_box_BuEnumIcon(self):
    # <<< 1copy (0defuiDrawbox,, $$)
    self.box_button.bind_draw()
    self.box_anim.bind_draw()
    # >>>
    self.box_icon_arrow.bind_draw()
    self.box_icon.bind_draw()
    #|
def c_draw_box_anim_BuEnumIcon(self):
    # <<< 1copy (0defuiDrawbox,, $$)
    self.box_button.bind_draw()
    self.box_anim.bind_draw()
    # >>>
    self.box_icon_arrow.bind_draw()
    self.box_icon.bind_draw()
    self.box_hover.bind_draw()
    #|
def c_draw_box_BuInt(self):
    # <<< 1copy (0defuiDrawbox,, $$)
    self.box_button.bind_draw()
    self.box_anim.bind_draw()
    # >>>
    #|
def c_draw_box_anim_BuInt(self):
    # <<< 1copy (0defuiDrawboxAnim,, $$)
    self.box_button.bind_draw()
    self.box_anim.bind_draw()
    self.box_hover.bind_draw()
    # >>>
    #|
def c_draw_blf_BuInt(self):
    # <<< 1copy (0defuiDrawblf,, $$)
    e = self.blf_value
    blfSize(FONT0, D_SIZE['font_main'])
    blfColor(FONT0, *e.color)
    blfPos(FONT0, e.x, e.y, 0)
    blfDraw(FONT0, e.text)

    e = self.blf_title
    blfColor(FONT0, *e.color)
    blfPos(FONT0, e.x, e.y, 0)
    blfDraw(FONT0, e.text)
    # >>>
    #|



def c_focus_anim_ID(self):
    self.draw_box = self.i_draw_box_anim
    if self.isdark is False:
        self.box_button.color = COL_box_text
        if self.box_icon_arrow.__class__ is GpuImg_object_picker_focus:
            self.box_icon_arrow.__class__ = GpuImg_object_picker
        elif self.box_icon_arrow.__class__ is GpuImg_delete_focus:
            self.box_icon_arrow.__class__ = GpuImg_delete

        if self.box_anim.__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
            self.box_hover.upd()
            self.dxy = self.i_dxy_anim_hover
    else:
        self.box_hover = GpuImgNull()
    #|
def c_focus_eye_ID(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_text_fo
        if self.box_icon_arrow.__class__ is GpuImg_object_picker:
            self.box_icon_arrow.__class__ = GpuImg_object_picker_focus
        elif self.box_icon_arrow.__class__ is GpuImg_delete:
            self.box_icon_arrow.__class__ = GpuImg_delete_focus
    #|
def c_focus_default_ID(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_text_fo
        if self.box_icon_arrow.__class__ is GpuImg_object_picker_focus:
            self.box_icon_arrow.__class__ = GpuImg_object_picker
        elif self.box_icon_arrow.__class__ is GpuImg_delete_focus:
            self.box_icon_arrow.__class__ = GpuImg_delete
    #|
def c_focus_empty_ID(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_text
        if self.box_icon_arrow.__class__ is GpuImg_object_picker_focus:
            self.box_icon_arrow.__class__ = GpuImg_object_picker
        elif self.box_icon_arrow.__class__ is GpuImg_delete_focus:
                self.box_icon_arrow.__class__ = GpuImg_delete
    #|

def c_focus_anim_strFile(self):
    self.draw_box = self.i_draw_box_anim
    if self.isdark is False:
        self.box_button.color = COL_box_text
        if self.box_icon_arrow.__class__ is GpuImg_FILE_FOLDER_focus:
            self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER

        if self.box_anim.__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
            self.box_hover.upd()
            self.dxy = self.i_dxy_anim_hover
    else:
        self.box_hover = GpuImgNull()
    #|
def c_focus_eye_strFile(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_text_fo
        if self.box_icon_arrow.__class__ is GpuImg_FILE_FOLDER:
            self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER_focus
    #|
def c_focus_default_strFile(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_text_fo
        if self.box_icon_arrow.__class__ is GpuImg_FILE_FOLDER_focus:
            self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER
    #|
def c_focus_empty_strFile(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_text
        if self.box_icon_arrow.__class__ is GpuImg_FILE_FOLDER_focus:
            self.box_icon_arrow.__class__ = GpuImg_FILE_FOLDER
    #|

def c_focus_anim_int(self):
    # /* 0defc_focus_anim_int
    self.draw_box = self.i_draw_box_anim
    if self.isdark is False:
        self.box_button.color = COL_box_val

        if self.box_anim.__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
            self.box_hover.upd()
            self.dxy = self.i_dxy_anim_hover
    else:
        self.box_hover = GpuImgNull()
    # */
def c_focus_default_int(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_val_fo
    #|
def c_focus_empty_int(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_val
    #|
def c_focus_media_left_int(self):
    if self.isdark is False:
        self.draw_box = self.i_draw_box_media
        self.dxy = self.i_dxy_media
        self.box_media = GpuImg_valuebox_left()
        e = self.box_button.inner
        self.box_media.LRBT_upd(e[0], e[0] + SIZE_widget[0], e[2], e[3])
        self.box_button.color = COL_box_val_fo
    #|
def c_focus_media_right_int(self):
    if self.isdark is False:
        self.draw_box = self.i_draw_box_media
        self.dxy = self.i_dxy_media
        self.box_media = GpuImg_valuebox_right()
        e = self.box_button.inner
        self.box_media.LRBT_upd(e[1] - SIZE_widget[0], e[1], e[2], e[3])
        self.box_button.color = COL_box_val_fo
    #|

def c_focus_anim_int_vec(self, ind):
    self.draw_box = self.i_draw_box_anim

    if self.isdark is True or self.box_anim[ind].__class__ is GpuImgNull:
        self.box_hover = GpuImgNull()
    else:
        self.box_hover = GpuImg_area_icon_hover(*self.box_anim[ind].r_LRBT())
        self.box_hover.upd()
        self.dxy = self.i_dxy_anim_hover
    #|
def c_focus_default_int_vec(self, ind):
    if self.isdark is False:
        self.draw_box = self.i_draw_box_media
        self.dxy = self.i_dxy_media
        self.box_media = BoxFake()
        e = self.box_button.inner
        T = e[3] - SIZE_widget[0] * ind
        self.box_active.LRBT_upd(e[0], e[1], T - SIZE_widget[0], T)
    #|
def c_focus_empty_int_vec(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    #|
def c_focus_media_left_int_vec(self, ind):
    if self.isdark is False:
        self.draw_box = self.i_draw_box_media
        self.dxy = self.i_dxy_media
        self.box_media = GpuImg_valuebox_left()
        e = self.box_button.inner
        h = SIZE_widget[0]
        T = e[3] - h * ind
        B = T - h
        self.box_media.LRBT_upd(e[0], e[0] + h, B, T)
        self.box_active.LRBT_upd(e[0], e[1], B, T)
    #|
def c_focus_media_right_int_vec(self, ind):
    if self.isdark is False:
        self.draw_box = self.i_draw_box_media
        self.dxy = self.i_dxy_media
        self.box_media = GpuImg_valuebox_right()
        e = self.box_button.inner
        h = SIZE_widget[0]
        T = e[3] - h * ind
        B = T - h
        self.box_media.LRBT_upd(e[1] - h, e[1], B, T)
        self.box_active.LRBT_upd(e[0], e[1], B, T)
    #|

def c_focus_anim_bool(self):
    # /* 0defc_focus_anim_bool
    # <<< 1copy (0defc_focus_anim_int,, ${'COL_box_val': 'COL_box_val_bool'}$)
    self.draw_box = self.i_draw_box_anim
    if self.isdark is False:
        self.box_button.color = COL_box_val_bool

        if self.box_anim.__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
            self.box_hover.upd()
            self.dxy = self.i_dxy_anim_hover
    else:
        self.box_hover = GpuImgNull()
    # >>>
    # */
def c_focus_default_bool(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_val_bool_fo
    #|
def c_focus_empty_bool(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_val_bool
    #|

def c_focus_anim_bool_vec(self, ind):
    # <<< 1copy (0defc_focus_anim_bool,, ${
    #     'self.box_button': 'self.box_button[ind]',
    #     'self.box_anim': 'self.box_anim[ind]'
    # }$)
    # <<< 1copy (0defc_focus_anim_int,, ${'COL_box_val': 'COL_box_val_bool'}$)
    self.draw_box = self.i_draw_box_anim
    if self.isdark is False:
        self.box_button[ind].color = COL_box_val_bool

        if self.box_anim[ind].__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim[ind].r_LRBT())
            self.box_hover.upd()
            self.dxy = self.i_dxy_anim_hover
    else:
        self.box_hover = GpuImgNull()
    # >>>
    # >>>
    #|
def c_focus_default_bool_vec(self, ind):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        for r, e in enumerate(self.box_button):
            e.color = COL_box_val_bool_fo  if r == ind else COL_box_val_bool
    #|
def c_focus_empty_bool_vec(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        for e in self.box_button:
            e.color = COL_box_val_bool
    #|

def c_focus_anim_bool_invert(self):
    self.draw_box = self.i_draw_box_anim

    if self.isdark is False:
        if self.get():
            self.box_button.set_state_on()
        else:
            self.box_button.set_state_off()

        if self.box_anim.__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
            self.box_hover.upd()
            self.dxy = self.i_dxy_anim_hover
    else:
        self.box_hover = GpuImgNull()
    #|
def c_focus_default_bool_invert(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        if self.get():
            self.box_button.set_state_on_focus()
        else:
            self.box_button.set_state_off_focus()
    #|
def c_focus_empty_bool_invert(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        if self.get():
            self.box_button.set_state_on()
        else:
            self.box_button.set_state_off()
    #|

def c_focus_anim_str(self):
    # <<< 1copy (0defc_focus_anim_int,, ${'COL_box_val': 'COL_box_text'}$)
    self.draw_box = self.i_draw_box_anim
    if self.isdark is False:
        self.box_button.color = COL_box_text

        if self.box_anim.__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
            self.box_hover.upd()
            self.dxy = self.i_dxy_anim_hover
    else:
        self.box_hover = GpuImgNull()
    # >>>
    #|
def c_focus_default_str(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_text_fo
    #|
def c_focus_empty_str(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        self.box_button.color = COL_box_text

        if hasattr(self, "box_icon_arrow"):
            if self.box_icon_arrow.__class__ is GpuImg_object_picker_focus:
                self.box_icon_arrow.__class__ = GpuImg_object_picker
            elif self.box_icon_arrow.__class__ is GpuImg_delete_focus:
                self.box_icon_arrow.__class__ = GpuImg_delete
    #|

def c_focus_match_str(self, ind):
    if self.isdark is False:
        self.box_button.color = COL_box_text_fo
        self.draw_box = self.i_draw_box_match
        self.dxy = self.i_dxy_match_hover

        if ind == 4:
            self.box_match_hover.LRBT_upd(*self.box_match_case.r_LRBT())
        elif ind == 5:
            self.box_match_hover.LRBT_upd(*self.box_match_whole_word.r_LRBT())
        else:
            self.box_match_hover.LRBT_upd(*self.box_match_end.r_LRBT())
    else:
        self.draw_box = self.i_draw_box
    #|

def c_focus_anim_flag(self):
    self.draw_box = self.i_draw_box_anim
    if self.isdark is False:
        for e in self.box_button:
            if e.state == 1:
                e.set_state_off()
            elif e.state == 3:
                e.set_state_on()

        if self.box_anim.__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
            self.box_hover.upd()
            self.dxy = self.i_dxy_anim_hover
    else:
        self.box_hover = GpuImgNull()
    #|
def c_focus_default_flag(self, i):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        for r, e in enumerate(self.box_button):
            if r == i:
                if e.state == 0:
                    e.set_state_off_focus()
            else:
                if e.state == 1:
                    e.set_state_off()
    #|
def c_focus_empty_flag(self):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        for e in self.box_button:
            if e.state == 1:
                e.set_state_off()
            elif e.state == 3:
                e.set_state_on()
    #|

def c_focus_default_enumflag(self, i):
    self.draw_box = self.i_draw_box
    self.dxy = self.i_dxy
    if self.isdark is False:
        for r, e in enumerate(self.box_button):
            if r == i:
                if e.state == 0:
                    e.set_state_off_focus()
                elif e.state == 2:
                    e.set_state_on_focus()
            else:
                if e.state == 1:
                    e.set_state_off()
                elif e.state == 3:
                    e.set_state_on()
    #|

def c_focus_anim_color(self):
    self.draw_box = self.i_draw_box_anim
    if self.isdark is False:
        self.box_button.color_rim = COL_box_color_rim

        if self.box_anim.__class__ is GpuImgNull:
            self.box_hover = GpuImgNull()
        else:
            self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
            self.box_hover.upd()
            if self.array_length == 3:
                self.dxy = self.i_dxy_3_anim_hover
            else:
                self.dxy = self.i_dxy_4_anim_hover
    else:
        self.box_hover = GpuImgNull()
    #|
def c_focus_default_color(self):
    if self.isdark is False:
        self.box_button.color_rim = [1.0, 1.0, 1.0, max(self.box_button.color[0 : 3])]

        if self.array_length == 3:
            self.draw_box = self.i_draw_box_3
            self.dxy = self.i_dxy_3
        else:
            self.draw_box = self.i_draw_box_4
            self.dxy = self.i_dxy_4
    else:
        if self.array_length == 3:
            self.draw_box = self.i_draw_box_3_dark
            self.dxy = self.i_dxy_3_dark
        else:
            self.draw_box = self.i_draw_box_4_dark
            self.dxy = self.i_dxy_4_dark
    #|
def c_focus_empty_color(self):
    if self.isdark is False:
        self.box_button.color_rim = COL_box_color_rim

        if self.array_length == 3:
            self.draw_box = self.i_draw_box_3
            self.dxy = self.i_dxy_3
        else:
            self.draw_box = self.i_draw_box_4
            self.dxy = self.i_dxy_4
    else:
        if self.array_length == 3:
            self.draw_box = self.i_draw_box_3_dark
            self.dxy = self.i_dxy_3_dark
        else:
            self.draw_box = self.i_draw_box_4_dark
            self.dxy = self.i_dxy_4_dark
    #|

#_c4#_c4#_c4#_c4

def focusID(cls):
    cls.focus_anim = c_focus_anim_ID
    cls.focus_eye = c_focus_eye_ID
    cls.focus_default = c_focus_default_ID
    cls.focus_empty = c_focus_empty_ID
    return cls
    #|
def focusStrFile(cls):
    cls.focus_anim = c_focus_anim_strFile
    cls.focus_eye = c_focus_eye_strFile
    cls.focus_default = c_focus_default_strFile
    cls.focus_empty = c_focus_empty_strFile
    return cls
    #|
def focusInt(cls):
    cls.focus_anim = c_focus_anim_int
    cls.focus_default = c_focus_default_int
    cls.focus_empty = c_focus_empty_int
    cls.focus_media_left = c_focus_media_left_int
    cls.focus_media_right = c_focus_media_right_int
    return cls
    #|
def focusIntvec(cls):
    cls.focus_anim = c_focus_anim_int_vec
    cls.focus_default = c_focus_default_int_vec
    cls.focus_empty = c_focus_empty_int_vec
    cls.focus_media_left = c_focus_media_left_int_vec
    cls.focus_media_right = c_focus_media_right_int_vec
    return cls
    #|
def focusBool(cls):
    cls.focus_anim = c_focus_anim_bool
    cls.focus_default = c_focus_default_bool
    cls.focus_empty = c_focus_empty_bool
    return cls
    #|
def focusBoolVec(cls):
    cls.focus_anim = c_focus_anim_bool_vec
    cls.focus_default = c_focus_default_bool_vec
    cls.focus_empty = c_focus_empty_bool_vec
    return cls
    #|
def focusBoolInvert(cls):
    cls.focus_anim = c_focus_anim_bool_invert
    cls.focus_default = c_focus_default_bool_invert
    cls.focus_empty = c_focus_empty_bool_invert
    return cls
    #|
def focusStr(cls):
    cls.focus_anim = c_focus_anim_str
    cls.focus_default = c_focus_default_str
    cls.focus_empty = c_focus_empty_str
    return cls
    #|
def focusEnumXY(cls):
    cls.focus_anim = c_focus_anim_flag
    cls.focus_default = c_focus_default_flag
    cls.focus_empty = c_focus_empty_flag
    return cls
    #|
def focusEnumFlag(cls):
    cls.focus_anim = c_focus_anim_flag
    cls.focus_default = c_focus_default_enumflag
    cls.focus_empty = c_focus_empty_flag
    return cls
    #|
def focusColor(cls):
    cls.focus_anim = c_focus_anim_color
    cls.focus_default = c_focus_default_color
    cls.focus_empty = c_focus_empty_color
    return cls
    #|



def c_focus_button(self, i):
    if self.box_button[i].state == 0:
        self.box_button[i].set_state_off_focus()
    elif self.box_button[i].state == 2:
        self.box_button[i].set_state_on_focus()
    #|
def c_unfocus_button(self, i):
    if self.box_button[i].state == 1:
        self.box_button[i].set_state_off()
    elif self.box_button[i].state == 3:
        self.box_button[i].set_state_on()
    #|
def c_turnon_button(self, i):
    if self.box_button[i].state in {1, 3}: # onfocuS
        self.box_button[i].set_state_on_focus()
    else:
        self.box_button[i].set_state_on()
    #|
def c_turnoff_button(self, i):
    if self.box_button[i].state in {1, 3}: # onfocuS
        self.box_button[i].set_state_off_focus()
    else:
        self.box_button[i].set_state_off()
    #|

def c_focus_buttonEnum(self, i):
    if self.box_button[i].state == 0:
        self.box_button[i].set_state_off_focus()
    #|
def c_turnon_buttonEnum(self, i):
    self.box_button[i].set_state_on()
    #|



def turnButtonStateEnum(cls):
    cls.focus_button = c_focus_buttonEnum
    cls.unfocus_button = c_unfocus_button
    cls.turnon_button = c_turnon_buttonEnum
    cls.turnoff_button = c_turnoff_button
    return cls
    #|
def turnButtonState(cls):
    cls.focus_button = c_focus_button
    cls.unfocus_button = c_unfocus_button
    cls.turnon_button = c_turnon_button
    cls.turnoff_button = c_turnoff_button
    return cls
    #|
def combEvt(cls):
    cls.get = c_get_comb
    cls.set = c_set_comb

    cls.evt_area_cut = c_evt_area_cut_COMB
    cls.evt_area_copy = c_evt_area_copy_COMB
    cls.evt_area_paste = c_evt_area_paste_COMB
    cls.evt_area_reset_single = c_evt_area_reset_single_COMB
    cls.evt_area_reset_all = c_evt_area_reset_all_COMB
    cls.evt_area_format = c_evt_area_format_COMB
    cls.evt_area_detail = c_evt_area_detail_COMB
    cls.evt_remove_from_keying_set = c_evt_remove_from_keying_set_COMB
    cls.evt_add_to_keying_set = c_evt_add_to_keying_set_COMB
    cls.evt_copy_full_data_path = c_evt_copy_full_data_path_COMB
    cls.evt_copy_data_path = c_evt_copy_data_path_COMB
    cls.evt_paste_full_data_path_as_driver = c_evt_paste_full_data_path_as_driver_COMB
    cls.evt_delete_driver = c_evt_delete_driver_COMB
    cls.evt_add_driver = c_evt_add_driver_COMB
    cls.evt_clear_keyframe = c_evt_clear_keyframe_COMB
    cls.evt_delete_keyframe = c_evt_delete_keyframe_COMB
    cls.evt_insert_keyframe = c_evt_insert_keyframe_COMB
    cls.evt_remove_override = c_evt_remove_override_COMB

    cls.to_modal_rm = c_to_modal_rm_COMB
    cls.bufn_keyframe = c_bufn_keyframe_group
    return cls
    #|
def toNoAnim(cls):
    cls.i_upd_anim_button = c_upd_button_keyframe_STR_dark
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_STR_dark
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_STR_ov
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_STR_ov_dark
    return cls
    #|
def toNoAnimGn(cls):
    cls.i_upd_anim_button = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_STR_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_STR_ov_dark_cprop
    return cls
    #|
def toPref(cls):
    cls.i_upd_anim_button = N1
    cls.i_upd_anim_button_dark = N1
    cls.i_upd_anim_button_ov = N1
    cls.i_upd_anim_button_ov_dark = N1
    return cls
    #|
def rBuDeco(ty, is_vec=False):
    def decoCls(cls):
        cls.set_ui_state_overridden = c_set_ui_state_overridden

        cls.evt_area_cut = c_evt_area_cut
        cls.evt_area_copy = c_evt_area_copy
        cls.evt_area_paste = c_evt_area_paste
        cls.evt_area_reset_single = c_evt_area_reset_single
        cls.evt_area_reset_all = c_evt_area_reset_all
        cls.evt_area_detail = c_evt_area_detail
        cls.evt_area_format = c_evt_area_format

        cls.evt_remove_from_keying_set = c_evt_remove_from_keying_set
        cls.evt_add_to_keying_set = c_evt_add_to_keying_set
        cls.evt_copy_full_data_path = c_evt_copy_full_data_path
        cls.evt_copy_data_path = c_evt_copy_data_path
        cls.evt_paste_full_data_path_as_driver = c_evt_paste_full_data_path_as_driver
        cls.evt_delete_driver = c_evt_delete_driver
        cls.evt_add_driver = c_evt_add_driver
        cls.evt_clear_keyframe = c_evt_clear_keyframe
        cls.evt_delete_keyframe = c_evt_delete_keyframe
        cls.evt_insert_keyframe = c_evt_insert_keyframe
        cls.evt_remove_override = c_evt_remove_override
        cls.evt_batch = c_evt_batch

        cls.bufn_keyframe = c_bufn_keyframe
        cls.get = c_get
        cls.set_text = c_set_text

        cls.outside_evt = c_outside_evt
        cls.i_dxy_anim_hover = c_dxy_anim_hover

        if is_vec:
            cls.r_height = c_r_height_vec
            cls.r_default_value = c_r_default_value_vec
            cls.to_modal_rm = c_to_modal_rm_vec
            cls.dark_anim = c_dark_anim_vec
        else:
            cls.r_height = c_r_height_int
            cls.r_default_value = c_r_default_value
            cls.to_modal_rm = c_to_modal_rm
            cls.dark_anim = c_dark_anim

        if ty == "VAL":
            cls.set_ui_state_link = c_set_ui_state_link
            cls.set_ui_state_default = c_set_ui_state_default
            cls.inside_evt = c_inside_evt
            cls.drag_untag = c_drag_untag

            if is_vec:
                cls.inside = c_inside_vec
                cls.set = c_set_vec

                cls.i_upd_anim_button = c_upd_button_keyframe_VAL_vec
                cls.i_upd_anim_button_dark = c_upd_button_keyframe_VAL_vec_dark
                cls.i_upd_anim_button_ov = c_upd_button_keyframe_VAL_vec_ov
                cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_VAL_vec_ov_dark
            else:
                cls.set = c_set
                cls.inside = c_inside

                cls.i_upd_anim_button = c_upd_button_keyframe_VAL
                cls.i_upd_anim_button_dark = c_upd_button_keyframe_VAL_dark
                cls.i_upd_anim_button_ov = c_upd_button_keyframe_VAL_ov
                cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_VAL_ov_dark
        elif ty == "BOOL":
            cls.set_ui_state_link = c_set_ui_state_link
            cls.set_ui_state_default = c_set_ui_state_default
            cls.inside_evt = c_inside_evt_bool

            if is_vec:
                cls.set = c_set_vec
                cls.inside = c_inside_bool_vec

                cls.i_upd_anim_button = c_upd_button_keyframe_BOOL_vec
                cls.i_upd_anim_button_dark = c_upd_button_keyframe_BOOL_vec_dark
                cls.i_upd_anim_button_ov = c_upd_button_keyframe_BOOL_vec_ov
                cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_BOOL_vec_ov_dark
            else:
                cls.set = c_set
                cls.inside = c_inside_bool

                cls.i_upd_anim_button = c_upd_button_keyframe_BOOL
                cls.i_upd_anim_button_dark = c_upd_button_keyframe_BOOL_dark
                cls.i_upd_anim_button_ov = c_upd_button_keyframe_BOOL_ov
                cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_BOOL_ov_dark
        elif ty == "STR":
            cls.set_ui_state_link = c_set_ui_state_link_STR
            cls.set_ui_state_default = c_set_ui_state_default_STR
            cls.inside = c_inside
            cls.inside_evt = c_inside_evt
            cls.set = c_set_str

            toNoAnim(cls)
        elif ty == "COLOR":
            cls.set = c_set_vec
            cls.set_ui_state_link = c_set_ui_state_link
            cls.set_ui_state_default = c_set_ui_state_default
            cls.inside = c_inside
            cls.inside_evt = c_inside_evt

            cls.r_default_value = c_r_default_value_vec
            cls.to_modal_rm = c_to_modal_rm_vec

            cls.i_upd_anim_button = c_upd_button_keyframe_COLOR
            cls.i_upd_anim_button_dark = c_upd_button_keyframe_COLOR_dark
            cls.i_upd_anim_button_ov = c_upd_button_keyframe_COLOR_ov
            cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_COLOR_ov_dark

            cls.bufn_keyframe = c_bufn_keyframe_group
        return cls
    return decoCls
    #|

#_c4#_c4#_c4#_c4

class BuValueSlots:
    __slots__ = (
    'identifier',
    'init_bat',
    'upd_data',
    'w',
    'rna',
    'pp',
    'r_pp',
    'box_button',
    'box_media',
    'box_hover',
    'box_anim',
    'blf_title',
    'blf_value',
    'text_format',
    'draw_box',
    'draw_blf',
    'dxy',
    'to_modal_drag_callfront',
    'end_modal_drag_callback',
    'inside_callback',
    'outside_callback',
    'set_callback',
    'isdark',
    'isdarkhard',
    'isdarkhard_prev',
    'overridden_state',
    'focus_element',
    'evtkill',
    'upd_anim_button',
    'is_trigger_anim_enable',
    'ui_anim_data',
    'r_button_width',
    'step',
    )
class BuBoolSlots:
    __slots__ = (
    'identifier',
    'init_bat',
    'upd_data',
    'w',
    'rna',
    'pp',
    'r_pp',
    'box_button',
    'box_hover',
    'box_anim',
    'blf_title',
    'draw_box',
    'draw_blf',
    'dxy',
    'set_callback',
    'isdark',
    'isdarkhard',
    'isdarkhard_prev',
    'overridden_state',
    'focus_element',
    'evtkill',
    'upd_anim_button',
    'is_trigger_anim_enable',
    'is_trigger_enable',
    'ui_anim_data',
    'r_button_width',
    )

@ assign(
    init_bat_anim = c_init_bat_anim_BuInt,
    i_draw_box = c_draw_box_BuInt,
    i_draw_box_anim = c_draw_box_anim_BuInt,
    i_draw_blf = c_draw_blf_BuInt)
@ focusInt
@ rBuDeco(ty="VAL")
class BuInt(BuValueSlots):
    __slots__ = ()

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data

        self.box_button = GpuRim(COL_box_val, COL_box_val_rim)
        self.box_anim = GpuImgNull()
        self.text_format = self.r_text_format()

        v = self.r_default_value()  if self.pp is None else self.get()
        self.blf_value = BlfClipColor(self.text_format(v), v, 0, 0, COL_box_val_fg)
        self.blf_title = BlfClipColor(unclip_text=rna.name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button
        #|

    def r_text_format(self):
        return D_format["INT"]
        #|

    def dark(self):
        # <<< 1copy (0defuiDark,, $$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_val_ignore
        self.box_button.color_rim = COL_box_val_rim_ignore
        self.blf_value.color = COL_box_val_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        #|
    def light(self):
        # <<< 1copy (0defuiLight,, $$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_val
        self.box_button.color_rim = COL_box_val_rim
        self.blf_value.color = COL_box_val_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        #|

    def modal(self):
        # <<< 1copy (0defuiModalValbox0,, $$)
        if MOUSE[0] < self.box_button.R:
            if MOUSE[0] < self.box_button.inner[0] + SIZE_widget[0]:
                if self.focus_element != 1:

                    self.focus_element = 1
                    Admin.REDRAW()
                    self.focus_media_left()

            elif MOUSE[0] >= self.box_button.inner[1] - SIZE_widget[0]:
                if self.focus_element != 2:

                    self.focus_element = 2
                    Admin.REDRAW()
                    self.focus_media_right()

            else:
                if self.focus_element != 0:

                    self.focus_element = 0
                    Admin.REDRAW()
                    self.focus_default()

        elif self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.is_trigger_anim_enable = True
                self.focus_element = 3
                Admin.REDRAW()
                self.focus_anim()

        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTrigger,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['valbox_drag']():
            self.to_modal_drag()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if hasattr(self, "evt_attr_toggle"):
            if TRIGGER['ui_attr_toggle']():
                self.evt_attr_toggle()
                return True
        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        # <<< 1copy (0defuiModalValboxClick,, $$)
        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_modal_drag_pre()
                return True
            elif i == 1:
                self.to_modal_media_left()
                return True
            elif i == 2:
                self.to_modal_media_right()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        # >>>
        #|

    def to_modal_drag_pre(self, override=None):

        if isinstance(override, tuple):
            end_trigger, mouseloop_end, mouseloop, r_dxy_mouse = override
            override = "POST"
        else:
            if override is None:
                if hasattr(self.w, "to_modal_join_column"):
                    self.w.to_modal_join_column(self)
                    return

            end_trigger = r_end_trigger('valbox_drag'  if override == "POST" else 'click')
            mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")

        _blf_value = self.blf_value

        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
        _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
        _xy = [0]
        _valbox_drag_fac = P.valbox_drag_fac_int
        _value_data = {'confirm': True}
        _set = self.set
        _th_drag = P.th_drag

        if hasattr(_blf_value, "unclip_text") and is_value(_blf_value.unclip_text): pass
        else: return
        _value_data["values"] = [(_blf_value.unclip_text, _blf_value.text)]

        if self.isdark is False: self.box_button.color = COL_box_val_active
        if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()

        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0, 0]
        _soft_threshold = max(1, round(2000 * _valbox_drag_fac))
        _soft_step = max(1, round(800 * _valbox_drag_fac))

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                _value_data["confirm"] = None
                w_head.fin()
                self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            if abs(_xy[0]) >= _th_drag:
                _xy[0] = 0
                _REDRAW()
                w_head.modal = modal_drag
                if _blf_value.unclip_text > _soft_max:
                    _soft_value[1] = _soft_threshold
                elif _blf_value.unclip_text < _soft_min:
                    _soft_value[0] = _soft_threshold

            mouseloop()

        def modal_drag():
            _REDRAW()

            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = False
                w_head.fin()
                return
            if end_trigger():
                w_head.fin()
                return

            dx, dy = r_dxy_mouse()
            if _TRIGGER_drag_fast(): dx *= 10
            elif _TRIGGER_drag_slow(): dx *= 0.1

            _xy[0] += dx * _valbox_drag_fac
            travel = _xy[0]
            if travel >= 1:
                dx = floor(travel)
                _xy[0] -= dx
            elif travel <= -1:
                dx = ceil(travel)
                _xy[0] -= dx
            else:
                mouseloop()
                return

            # <<< 1copy (0defuiIntModalDragSet,, $$)
            new_value = _blf_value.unclip_text + dx
            if _soft_value[1] >= _soft_threshold:
                if new_value < _soft_max:
                    _soft_value[1] -= _soft_step
                    if _soft_value[1] < 0: _soft_value[1] = 0
            else:
                if new_value > _soft_max:
                    _soft_value[1] += new_value - _soft_max
                    _soft_value[0] = 0
                    new_value = _soft_max
                else:
                    if _soft_value[0] >= _soft_threshold:
                        if new_value > _soft_min:
                            _soft_value[0] -= _soft_step
                            if _soft_value[0] < 0: _soft_value[0] = 0
                    else:
                        if new_value < _soft_min:
                            _soft_value[0] += _soft_min - new_value
                            _soft_value[1] = 0
                            new_value = _soft_min

            _set(new_value, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>
            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
            mouseloop_end()
            kill_evt_except()
            if self.isdark is True:
                self.box_button.color = COL_box_val_ignore
            else:
                self.box_button.color = COL_box_val_fo  if self.box_button.inbox(MOUSE) else COL_box_val

            if _value_data["confirm"] is None: pass
            else:
                _final_value = _blf_value.unclip_text
                _set(_value_data["values"][0][0], undo_push=False)

                if _value_data["confirm"] == True:
                    _set(_final_value)

            if hasattr(self, "end_modal_drag_callback"): self.end_modal_drag_callback()

            MODAL_DRAG_STATE[0] = -1

        if override == "POST":
            w_head = Head(self, modal_drag, end_modal_release)
        elif override == "MEDIA":
            def modal_media():
                _REDRAW()
                if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc() or end_trigger():
                    w_head.fin()
                    return

                dx, dy = r_dxy_mouse()
                _xy[0] += dx
                if abs(_xy[0]) >= P.th_drag:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                    _xy[0] = 0
                    Admin.REDRAW()
                    self.draw_box = self.i_draw_box
                    _valboxdata[0] = 0
                    w_head.modal = modal_drag

                mouseloop()

            w_head = Head(self, modal_media, end_modal_release)
        else:
            w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    def to_modal_drag(self):

        self.to_modal_drag_pre(override="POST")
        #|
    def to_modal_media_left(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0, 0]
        _soft_threshold = 20
        _soft_step = 8
        if _blf_value.unclip_text > _soft_max:
            _soft_value[1] = _soft_threshold
        elif _blf_value.unclip_text < _soft_min:
            _soft_value[0] = _soft_threshold

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiIntModalDragSet,, ${'+ dx':'- 1'}$)
            new_value = _blf_value.unclip_text - 1
            if _soft_value[1] >= _soft_threshold:
                if new_value < _soft_max:
                    _soft_value[1] -= _soft_step
                    if _soft_value[1] < 0: _soft_value[1] = 0
            else:
                if new_value > _soft_max:
                    _soft_value[1] += new_value - _soft_max
                    _soft_value[0] = 0
                    new_value = _soft_max
                else:
                    if _soft_value[0] >= _soft_threshold:
                        if new_value > _soft_min:
                            _soft_value[0] -= _soft_step
                            if _soft_value[0] < 0: _soft_value[0] = 0
                    else:
                        if new_value < _soft_min:
                            _soft_value[0] += _soft_min - new_value
                            _soft_value[1] = 0
                            new_value = _soft_min

            _set(new_value, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    def to_modal_media_right(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0, 0]
        _soft_threshold = 20
        _soft_step = 8
        if _blf_value.unclip_text > _soft_max:
            _soft_value[1] = _soft_threshold
        elif _blf_value.unclip_text < _soft_min:
            _soft_value[0] = _soft_threshold

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiIntModalDragSet,, ${'+ dx':'+ 1'}$)
            new_value = _blf_value.unclip_text + 1
            if _soft_value[1] >= _soft_threshold:
                if new_value < _soft_max:
                    _soft_value[1] -= _soft_step
                    if _soft_value[1] < 0: _soft_value[1] = 0
            else:
                if new_value > _soft_max:
                    _soft_value[1] += new_value - _soft_max
                    _soft_value[0] = 0
                    new_value = _soft_max
                else:
                    if _soft_value[0] >= _soft_threshold:
                        if new_value > _soft_min:
                            _soft_value[0] -= _soft_step
                            if _soft_value[0] < 0: _soft_value[0] = 0
                    else:
                        if new_value < _soft_min:
                            _soft_value[0] += _soft_min - new_value
                            _soft_value[1] = 0
                            new_value = _soft_min

            _set(new_value, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    def to_dropdown(self):

        o = self.blf_value
        DropDownVal(self, self.box_button.r_LRBT(), o.text, o.unclip_text, self.rna)
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        #|
    def i_dxy_media(self, dx, dy):
        self.i_dxy(dx, dy)
        self.box_media.dxy_upd(dx, dy)
        #|
    def i_dxy_subtype(self, dx, dy):
        # <<< 1copy (0defuiDxySubtype,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        self.blf_subtype.x += dx
        self.blf_subtype.y += dy
        # >>>
        #|

    def i_draw_box_media(self):
        # <<< 1copy (0defuiDrawboxMedia,, $$)
        self.box_button.bind_draw()
        self.box_media.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        #|

    def i_draw_blf_subtype(self):
        # <<< 1copy (0defuiDrawblfSubtype,, $$)
        # <<< 1copy (0defuiDrawblf,, $$)
        e = self.blf_value
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        e = self.blf_title
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        # >>>

        e = self.blf_subtype
        blfSize(FONT0, D_SIZE['font_label'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        # >>>
        #|

    def upd_data(self):
        # <<< 1copy (0defuiUpdDataFormat,, $$)
        self.upd_anim_button()
        if self.blf_value.unclip_text == getattr(self.pp, self.identifier): return


        v = getattr(self.pp, self.identifier)
        self.blf_value.unclip_text = v
        self.blf_value.text = self.text_format(v)
        # >>>
        #|
    #|
    #|
class BuFloat(BuInt):
    __slots__ = ()

    def r_text_format(self):
        if self.rna.subtype == "PIXEL":
            return lambda x: f'{D_format[self.rna.unit](x)} px'
        else:
            return D_format[self.rna.unit]
        #|

    def to_modal_drag_pre(self, override=None):

        if isinstance(override, tuple):
            end_trigger, mouseloop_end, mouseloop, r_dxy_mouse = override
            override = "POST"
        else:
            if override is None:
                if hasattr(self.w, "to_modal_join_column"):
                    self.w.to_modal_join_column(self)
                    return

            end_trigger = r_end_trigger('valbox_drag'  if override == "POST" else 'click')
            mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")

        _blf_value = self.blf_value

        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
        _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
        _xy = [0]
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _value_data = {'confirm': True}
        _set = self.set
        _th_drag = P.th_drag

        if hasattr(_blf_value, "unclip_text") and is_value(_blf_value.unclip_text): pass
        else: return
        _value_data["values"] = [(_blf_value.unclip_text, _blf_value.text)]

        if self.isdark is False: self.box_button.color = COL_box_val_active
        if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()

        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 1000.0 * _valbox_drag_fac

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                _value_data["confirm"] = None
                w_head.fin()
                self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            if abs(_xy[0]) >= _th_drag:
                _xy[0] = 0
                _REDRAW()
                w_head.modal = modal_drag
                if _blf_value.unclip_text > _soft_max:
                    _soft_value[1] = _soft_threshold
                elif _blf_value.unclip_text < _soft_min:
                    _soft_value[0] = _soft_threshold

            mouseloop()

        def modal_drag():
            _REDRAW()

            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = False
                w_head.fin()
                return
            if end_trigger():
                w_head.fin()
                return

            dx, dy = r_dxy_mouse()
            if _TRIGGER_drag_fast(): dx *= _valbox_drag_fac * 10
            elif _TRIGGER_drag_slow(): dx *= _valbox_drag_fac * 0.1
            else: dx *= _valbox_drag_fac

            # <<< 1copy (0defuiFloatModalDragSet,, $$)
            try:
                v_float = _blf_value.unclip_text + dx

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                mouseloop()
                return

            _set(v_float, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>
            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
            mouseloop_end()
            kill_evt_except()
            if self.isdark:
                self.box_button.color = COL_box_val_ignore
            else:
                self.box_button.color = COL_box_val_fo  if self.box_button.inbox(MOUSE) else COL_box_val

            if _value_data["confirm"] is None: pass
            else:
                _final_value = _blf_value.unclip_text
                _set(_value_data["values"][0][0], undo_push=False)

                if _value_data["confirm"] == True:
                    _set(_final_value)

            if hasattr(self, "end_modal_drag_callback"): self.end_modal_drag_callback()

            MODAL_DRAG_STATE[0] = -1

        if override == "POST":
            w_head = Head(self, modal_drag, end_modal_release)
        elif override == "MEDIA":
            def modal_media():
                _REDRAW()
                if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc() or end_trigger():
                    w_head.fin()
                    return

                dx, dy = r_dxy_mouse()
                _xy[0] += dx
                if abs(_xy[0]) >= P.th_drag:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                    _xy[0] = 0
                    Admin.REDRAW()
                    self.draw_box = self.i_draw_box
                    _valboxdata[0] = 0
                    w_head.modal = modal_drag

                mouseloop()

            w_head = Head(self, modal_media, end_modal_release)
        else:
            w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    def to_modal_media_left(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 20.0 * _valbox_drag_fac
        if _blf_value.unclip_text > _soft_max:
            _soft_value[1] = _soft_threshold
        elif _blf_value.unclip_text < _soft_min:
            _soft_value[0] = _soft_threshold

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiFloatModalDragSet,, ${'+ dx':'- _valbox_drag_fac', 'mouseloop()':''}$)
            try:
                v_float = _blf_value.unclip_text - _valbox_drag_fac

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                
                return

            _set(v_float, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    def to_modal_media_right(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 20.0 * _valbox_drag_fac
        if _blf_value.unclip_text > _soft_max:
            _soft_value[1] = _soft_threshold
        elif _blf_value.unclip_text < _soft_min:
            _soft_value[0] = _soft_threshold

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiFloatModalDragSet,, ${'+ dx':'+ _valbox_drag_fac', 'mouseloop()':''}$)
            try:
                v_float = _blf_value.unclip_text + _valbox_drag_fac

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                
                return

            _set(v_float, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    #|
    #|

@ focusIntvec
@ rBuDeco(ty="VAL", is_vec=True)
class BuIntVec(BuValueSlots):
    __slots__ = 'box_active', 'array_length', 'vec_range'

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data
        self.array_length = rna.array_length
        self.vec_range = range(self.array_length)

        vv = self.r_default_value()  if self.pp is None else self.get()
        self.box_button = GpuRim(COL_box_val, COL_box_val_rim)
        self.box_active = GpuBox(COL_box_val_fo)
        self.box_anim = [GpuImgNull()  for v in vv]
        self.text_format = self.r_text_format()

        self.blf_value = [BlfClip(self.text_format(v), v)  for v in vv]
        self.blf_value[0].color = COL_box_val_fg

        self.blf_title = BlfClipColor(unclip_text=rna.name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button
        #|

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        h = SIZE_widget[0]
        R2 = RR - h
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h'] - (self.array_length - 1) * h
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        blf_title = self.blf_title
        blf_x = L + widget_rim + D_SIZE['font_main_dx']
        blf_y = TT - widget_rim - D_SIZE['font_main_dT']
        blf_title.y = blf_y

        T0 = TT - widget_rim
        B0 = T0 - h
        for e, o in zip(self.blf_value, self.box_anim):
            e.x = blf_x
            e.y = blf_y

            o.LRBT_upd(R2, RR, B0, T0)
            blf_y -= h
            B0 -= h
            T0 -= h

        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_title.text = r_blf_clipping_end(blf_title.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        blf_title.x = R0 - round(blfDimen(FONT0, blf_title.text)[0])
        return B
        #|

    def r_text_format(self):
        return D_format["INT"]
        #|

    def dark(self):
        # <<< 1copy (0defuiDarkvec,, $$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_val_ignore
        self.box_button.color_rim = COL_box_val_rim_ignore
        for e in self.blf_value:
            e.color = COL_box_val_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        #|
    def light(self):
        # <<< 1copy (0defuiLightvec,, $$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_val
        self.box_button.color_rim = COL_box_val_rim
        for e in self.blf_value:
            e.color = COL_box_val_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        #|

    def modal(self):
        # <<< 1copy (0defuiModalValboxvec0,, $$)
        h = SIZE_widget[0]

        if MOUSE[0] < self.box_button.R:
            ind = min(max(0, (MOUSE[1] - self.box_button.inner[3]) // - h), self.array_length - 1)

            if MOUSE[0] < self.box_button.inner[0] + h:
                if self.focus_element != (ind, 1):

                    self.focus_element = (ind, 1)
                    Admin.REDRAW()
                    self.focus_media_left(ind)

            elif MOUSE[0] >= self.box_button.inner[1] - h:
                if self.focus_element != (ind, 2):

                    self.focus_element = (ind, 2)
                    Admin.REDRAW()
                    self.focus_media_right(ind)
            else:
                if self.focus_element != (ind, 0):

                    self.focus_element = (ind, 0)
                    Admin.REDRAW()
                    self.focus_default(ind)

        elif self.box_anim[0].L <= MOUSE[0]:
            ind = min(max(0, (MOUSE[1] - self.box_button.inner[3]) // - h), self.array_length - 1)

            if self.focus_element != (ind, 3):

                self.focus_element = (ind, 3)
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim(ind)
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTrigger,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['valbox_drag']():
            self.to_modal_drag()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if hasattr(self, "evt_attr_toggle"):
            if TRIGGER['ui_attr_toggle']():
                self.evt_attr_toggle()
                return True
        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            if isinstance(self.focus_element, tuple):
                ind, i = self.focus_element
                if i == 0:
                    self.to_modal_drag_pre()
                    return True
                elif i == 1:
                    self.to_modal_media_left()
                    return True
                elif i == 2:
                    self.to_modal_media_right()
                    return True
                elif i == 3:
                    # <<< 1copy (0defuiClickAnim,, ${'box_anim':'box_anim[ind]'}$)
                    if self.is_trigger_anim_enable is True:
                        self.is_trigger_anim_enable = False
                        if is_first_press('click') == False:
                            boo = self.box_anim[ind].__class__ in S_icon_keyframe_true
                            if _last_bool_state[0] != boo:
                                self.bufn_keyframe()
                        else:
                            self.bufn_keyframe()
                            _last_bool_state[0] = self.box_anim[ind].__class__ in S_icon_keyframe_true
                    return True
                    # >>>
        return False
        #|

    def to_modal_drag_pre(self, override=None):

        _blf_value = self.blf_value

        end_trigger = r_end_trigger('valbox_drag'  if override == "POST" else 'click')
        mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")
        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
        _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
        _xy = [0, 0]
        _valbox_drag_fac = P.valbox_drag_fac_int
        _value_data = {'confirm': True}
        _set = self.set
        _th_drag = P.th_drag
        _h = SIZE_widget[0]
        _box_active_LRBT_upd = self.box_active.LRBT_upd

        if hasattr(_blf_value[0], "unclip_text") and is_value(_blf_value[0].unclip_text): pass
        else: return

        _value_data["values"] = [e.unclip_text  for e in _blf_value]

        if self.isdark is False: self.box_active.color = COL_box_val_active
        if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                ind = self.focus_element
                _value_data["confirm"] = None
                w_head.fin()
                self.focus_element = ind
                self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if abs(_xy[0]) >= P.th_drag:
                _xy[0] = 0
                _REDRAW()
                w_head.modal = modal_drag
            elif abs(_xy[1]) >= P.th_drag:
                _xy[0] = 0
                _xy[1] = 0
                _REDRAW()
                w_head.modal = modal_drag_pre_array
                _value_data["end_index"] = self.focus_element[0]

            mouseloop()

        def modal_drag():
            _REDRAW()

            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = False
                w_head.fin()
                return
            if end_trigger():
                w_head.fin()
                return

            dx, dy = r_dxy_mouse()
            if _TRIGGER_drag_fast(): dx *= 10
            elif _TRIGGER_drag_slow(): dx *= 0.1

            _xy[0] += dx * _valbox_drag_fac
            travel = _xy[0]
            if travel >= 1:
                dx = floor(travel)
                _xy[0] -= dx
            elif travel <= -1:
                dx = ceil(travel)
                _xy[0] -= dx
            else:
                mouseloop()
                return

            # <<< 1copy (0defuiIntvecModalDragSet,, $$)
            e = _blf_value[self.focus_element[0]]
            _set(e.unclip_text + dx, self.focus_element[0], undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>
            mouseloop()

        def modal_drag_pre_array():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                i0 = self.focus_element
                _value_data["confirm"] = None
                w_head.fin()
                self.focus_element = i0
                i0 = i0[0]

                ind = _value_data["end_index"]
                if i0 > ind: i0, ind = ind, i0
                if i0 == ind:
                    self.to_dropdown()
                else:
                    self.to_dropdown(range(i0, ind + 1), _value_data["end_index"])
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if _xy[1] < - _h:
                d = (- _xy[1]) // _h
                _xy[1] += _h * d
                _xy[0] = 0
                ind = min(_value_data["end_index"] + d, self.array_length - 1)
            elif _xy[1] > _h:
                d = _xy[1] // _h
                _xy[1] -= _h * d
                _xy[0] = 0
                ind = max(0, _value_data["end_index"] - d)
            else:
                ind = _value_data["end_index"]

            if ind != _value_data["end_index"]:
                _value_data["end_index"] = ind
                L, R, B, T = self.box_button.inner
                i0 = self.focus_element[0]
                if i0 > ind: i0, ind = ind, i0
                T -= i0 * _h
                B = T - _h * (ind - i0 + 1)
                _REDRAW()
                _box_active_LRBT_upd(L, R, B, T)

            if abs(_xy[0]) >= _h:
                _xy[0] = 0
                _REDRAW()
                i0 = self.focus_element[0]
                ind = _value_data["end_index"]
                if i0 > ind: i0, ind = ind, i0
                _value_data["array_range"] = range(i0, ind + 1)
                _value_data["array_index"] = i0, ind + 1

                def modal_drag_array():
                    _REDRAW()

                    if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                        _value_data["confirm"] = False
                        w_head.fin()
                        return
                    if end_trigger():
                        w_head.fin()
                        return

                    dx, dy = r_dxy_mouse()
                    if _TRIGGER_drag_fast(): dx *= 10
                    elif _TRIGGER_drag_slow(): dx *= 0.1

                    _xy[0] += dx * _valbox_drag_fac
                    travel = _xy[0]
                    if travel >= 1:
                        dx = floor(travel)
                        _xy[0] -= dx
                    elif travel <= -1:
                        dx = ceil(travel)
                        _xy[0] -= dx
                    else:
                        mouseloop()
                        return

                    _set([_blf_value[r].unclip_text + dx  for r in _value_data["array_range"]],
                        _value_data["array_index"], undo_push=False)
                    if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
                    mouseloop()

                w_head.modal = modal_drag_array

            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
            mouseloop_end()
            kill_evt_except()
            self.box_active.color = COL_box_val_fo

            if _value_data["confirm"] is None: pass
            else:
                if "array_range" in _value_data:
                    e = _value_data["array_range"]
                    _final_value = [_blf_value[i].unclip_text  for i in e]
                    _final_index = (e.start, e.stop)
                else:
                    i = self.focus_element[0]
                    _final_value = _blf_value[i].unclip_text
                    _final_index = i

                _set(_value_data["values"], (0, self.array_length), undo_push=False)

                if _value_data["confirm"] == True:
                    _set(_final_value, _final_index)

            self.focus_element = -1
            if hasattr(self, "end_modal_drag_callback"): self.end_modal_drag_callback()

            MODAL_DRAG_STATE[0] = -1

        if override == "POST":
            w_head = Head(self, modal_drag, end_modal_release)
        elif override == "MEDIA":
            def modal_media():
                _REDRAW()
                if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc() or end_trigger():
                    w_head.fin()
                    return

                dx, dy = r_dxy_mouse()
                _xy[0] += dx
                if abs(_xy[0]) >= P.th_drag:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                    _xy[0] = 0
                    Admin.REDRAW()
                    self.draw_box = self.i_draw_box
                    _valboxdata[0] = 0
                    w_head.modal = modal_drag

                mouseloop()

            w_head = Head(self, modal_media, end_modal_release)
        else:
            w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    def to_modal_drag(self):

        self.to_modal_drag_pre(override="POST")
        #|
    def to_modal_media_left(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiIntvecModalDragSet,, ${'+ dx':'- 1'}$)
            e = _blf_value[self.focus_element[0]]
            _set(e.unclip_text - 1, self.focus_element[0], undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    def to_modal_media_right(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiIntvecModalDragSet,, ${'+ dx':'+ 1'}$)
            e = _blf_value[self.focus_element[0]]
            _set(e.unclip_text + 1, self.focus_element[0], undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    def to_dropdown(self, array_range=None, end_index=None):

        ind = self.focus_element[0]  if array_range == None else end_index
        self.focus_element = -1

        o = self.blf_value[ind]
        h = SIZE_widget[0]
        widget_rim = SIZE_border[3]
        L, R, B, T = self.box_button.inner
        L -= widget_rim
        R += widget_rim
        T -= h * ind
        B = T - h - widget_rim
        T += widget_rim

        if array_range == None: array_range = range(ind, ind + 1)
        DropDownVal(self, (L, R, B, T), o.text, o.unclip_text, self.rna, array_range)
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiDxyVec,, $$)
        self.box_button.dxy_upd(dx, dy)
        for e in self.box_anim:
            e.dxy_upd(dx, dy)

        for e in self.blf_value:
            e.x += dx
            e.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        #|
    def i_dxy_media(self, dx, dy):
        self.i_dxy(dx, dy)
        self.box_media.dxy_upd(dx, dy)
        self.box_active.dxy_upd(dx, dy)
        #|

    def i_draw_box(self):
        # <<< 1copy (0defuiDrawboxVec,, $$)
        self.box_button.bind_draw()
        for e in self.box_anim:
            e.bind_draw()
        # >>>
        #|
    def i_draw_box_media(self):
        # <<< 1copy (0defuiDrawboxMediaVec,, $$)
        self.box_button.bind_draw()
        self.box_active.bind_draw()
        self.box_media.bind_draw()
        for e in self.box_anim:
            e.bind_draw()
        # >>>
        #|
    def i_draw_box_anim(self):
        # <<< 1copy (0defuiDrawboxAnimVec,, $$)
        self.box_button.bind_draw()
        for e in self.box_anim:
            e.bind_draw()
        self.box_hover.bind_draw()
        # >>>
        #|
    def i_draw_blf(self):
        # <<< 1copy (0defuiDrawblfVec,, $$)
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *self.blf_value[0].color)
        for e in self.blf_value:
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)

        e = self.blf_title
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        # >>>
        #|

    def upd_data(self):
        # <<< 1copy (0defuiUpdDataFormatVec,, $$)
        self.upd_anim_button()
        for e, o in zip(self.blf_value, getattr(self.pp, self.identifier)):
            if e.unclip_text == o: continue

            e.unclip_text = o
            e.text = self.text_format(o)
        # >>>
        #|
    #|
    #|
class BuFloatVec(BuIntVec):
    __slots__ = ()

    def r_text_format(self):
        return D_format[self.rna.unit]
        #|

    def to_modal_drag_pre(self, override=None):

        _blf_value = self.blf_value

        end_trigger = r_end_trigger('valbox_drag'  if override == "POST" else 'click')
        mouseloop_end, mouseloop, r_dxy_mouse = r_mouseloop(loop_type="NONE", cursor_icon="NONE")
        _REDRAW = Admin.REDRAW
        _EVT_TYPE = EVT_TYPE
        _TRIGGER_esc = TRIGGER['esc']
        _TRIGGER_drag_fast = TRIGGER['valbox_drag_modal_fast']
        _TRIGGER_drag_slow = TRIGGER['valbox_drag_modal_slow']
        _xy = [0, 0]
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _value_data = {'confirm': True}
        _set = self.set
        _th_drag = P.th_drag
        _h = SIZE_widget[0]
        _box_active_LRBT_upd = self.box_active.LRBT_upd

        if hasattr(_blf_value[0], "unclip_text") and is_value(_blf_value[0].unclip_text): pass
        else: return

        _value_data["values"] = [e.unclip_text  for e in _blf_value]

        if self.isdark is False: self.box_active.color = COL_box_val_active
        if hasattr(self, "to_modal_drag_callfront"): self.to_modal_drag_callfront()

        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 1000.0 * _valbox_drag_fac

        def modal_drag_pre():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                ind = self.focus_element
                _value_data["confirm"] = None
                w_head.fin()
                self.focus_element = ind
                self.to_dropdown()
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if abs(_xy[0]) >= _th_drag:
                _xy[0] = 0
                _REDRAW()
                w_head.modal = modal_drag
                nonlocal _blf_value_fo, _index_
                _index_ = self.focus_element[0]
                _blf_value_fo = _blf_value[_index_]
                if _blf_value_fo.unclip_text > _soft_max:
                    _soft_value[1] = _soft_threshold
                elif _blf_value_fo.unclip_text < _soft_min:
                    _soft_value[0] = _soft_threshold

            elif abs(_xy[1]) >= _th_drag:
                _xy[0] = 0
                _xy[1] = 0
                _REDRAW()
                w_head.modal = modal_drag_pre_array
                _value_data["end_index"] = self.focus_element[0]

            mouseloop()

        _blf_value_fo = None
        _index_ = None
        def modal_drag():
            _REDRAW()

            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = False
                w_head.fin()
                return
            if end_trigger():
                w_head.fin()
                return

            dx, dy = r_dxy_mouse()
            if _TRIGGER_drag_fast(): dx *= _valbox_drag_fac * 10
            elif _TRIGGER_drag_slow(): dx *= _valbox_drag_fac * 0.1
            else: dx *= _valbox_drag_fac

            # <<< 1copy (0defuiFloatvecModalDragSet,, $$)
            try:
                v_float = _blf_value_fo.unclip_text + dx

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                mouseloop()
                return
            _set(v_float, _index_, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>
            mouseloop()

        def modal_drag_pre_array():
            if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                _value_data["confirm"] = None
                w_head.fin()
                return

            if end_trigger():
                mouseloop()
                i0 = self.focus_element
                _value_data["confirm"] = None
                w_head.fin()
                self.focus_element = i0
                i0 = i0[0]

                ind = _value_data["end_index"]
                if i0 > ind: i0, ind = ind, i0
                if i0 == ind:
                    self.to_dropdown()
                else:
                    self.to_dropdown(range(i0, ind + 1), _value_data["end_index"])
                return

            dx, dy = r_dxy_mouse()
            _xy[0] += dx
            _xy[1] += dy

            if _xy[1] < - _h:
                d = (- _xy[1]) // _h
                _xy[1] += _h * d
                _xy[0] = 0
                ind = min(_value_data["end_index"] + d, self.array_length - 1)
            elif _xy[1] > _h:
                d = _xy[1] // _h
                _xy[1] -= _h * d
                _xy[0] = 0
                ind = max(0, _value_data["end_index"] - d)
            else:
                ind = _value_data["end_index"]

            if ind != _value_data["end_index"]:
                _value_data["end_index"] = ind
                L, R, B, T = self.box_button.inner
                i0 = self.focus_element[0]
                if i0 > ind: i0, ind = ind, i0
                T -= i0 * _h
                B = T - _h * (ind - i0 + 1)
                _REDRAW()
                _box_active_LRBT_upd(L, R, B, T)

            if abs(_xy[0]) >= _h:
                _xy[0] = 0
                _REDRAW()
                i0 = self.focus_element[0]
                ind = _value_data["end_index"]
                init_ind = ind

                if i0 > ind: i0, ind = ind, i0
                _value_data["array_range"] = range(i0, ind + 1)
                _value_data["array_index"] = i0, ind + 1
                le = len(_value_data["array_range"])
                _index_ = _value_data["array_index"]
                _blf_value_fo = _blf_value[init_ind]

                _set([_blf_value_fo.unclip_text] * le, _index_, undo_push=False)
                if _blf_value_fo.unclip_text > _soft_max:
                    _soft_value[1] = _soft_threshold
                elif _blf_value_fo.unclip_text < _soft_min:
                    _soft_value[0] = _soft_threshold

                def modal_drag_array():
                    _REDRAW()

                    if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc():
                        _value_data["confirm"] = False
                        w_head.fin()
                        return
                    if end_trigger():
                        w_head.fin()
                        return

                    dx, dy = r_dxy_mouse()
                    if _TRIGGER_drag_fast(): dx *= _valbox_drag_fac * 10
                    elif _TRIGGER_drag_slow(): dx *= _valbox_drag_fac * 0.1
                    else: dx *= _valbox_drag_fac

                    # <<< 1copy (0defuiFloatvecModalDragSet,, ${
                    #     '_set(v_float': '_set([v_float] * le'
                    # }$)
                    try:
                        v_float = _blf_value_fo.unclip_text + dx

                        if _soft_value[1] >= _soft_threshold:
                            if v_float < _soft_max:
                                _soft_value[1] /= 2.0
                        else:
                            if v_float > _soft_max:
                                _soft_value[1] += v_float - _soft_max
                                _soft_value[0] = 0.0
                                v_float = _soft_max
                            else:
                                if _soft_value[0] >= _soft_threshold:
                                    if v_float > _soft_min:
                                        _soft_value[0] /= 2.0
                                else:
                                    if v_float < _soft_min:
                                        _soft_value[0] += _soft_min - v_float
                                        _soft_value[1] = 0.0
                                        v_float = _soft_min
                    except:
                        mouseloop()
                        return
                    _set([v_float] * le, _index_, undo_push=False)
                    if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
                    # >>>
                    mouseloop()

                w_head.modal = modal_drag_array

            mouseloop()

        def end_modal_release():
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
            mouseloop_end()
            kill_evt_except()
            self.box_active.color = COL_box_val_fo

            if _value_data["confirm"] is None: pass
            else:
                if "array_range" in _value_data:
                    e = _value_data["array_range"]
                    _final_value = [_blf_value[i].unclip_text  for i in e]
                    _final_index = (e.start, e.stop)
                else:
                    i = self.focus_element[0]
                    _final_value = _blf_value[i].unclip_text
                    _final_index = i

                _set(_value_data["values"], (0, self.array_length), undo_push=False)

                if _value_data["confirm"] == True:
                    _set(_final_value, _final_index)

            self.focus_element = -1
            if hasattr(self, "end_modal_drag_callback"): self.end_modal_drag_callback()
            MODAL_DRAG_STATE[0] = -1

        if override == "POST":
            w_head = Head(self, modal_drag, end_modal_release)
            _index_ = self.focus_element[0]
            _blf_value_fo = _blf_value[_index_]
            if _blf_value_fo.unclip_text > _soft_max:
                _soft_value[1] = _soft_threshold
            elif _blf_value_fo.unclip_text < _soft_min:
                _soft_value[0] = _soft_threshold

        elif override == "MEDIA":
            def modal_media():
                _REDRAW()
                if (_EVT_TYPE[0] == 'ESC' and _EVT_TYPE[1] == 'PRESS') or _TRIGGER_esc() or end_trigger():
                    w_head.fin()
                    return

                dx, dy = r_dxy_mouse()
                _xy[0] += dx
                if abs(_xy[0]) >= P.th_drag:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                    _xy[0] = 0
                    Admin.REDRAW()
                    self.draw_box = self.i_draw_box
                    _valboxdata[0] = 0
                    w_head.modal = modal_drag
                    nonlocal _blf_value_fo, _index_
                    _index_ = self.focus_element[0]
                    _blf_value_fo = _blf_value[_index_]

                    if _blf_value_fo.unclip_text > _soft_max:
                        _soft_value[1] = _soft_threshold
                    elif _blf_value_fo.unclip_text < _soft_min:
                        _soft_value[0] = _soft_threshold

                mouseloop()

            w_head = Head(self, modal_media, end_modal_release)
        else:
            w_head = Head(self, modal_drag_pre, end_modal_release)
        MODAL_DRAG_STATE[0] = 0
        _REDRAW()
        #|
    def to_modal_media_left(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _index_ = self.focus_element[0]
        _blf_value_fo = _blf_value[_index_]

        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 20.0 * _valbox_drag_fac

        if _blf_value_fo.unclip_text > _soft_max:
            _soft_value[1] = _soft_threshold
        elif _blf_value_fo.unclip_text < _soft_min:
            _soft_value[0] = _soft_threshold

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiFloatvecModalDragSet,, ${'+ dx':'- _valbox_drag_fac', 'mouseloop()':''}$)
            try:
                v_float = _blf_value_fo.unclip_text - _valbox_drag_fac

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                
                return
            _set(v_float, _index_, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    def to_modal_media_right(self):

        self.to_modal_drag_pre(override="MEDIA")

        _set = self.set
        _blf_value = self.blf_value
        _valbox_drag_fac = max(0.0001, P.valbox_drag_fac_float * (self.step  if hasattr(self, "step") else self.rna.step) * 0.01)
        _index_ = self.focus_element[0]
        _blf_value_fo = _blf_value[_index_]

        _soft_min = self.rna.soft_min
        _soft_max = self.rna.soft_max
        _soft_value = [0.0, 0.0]
        _soft_threshold = 20.0 * _valbox_drag_fac

        if _blf_value_fo.unclip_text > _soft_max:
            _soft_value[1] = _soft_threshold
        elif _blf_value_fo.unclip_text < _soft_min:
            _soft_value[0] = _soft_threshold

        global _timer_button_fn
        def _timer_button_fn():
            # <<< 1copy (0defuiFloatvecModalDragSet,, ${'+ dx':'+ _valbox_drag_fac', 'mouseloop()':''}$)
            try:
                v_float = _blf_value_fo.unclip_text + _valbox_drag_fac

                if _soft_value[1] >= _soft_threshold:
                    if v_float < _soft_max:
                        _soft_value[1] /= 2.0
                else:
                    if v_float > _soft_max:
                        _soft_value[1] += v_float - _soft_max
                        _soft_value[0] = 0.0
                        v_float = _soft_max
                    else:
                        if _soft_value[0] >= _soft_threshold:
                            if v_float > _soft_min:
                                _soft_value[0] /= 2.0
                        else:
                            if v_float < _soft_min:
                                _soft_value[0] += _soft_min - v_float
                                _soft_value[1] = 0.0
                                v_float = _soft_min
            except:
                
                return
            _set(v_float, _index_, undo_push=False)
            if MODAL_DRAG_STATE[0] == 0: MODAL_DRAG_STATE[0] = 1
            # >>>

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|
    #|
    #|
class BuSub:
    __slots__ = ()

    def init_subtype(self, titles):
        self.blf_subtype = [Blf(tx)  for _, tx in zip(self.blf_value, titles)]
        self.blf_subtype[0].color = COL_box_button_fg_info
        #|
    def init_subtype_dimen(self, titles, dimen_titles):
        self.blf_subtype = [BlfClip(tx, dimen_tx)  for _, tx, dimen_tx in zip(self.blf_value, titles, dimen_titles)]
        self.blf_subtype[0].color = COL_box_button_fg_info
        #|

    def dark(self):
        super().dark()
        self.blf_subtype[0].color = COL_block_fg_ignore
        #|
    def light(self):
        super().light()
        self.blf_subtype[0].color = COL_box_button_fg_info
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiDxyVecSubtype,, $$)
        # <<< 1copy (0defuiDxyVec,, $$)
        self.box_button.dxy_upd(dx, dy)
        for e in self.box_anim:
            e.dxy_upd(dx, dy)

        for e in self.blf_value:
            e.x += dx
            e.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        for e in self.blf_subtype:
            e.x += dx
            e.y += dy
        # >>>
        #|
    def i_draw_blf(self):
        blfSize(FONT1, D_SIZE['font_label'])
        blfColor(FONT1, *self.blf_subtype[0].color)
        for e in self.blf_subtype:
            blfPos(FONT1, e.x, e.y, 0)
            blfDraw(FONT1, e.text)

        # <<< 1copy (0defuiDrawblfVec,, $$)
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *self.blf_value[0].color)
        for e in self.blf_value:
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)

        e = self.blf_title
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        # >>>
        #|

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        h = SIZE_widget[0]
        R2 = RR - h
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h'] - (self.array_length - 1) * h
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        blf_title = self.blf_title
        blf_x = L + widget_rim + D_SIZE['font_main_dx']
        blf_y = TT - widget_rim - D_SIZE['font_main_dT']
        blf_title.y = blf_y

        T0 = TT - widget_rim
        B0 = T0 - h
        for e, o, u in zip(self.blf_value, self.box_anim, self.blf_subtype):
            e.x = blf_x
            e.y = blf_y
            u.y = blf_y

            o.LRBT_upd(R2, RR, B0, T0)
            blf_y -= h
            B0 -= h
            T0 -= h

        blfSize(FONT1, D_SIZE['font_label'])
        xx = L - D_SIZE['font_label_dx']
        if hasattr(self.blf_subtype[0], "unclip_text"):
            for u in self.blf_subtype:
                u.x = xx - round(blfDimen(FONT1, u.unclip_text)[0])
        else:
            for u in self.blf_subtype:
                u.x = xx - round(blfDimen(FONT1, u.text)[0])

        R0 = self.blf_subtype[0].x - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_title.text = r_blf_clipping_end(blf_title.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        blf_title.x = R0 - round(blfDimen(FONT0, blf_title.text)[0])
        return B
        #|

    def init_bat_anim_L(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        h = SIZE_widget[0]
        L = RR - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h'] - (self.array_length - 1) * h
        self.box_button.LRBT_upd(L, RR, B, TT, widget_rim)

        blf_title = self.blf_title
        blf_x = L + widget_rim + D_SIZE['font_main_dx']
        blf_y = TT - widget_rim - D_SIZE['font_main_dT']
        blf_title.y = blf_y

        T0 = TT - widget_rim
        B0 = T0 - h

        blfSize(FONT1, D_SIZE['font_label'])
        font_label_dx = D_SIZE['font_label_dx']
        xx = L - font_label_dx
        if hasattr(self.blf_subtype[0], "unclip_text"):
            for u in self.blf_subtype:
                u.x = xx - round(blfDimen(FONT1, u.unclip_text)[0])
        else:
            for u in self.blf_subtype:
                u.x = xx - round(blfDimen(FONT1, u.text)[0])

        for e, o, u in zip(self.blf_value, self.box_anim, self.blf_subtype):
            e.x = blf_x
            e.y = blf_y
            u.y = blf_y

            R2 = u.x - font_label_dx
            o.LRBT_upd(R2 - h, R2, B0, T0)
            blf_y -= h
            B0 -= h
            T0 -= h

        R0 = self.blf_subtype[0].x - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_title.text = r_blf_clipping_end(blf_title.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        blf_title.x = R0 - round(blfDimen(FONT0, blf_title.text)[0])
        return B
        #|
    #|
    #|
class BuIntVecSub(BuSub, BuIntVec): __slots__ = 'blf_subtype'
class BuFloatVecSub(BuSub, BuFloatVec): __slots__ = 'blf_subtype'
class BuFloatVecColor(BuFloatVecSub):
    __slots__ = 'update_callback', 'callback_enable'

    def inside(self, mouse):
        if self.box_button.B <= mouse[1] < self.box_button.T:
            if self.box_anim[0].L <= mouse[0] < self.box_button.R: return True
        return False
        #|

    def modal(self):
        # <<< 1copy (0defuiModalValboxvec0,, ${
        #     'if MOUSE[0] < self.box_button.R:': 'if MOUSE[0] >= self.box_button.L:',
        #     'elif self.box_anim[0].L <= MOUSE[0]:': 'elif MOUSE[0] < self.box_anim[0].R:',
        # }$)
        h = SIZE_widget[0]

        if MOUSE[0] >= self.box_button.L:
            ind = min(max(0, (MOUSE[1] - self.box_button.inner[3]) // - h), self.array_length - 1)

            if MOUSE[0] < self.box_button.inner[0] + h:
                if self.focus_element != (ind, 1):

                    self.focus_element = (ind, 1)
                    Admin.REDRAW()
                    self.focus_media_left(ind)

            elif MOUSE[0] >= self.box_button.inner[1] - h:
                if self.focus_element != (ind, 2):

                    self.focus_element = (ind, 2)
                    Admin.REDRAW()
                    self.focus_media_right(ind)
            else:
                if self.focus_element != (ind, 0):

                    self.focus_element = (ind, 0)
                    Admin.REDRAW()
                    self.focus_default(ind)

        elif MOUSE[0] < self.box_anim[0].R:
            ind = min(max(0, (MOUSE[1] - self.box_button.inner[3]) // - h), self.array_length - 1)

            if self.focus_element != (ind, 3):

                self.focus_element = (ind, 3)
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim(ind)
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTrigger,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['valbox_drag']():
            self.to_modal_drag()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            if isinstance(self.focus_element, tuple):
                ind, i = self.focus_element
                if i == 0:
                    self.to_modal_drag_pre()
                    return True
                elif i == 1:
                    self.to_modal_media_left()
                    return True
                elif i == 2:
                    self.to_modal_media_right()
                    return True
                elif i == 3:
                    # <<< 1copy (0defuiClickAnim,, ${'box_anim':'box_anim[ind]'}$)
                    if self.is_trigger_anim_enable is True:
                        self.is_trigger_anim_enable = False
                        if is_first_press('click') == False:
                            boo = self.box_anim[ind].__class__ in S_icon_keyframe_true
                            if _last_bool_state[0] != boo:
                                self.bufn_keyframe()
                        else:
                            self.bufn_keyframe()
                            _last_bool_state[0] = self.box_anim[ind].__class__ in S_icon_keyframe_true
                    return True
                    # >>>
        return False
        #|

    def set(self, v, index, refresh=True, undo_push=True):
        super().set(v, index, refresh, undo_push=False)
        self.upd_data()
        if self.callback_enable: self.update_callback()
        #|
    #|
    #|

@ toNoAnim
class BuIntNoAnim(BuInt): __slots__ = ()
@ toNoAnim
class BuIntVecNoAnim(BuIntVec): __slots__ = ()
@ toNoAnim
class BuFloatNoAnim(BuFloat): __slots__ = ()
@ toNoAnim
class BuFloatVecNoAnim(BuFloatVec): __slots__ = ()
@ toNoAnim
class BuIntVecSubNoAnim(BuIntVecSub): __slots__ = ()
@ toNoAnim
class BuFloatVecSubNoAnim(BuFloatVecSub): __slots__ = ()
@ toNoAnim
class BuFloatVecColorNoAnim(BuFloatVecColor): __slots__ = ()

@ focusColor
@ rBuDeco(ty="COLOR")
class BuColor(BuBoolSlots):
    __slots__ = (
        'color_space',
        'array_length',
        'vec_range',
        'color_value',
        'box_grid',
        'box_rgb',
        'box_dark',
        'set_box_color')

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard, color_space):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data
        self.array_length = rna.array_length
        self.vec_range = range(self.array_length)
        self.color_space = color_space

        self.box_button = GpuRim([0.0, 0.0, 0.0, 1.0], COL_box_color_rim)
        self.box_anim = GpuImgNull()
        self.box_dark = GpuBox()

        self.blf_title = BlfClipColor(unclip_text=rna.name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf

        self.upd_anim_button = self.i_upd_anim_button

        if self.array_length == 3:
            self.dxy = self.i_dxy_3
            self.draw_box = self.i_draw_box_3
            self.color_value = [0.0, 0.0, 0.0]

            if color_space == "Scene Linear":
                self.set_box_color = self.i_set_box_color_3_Scene_Linear
            elif color_space == "GPU Shader":
                self.set_box_color = self.i_set_box_color_3_GPU_Shader
            else:
                self.set_box_color = self.i_set_box_color_3_sRGB
        else:
            self.dxy = self.i_dxy_4
            self.draw_box = self.i_draw_box_4
            self.color_value = [0.0, 0.0, 0.0, 1.0]

            if color_space == "Scene Linear":
                self.set_box_color = self.i_set_box_color_4_Scene_Linear
            elif color_space == "GPU Shader":
                self.set_box_color = self.i_set_box_color_4_GPU_Shader
            else:
                self.set_box_color = self.i_set_box_color_4_sRGB

            self.box_grid = GpuGrid()
            self.box_rgb = GpuBox([0.0, 0.0, 0.0, 1.0])
        #|

    def init_bat_anim_3(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)
        self.box_dark.LRBT_upd(L, R1 - SIZE_widget[0] // 3, B, TT)

        B0 = B + widget_rim

        e = self.blf_title
        e.y = B0 + D_SIZE['font_main_dy']
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])

        self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
        return B
        #|
    def init_bat_anim_4(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)
        self.box_dark.LRBT_upd(L, R1 - SIZE_widget[0] // 3, B, TT)

        L0, R0, B0, T0 = self.box_button.inner
        cx = (L0 + R0) // 2
        self.box_grid.LRBT_upd(cx, R0, B0, T0)
        self.box_rgb.LRBT_upd(L0, cx, B0, T0)

        B0 = B + widget_rim

        e = self.blf_title
        e.y = B0 + D_SIZE['font_main_dy']
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])

        self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
        return B
        #|

    def dark(self):
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        if self.array_length == 3:
            self.dxy = self.i_dxy_3_dark
            self.draw_box = self.i_draw_box_3_dark
        else:
            self.dxy = self.i_dxy_4_dark
            self.draw_box = self.i_draw_box_4_dark

        L, R, B, T = self.box_button.r_LRBT()
        self.box_dark.LRBT_upd(L, R - SIZE_widget[0] // 3, B, T)
        self.box_dark.color = list(COL_box_text)
        self.box_dark.color[3] *= 0.98

        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        #|
    def light(self):
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        if self.array_length == 3:
            self.dxy = self.i_dxy_3
            self.draw_box = self.i_draw_box_3
        else:
            self.dxy = self.i_dxy_4
            self.draw_box = self.i_draw_box_4

        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        #|

    def modal(self):
        # <<< 1copy (0defuiModalStr0,, $$)
        if self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.focus_element = 3
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim()

        elif MOUSE[0] < self.box_button.R:
            if self.focus_element != 0:

                self.focus_element = 0
                Admin.REDRAW()
                self.focus_default()
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTrigger,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['valbox_drag']():
            self.to_modal_drag()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_dropdown()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        #|

    def to_dropdown(self):

        self.pp = self.r_pp()
        DropDownBuColor(self)
        #|

    def i_dxy_3(self, dx, dy):
        # <<< 1copy (0defuiBoolDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        #|
    def i_dxy_3_anim_hover(self, dx, dy):
        self.i_dxy_3(dx, dy)
        if hasattr(self, "focus_element"):
            if self.focus_element != -1:
                self.focus_element = -1
                self.box_hover.LRBT_upd(0, 0, 0, 0)
        #|
    def i_dxy_4(self, dx, dy):
        # <<< 1copy (0defuiBoolDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>

        self.box_grid.dxy_upd(dx, dy)
        self.box_rgb.dxy_upd(dx, dy)
        #|
    def i_dxy_4_anim_hover(self, dx, dy):
        self.i_dxy_4(dx, dy)
        if hasattr(self, "focus_element"):
            if self.focus_element != -1:
                self.focus_element = -1
                self.box_hover.LRBT_upd(0, 0, 0, 0)
        #|
    def i_dxy_3_dark(self, dx, dy):
        # <<< 1copy (0defuiBoolDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>

        self.box_dark.dxy_upd(dx, dy)
        #|
    def i_dxy_4_dark(self, dx, dy):
        # <<< 1copy (0defuiBoolDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>

        self.box_grid.dxy_upd(dx, dy)
        self.box_rgb.dxy_upd(dx, dy)

        self.box_dark.dxy_upd(dx, dy)
        #|

    def i_draw_box_3(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        #|
    def i_draw_box_4(self):
        self.box_grid.bind_draw()

        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>

        self.box_rgb.bind_draw()
        #|
    def i_draw_box_3_dark(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>

        self.box_dark.bind_draw()
        #|
    def i_draw_box_4_dark(self):
        self.box_grid.bind_draw()

        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>

        self.box_rgb.bind_draw()
        self.box_dark.bind_draw()
        #|

    def i_draw_blf(self):
        # <<< 1copy (0defuiBoolDrawblf,, $$)
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        # >>>
        #|

    def i_draw_box_anim(self):
        if self.isdark is True:
            if self.array_length == 3:
                self.i_draw_box_3_dark()
            else:
                self.i_draw_box_4_dark()
        else:
            if self.array_length == 3:
                self.i_draw_box_3()
            else:
                self.i_draw_box_4()
        self.box_hover.bind_draw()
        #|

    def i_set_box_color_3_Scene_Linear(self, v):
        e = self.box_button.color

        for r, v in enumerate(v):
            e[r] = L_rgb_to_glc[scene_linear_to_hex(v)]
        #|
    def i_set_box_color_4_Scene_Linear(self, v):
        e = self.box_button.color
        o = self.box_rgb.color
        e[0] = o[0] = L_rgb_to_glc[scene_linear_to_hex(v[0])]
        e[1] = o[1] = L_rgb_to_glc[scene_linear_to_hex(v[1])]
        e[2] = o[2] = L_rgb_to_glc[scene_linear_to_hex(v[2])]
        e[3] = v[3]
        #|
    def i_set_box_color_3_sRGB(self, v):
        e = self.box_button.color

        for r, v in enumerate(v):
            e[r] = L_rgb_to_glc[min(max(0, round(v * 255)), 255)]
        #|
    def i_set_box_color_4_sRGB(self, v):
        e = self.box_button.color
        o = self.box_rgb.color
        e[0] = o[0] = L_rgb_to_glc[min(max(0, round(v[0] * 255)), 255)]
        e[1] = o[1] = L_rgb_to_glc[min(max(0, round(v[1] * 255)), 255)]
        e[2] = o[2] = L_rgb_to_glc[min(max(0, round(v[2] * 255)), 255)]
        e[3] = v[3]
        #|
    def i_set_box_color_3_GPU_Shader(self, v):
        self.box_button.color[:] = v
        #|
    def i_set_box_color_4_GPU_Shader(self, v):
        self.box_button.color[:] = v
        self.box_rgb.color[0 : 3] = v[0 : 3]
        #|

    def upd_data(self):
        # /* 0defBuColor_upd_data
        self.upd_anim_button()
        if list(getattr(self.pp, self.identifier)) == self.color_value: return


        v = getattr(self.pp, self.identifier)
        self.color_value[:] = v
        self.set_box_color(v)
        # */
    #|
    #|
@ toNoAnim
class BuColorNoAnim(BuColor): __slots__ = ()

@ focusBool
@ rBuDeco(ty="BOOL")
class BuBool(BuBoolSlots):
    __slots__ = ()

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data

        self.box_button = GpuCheckbox()
        self.box_anim = GpuImgNull()

        self.blf_title = BlfClipColor(unclip_text=rna.name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button

        self.evtkill = False
        #|

    def r_B(self): return self.box_button.B - D_SIZE['widget_bool_dB']
    def r_T(self): return self.box_button.T + D_SIZE['widget_bool_dT']

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        T = TT - D_SIZE['widget_bool_dT']
        self.box_button.LRBT_upd(L, L + D_SIZE['widget_bool_full_h'], T - D_SIZE['widget_bool_full_h'], T, widget_rim)

        B0 = B + widget_rim

        e = self.blf_title
        e.y = B0 + D_SIZE['font_main_dy']
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])

        self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
        return B
        #|
    def init_bat_animR(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        T = TT - D_SIZE['widget_bool_dT']
        R3 = L + D_SIZE['widget_bool_full_h']
        self.box_button.LRBT_upd(L, R3, T - D_SIZE['widget_bool_full_h'], T, widget_rim)

        B0 = B + widget_rim

        e = self.blf_title
        e.x = R3 + D_SIZE['font_main_title_offset_R']
        e.y = B0 + D_SIZE['font_main_dy']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, e.x, R1)

        self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
        return B
        #|
    def init_bat_animH(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim

        B = TT - D_SIZE['widget_full_h']
        T = TT - D_SIZE['widget_bool_dT']
        R3 = LL + D_SIZE['widget_bool_full_h']
        self.box_button.LRBT_upd(LL, R3, T - D_SIZE['widget_bool_full_h'], T, widget_rim)

        B0 = B + widget_rim

        e = self.blf_title
        e.x = R3 + D_SIZE['font_main_title_offset_R']
        e.y = B0 + D_SIZE['font_main_dy']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, e.x, R1)

        self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
        return B
        #|

    def dark(self):
        # <<< 1copy (0defuiBoolDark,, $$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.dark()
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>

        if hasattr(self.w, "GROUP_INFO"):
            self.w.button0.dark()
        #|
    def light(self):
        # <<< 1copy (0defuiBoolLight,, $$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.light()
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>

        if hasattr(self.w, "GROUP_INFO"):
            self.w.button0.light()
        #|

    def modal(self):
        # <<< 1copy (0defuiModalBoolInvert0,, ${
        #     'MOUSE[0] < self.box_button.R': 'self.box_anim.B <= MOUSE[1] < self.box_anim.T and self.box_button.L <= MOUSE[0] < self.box_button.L + SIZE_widget[0]'
        # }$)
        if self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.focus_element = 3
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim()

        elif self.box_anim.B <= MOUSE[1] < self.box_anim.T and self.box_button.L <= MOUSE[0] < self.box_button.L + SIZE_widget[0]:
            if self.focus_element != 0:

                self.focus_element = 0
                self.is_trigger_enable = True
                Admin.REDRAW()
                self.focus_default()
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTriggerBool,, $$)
        if self.is_trigger_anim_enable is True and self.is_trigger_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
            self.is_trigger_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerBool,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if hasattr(self, "evt_attr_toggle"):
            if TRIGGER['ui_attr_toggle']():
                self.evt_attr_toggle()
                return True
        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        # <<< 1copy (0defuiModalBoolClick,, $$)
        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                if self.is_trigger_enable is True:
                    self.is_trigger_enable = False
                    if is_first_press('click') == False:
                        self.set(_last_bool_state[0])
                        #_REF_set_after_#
                    else:
                        boo = not self.get()
                        self.set(boo)
                        #_REF_set_after_#
                        _last_bool_state[0] = boo
                    Admin.REDRAW()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        # >>>
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiBoolDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        #|
    def i_draw_box(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        #|
    def i_draw_box_anim(self):
        # <<< 1copy (0defuiDrawboxAnim,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        self.box_hover.bind_draw()
        # >>>
        #|
    def i_draw_blf(self):
        # <<< 1copy (0defuiBoolDrawblf,, $$)
        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        # >>>
        #|

    def upd_data(self):
        # <<< 1copy (0defuiBoolUpdData,, $$)
        self.upd_anim_button()
        self.box_button.value = getattr(self.pp, self.identifier)
        # >>>
        #|
    #|
    #|
@ focusBoolInvert
class BuBoolIcon(BuBool):
    __slots__ = 'box_icon', 'icon_cls'

    def __init__(self, w, rna, r_pp, ui_anim_data, isdarkhard, icon_cls):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data

        self.box_button = GpuButtonBool()
        self.icon_cls = icon_cls
        self.box_icon = icon_cls()
        self.box_anim = GpuImgNull()

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button

        self.evtkill = False
        #|

    def r_B(self): return self.box_button.B - SIZE_border[3]
    def r_T(self): return self.box_button.T + SIZE_border[3]

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        B = TT - D_SIZE['widget_full_h']
        B0 = B + widget_rim
        T0 = TT - widget_rim

        if hasattr(self, "r_button_width"):
            RR -= D_SIZE['widget_width'] + D_SIZE['font_main_title_offset'] + widget_rim + SIZE_widget[0] + self.r_button_width()
            L0 = RR - D_SIZE['widget_full_h']
            R1 = L0 - D_SIZE['font_main_dx']

            self.box_button.LRBT_upd(L0, RR, B0, T0, widget_rim)
            self.box_anim.LRBT_upd(R1 - SIZE_widget[0], R1, B0, T0)
            self.box_icon.LRBT_upd(L0 + widget_rim, RR - widget_rim, B0, T0)
        else:
            R2 = RR - SIZE_widget[0]
            R1 = R2 - widget_rim
            L = R1 - D_SIZE['widget_full_h']

            self.box_button.LRBT_upd(L, R1, B0, T0, widget_rim)
            self.box_anim.LRBT_upd(R2, RR, B0, T0)
            self.box_icon.LRBT_upd(L + widget_rim, R1 - widget_rim, B0, T0)
        return B
        #|

    def dark(self):
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.dark()
        self.box_icon.__class__ = GpuImg_stop_dark
        #|
    def light(self):
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.light()
        self.box_icon.__class__ = self.icon_cls
        #|

    def inside(self, mouse):
        if self.box_anim.B <= mouse[1] < self.box_anim.T:
            if hasattr(self, "r_button_width"):
                if self.box_anim.L <= mouse[0] < self.box_button.R: return True
            else:
                if self.box_button.L <= mouse[0] < self.box_anim.R: return True
        return False
        #|

    def modal(self):
        # <<< 1copy (0defuiModalBoolInvert0,, ${
        #     'if self.box_anim.L <= MOUSE[0]:': 'if self.box_anim.L <= MOUSE[0] < self.box_anim.R:',
        #     'elif MOUSE[0] < self.box_button.R:': 'elif self.box_button.L <= MOUSE[0] < self.box_button.R:'
        # }$)
        if self.box_anim.L <= MOUSE[0] < self.box_anim.R:
            if self.focus_element != 3:

                self.focus_element = 3
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim()

        elif self.box_button.L <= MOUSE[0] < self.box_button.R:
            if self.focus_element != 0:

                self.focus_element = 0
                self.is_trigger_enable = True
                Admin.REDRAW()
                self.focus_default()
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTriggerBool,, $$)
        if self.is_trigger_anim_enable is True and self.is_trigger_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
            self.is_trigger_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerBool,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        # <<< 1copy (0defuiModalBoolClick,, ${
        #     '#_REF_set_after_#': '(self.box_button.set_state_on_focus  if self.get() else self.box_button.set_state_off_focus)()',
        # }$)
        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                if self.is_trigger_enable is True:
                    self.is_trigger_enable = False
                    if is_first_press('click') == False:
                        self.set(_last_bool_state[0])
                        (self.box_button.set_state_on_focus  if self.get() else self.box_button.set_state_off_focus)()
                    else:
                        boo = not self.get()
                        self.set(boo)
                        (self.box_button.set_state_on_focus  if self.get() else self.box_button.set_state_off_focus)()
                        _last_bool_state[0] = boo
                    Admin.REDRAW()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        # >>>
        #|

    def i_dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)
        self.box_icon.dxy_upd(dx, dy)
        #|

    def i_draw_box(self):
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        self.box_icon.bind_draw()
        #|
    def i_draw_box_anim(self):
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        self.box_icon.bind_draw()
        self.box_hover.bind_draw()
        #|
    def i_draw_blf(self): pass

    def upd_data(self):
        self.upd_anim_button()

        if getattr(self.pp, self.identifier):
            if self.box_button.state in {2, 3}: pass
            else: self.box_button.set_state_on()
        else:
            if self.box_button.state in {0, 1}: pass
            else: self.box_button.set_state_off()
        #|
    #|
    #|

class BuBoolJ(BuBool):
    __slots__ = ()

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - D_SIZE['font_main_title_offset'] - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])
        L1 = L - D_SIZE['widget_bool_full_h']
        L2 = L1 - D_SIZE['font_main_dx']
        L3 = L2 - SIZE_widget[0]
        B = TT - D_SIZE['widget_full_h']
        B0 = B + widget_rim

        T = TT - D_SIZE['widget_bool_dT']
        self.box_button.LRBT_upd(L1, L, T - D_SIZE['widget_bool_full_h'], T, widget_rim)

        self.box_anim.LRBT_upd(L3, L2, B0, TT - widget_rim)

        e = self.blf_title
        e.y = B0 + D_SIZE['font_main_dy']
        R0 = L3 - D_SIZE['font_main_dx']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])
        return B
        #|

    def inside(self, mouse):
        if self.box_anim.B <= mouse[1] < self.box_anim.T:
            if self.box_anim.L <= mouse[0] < self.box_button.R: return True
        return False
        #|

    def modal(self):
        # <<< 1copy (0defuiModalBoolInvert0,, ${
        #     'if self.box_anim.L <= MOUSE[0]:': 'if MOUSE[0] < self.box_anim.R:',
        #     'elif MOUSE[0] < self.box_button.R:': 'elif self.box_button.R - SIZE_widget[0] <= MOUSE[0] < self.box_button.R:'
        # }$)
        if MOUSE[0] < self.box_anim.R:
            if self.focus_element != 3:

                self.focus_element = 3
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim()

        elif self.box_button.R - SIZE_widget[0] <= MOUSE[0] < self.box_button.R:
            if self.focus_element != 0:

                self.focus_element = 0
                self.is_trigger_enable = True
                Admin.REDRAW()
                self.focus_default()
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTriggerBool,, $$)
        if self.is_trigger_anim_enable is True and self.is_trigger_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
            self.is_trigger_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerBool,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        # <<< 1copy (0defuiModalBoolClick,, $$)
        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                if self.is_trigger_enable is True:
                    self.is_trigger_enable = False
                    if is_first_press('click') == False:
                        self.set(_last_bool_state[0])
                        #_REF_set_after_#
                    else:
                        boo = not self.get()
                        self.set(boo)
                        #_REF_set_after_#
                        _last_bool_state[0] = boo
                    Admin.REDRAW()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        # >>>
        #|
    #|
    #|

@ focusBoolVec
@ rBuDeco(ty="BOOL", is_vec=True)
class BuBoolVec(BuBoolSlots):
    __slots__ = 'array_length', 'vec_range', 'blf_subtype'

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data
        self.array_length = rna.array_length
        self.vec_range = range(self.array_length)

        self.box_button = [GpuCheckbox()  for r in self.vec_range]
        self.box_anim = [GpuImgNull()  for r in self.vec_range]

        self.blf_title = BlfClipColor(unclip_text=rna.name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button

        self.evtkill = False
        #|

    def r_B(self): return self.box_button[-1] - D_SIZE['widget_bool_dB']
    def r_T(self): return self.box_button[0] + D_SIZE['widget_bool_dT']

    def init_subtype(self, titles):
        self.blf_subtype = [Blf(tx)  for _, tx in zip(self.box_button, titles)]
        self.blf_subtype[0].color = COL_box_button_fg_info
        #|

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        h = SIZE_widget[0]
        R2 = RR - h
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        T = TT - D_SIZE['widget_bool_dT']
        R3 = L + D_SIZE['widget_bool_full_h']
        B0 = B + widget_rim

        blf_title = self.blf_title
        blf_title.x = R3 + D_SIZE['font_main_title_offset_R']
        y = B0 + D_SIZE['font_main_dy']
        blf_title.y = y
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        blf_title.text = r_blf_clipping_end(blf_title.unclip_text, blf_title.x, R1)

        B1 = T - D_SIZE['widget_bool_full_h']
        T2 = TT - widget_rim
        blfSize(FONT1, D_SIZE['font_label'])
        xx = L - D_SIZE['font_label_dx']
        x = xx - round(blfDimen(FONT1, self.blf_subtype[0].text)[0])

        for box_anim, box_button, blf_subtype in zip(self.box_anim, self.box_button, self.blf_subtype):
            box_anim.LRBT_upd(R2, RR, B0, T2)
            box_button.LRBT_upd(L, R3, B1, T, widget_rim)
            blf_subtype.x = x
            blf_subtype.y = y

            B0 -= h
            T2 -= h
            B1 -= h
            T -= h
            y -= h

        return B - (self.array_length - 1) * h
        #|

    def dark(self):
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        for e in self.box_button:
            e.dark()

        self.blf_title.color = COL_block_fg_ignore
        self.blf_subtype[0].color = COL_block_fg_ignore
        Admin.REDRAW()

        if hasattr(self.w, "GROUP_INFO"):
            self.w.button0.dark()
        #|
    def light(self):
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        for e in self.box_button:
            e.light()

        self.blf_title.color = COL_block_fg
        self.blf_subtype[0].color = COL_box_button_fg_info
        Admin.REDRAW()

        if hasattr(self.w, "GROUP_INFO"):
            self.w.button0.light()
        #|

    def i_dxy(self, dx, dy):
        for e in self.box_button:
            e.dxy_upd(dx, dy)
        for e in self.box_anim:
            e.dxy_upd(dx, dy)

        self.blf_title.x += dx
        self.blf_title.y += dy
        for e in self.blf_subtype:
            e.x += dx
            e.y += dy
        #|
    def i_draw_box(self):
        for e in self.box_button:
            e.bind_draw()
        for e in self.box_anim:
            e.bind_draw()
        #|
    def i_draw_box_anim(self):
        for e in self.box_button:
            e.bind_draw()
        for e in self.box_anim:
            e.bind_draw()
        self.box_hover.bind_draw()
        #|
    def i_draw_blf(self):
        blfSize(FONT1, D_SIZE['font_label'])
        blfColor(FONT1, *self.blf_subtype[0].color)
        for e in self.blf_subtype:
            blfPos(FONT1, e.x, e.y, 0)
            blfDraw(FONT1, e.text)

        e = self.blf_title
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def modal(self):
        if self.box_anim[0].L <= MOUSE[0]:
            ind = min(max(0, (MOUSE[1] - self.box_anim[0].T) // - SIZE_widget[0]), self.array_length - 1)

            if self.focus_element != (ind, 3):

                self.focus_element = ind, 3
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim(ind)

        elif self.box_button[0].L <= MOUSE[0] < self.box_button[0].L + SIZE_widget[0]:
            ind = min(max(0, (MOUSE[1] - self.box_button[0].inner[3]) // - SIZE_widget[0]), self.array_length - 1)

            if self.focus_element != (ind, 0):

                self.focus_element = ind, 0
                self.is_trigger_enable = True
                Admin.REDRAW()
                self.focus_default(ind)
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTriggerBool,, $$)
        if self.is_trigger_anim_enable is True and self.is_trigger_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
            self.is_trigger_enable = True
        # >>>

        # <<< 1copy (0defuiModalTriggerBool,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            if isinstance(self.focus_element, tuple):
                ind, i = self.focus_element
                if i == 0:
                    if self.is_trigger_enable is True:
                        self.is_trigger_enable = False
                        if is_first_press('click') == False:
                            self.set(_last_bool_state[0], ind)
                            #_REF_set_after_#
                        else:
                            boo = not self.get()[ind]
                            self.set(boo, ind)
                            #_REF_set_after_#
                            _last_bool_state[0] = boo
                        Admin.REDRAW()
                    return True
                elif i == 3:
                    # <<< 1copy (0defuiClickAnim,, ${'self.box_anim':'self.box_anim[ind]'}$)
                    if self.is_trigger_anim_enable is True:
                        self.is_trigger_anim_enable = False
                        if is_first_press('click') == False:
                            boo = self.box_anim[ind].__class__ in S_icon_keyframe_true
                            if _last_bool_state[0] != boo:
                                self.bufn_keyframe()
                        else:
                            self.bufn_keyframe()
                            _last_bool_state[0] = self.box_anim[ind].__class__ in S_icon_keyframe_true
                    return True
                    # >>>
        return False
        #|

    def upd_data(self):
        self.upd_anim_button()
        for box_button, v in zip(self.box_button, getattr(self.pp, self.identifier)):
            box_button.value = v
        #|
    #|
    #|

@ toNoAnim
class BuBoolNoAnim(BuBool): __slots__ = ()
@ toNoAnim
class BuBoolIconNoAnim(BuBoolIcon): __slots__ = ()


@ assign(
    init_bat_anim = c_init_bat_anim_BuInt,
    i_draw_box = c_draw_box_BuInt,
    i_draw_box_anim = c_draw_box_anim_BuInt,
    i_draw_blf = c_draw_blf_BuInt,
    set = c_set,
    tag_clipping_dirty = c_tag_clipping_dirty)
@ focusStr
@ rBuDeco(ty="STR")
class BuStr(BuValueSlots):
    __slots__ = ()

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data

        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_anim = GpuImgNull()

        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.blf_title = BlfClipColor(unclip_text=rna.name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button
        #|

    def set_align(self, ty, r_offset_width=None):
        if ty == "FULL":
            self.blf_title.text = self.blf_title.unclip_text
            self.init_bat = self.init_bat_anim_FULL

            if r_offset_width is None: return
            self.r_button_width = r_offset_width
        #|

    def init_bat_anim_FULL(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim

        blf_title = self.blf_title
        if blf_title.unclip_text:
            blfSize(FONT0, D_SIZE['font_main'])
            if hasattr(self, "r_button_width"):
                blf_title.x = LL + D_SIZE['font_main_title_offset'] + self.r_button_width()
            else:
                blf_title.x = LL + D_SIZE['font_main_title_offset']

            L = blf_title.x + round(blfDimen(FONT0, blf_title.unclip_text)[0]) + D_SIZE['font_main_title_offset']
        else:
            if hasattr(self, "r_button_width"):
                L = LL + widget_rim + widget_rim + self.r_button_width()
            else:
                L = LL + widget_rim + widget_rim
            blf_title.x = L

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        B0 = B + widget_rim
        blf_y = B0 + D_SIZE['font_main_dy']
        self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
        self.blf_value.y = blf_y

        blf_title.y = blf_y

        self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
        return B
        #|

    def dark(self):
        # <<< 1copy (0defuiStrDark,, $$)
        # <<< 1copy (0defuiDark,, ${'_box_val':'_box_text'}$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_text_ignore
        self.box_button.color_rim = COL_box_text_rim_ignore
        self.blf_value.color = COL_box_text_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        # >>>
        #|
    def light(self):
        # <<< 1copy (0defuiStrLight,, $$)
        # <<< 1copy (0defuiLight,, ${'_box_val':'_box_text'}$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_text
        self.box_button.color_rim = COL_box_text_rim
        self.blf_value.color = COL_box_text_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        # >>>
        #|

    def modal(self):
        # <<< 1copy (0defuiModalStr0,, $$)
        if self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.focus_element = 3
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim()

        elif MOUSE[0] < self.box_button.R:
            if self.focus_element != 0:

                self.focus_element = 0
                Admin.REDRAW()
                self.focus_default()
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_dropdown()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        v = self.get()
        if isinstance(v, bytes):
            v = v.decode('utf-8')

        return DropDownString(self, self.box_button.r_LRBT(), v)
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiStrDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        #|

    def upd_data(self):
        # <<< 1copy (0defuiStrUpdData,, $$)
        self.upd_anim_button()
        if self.blf_value.unclip_text == getattr(self.pp, self.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.identifier)
        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if self.blf_title.unclip_text:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
            else:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (
                D_SIZE['font_main_dx'] + SIZE_border[3]) * 2)#_REF_
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2)#_REF_
        # >>>
        #|
    #|
    #|

@ assign(
    r_default_value = c_r_default_value_vec)
class BuStrVec(BuStr):
    __slots__ = ()

    def to_dropdown(self, killevt=True, select_all=None):

        return DropDownString(self, self.box_button.r_LRBT(), ", ".join("{:.16f}".format(v)  for v in self.get()))
        #|

    @ catch
    def evt_area_copy(self, index=None, is_report=True):

        kill_evt_except()
        s = ""
        fac = r_unit_factor(self.unit  if hasattr(self, "unit") else self.rna.unit, None)
        for e in self.get(): s += f'{value_to_display(e / fac)}, '

        bpy.context.window_manager.clipboard = s[: -2]
        if is_report: report("Copy to Clipboard")
        #|
    def evt_area_cut(self, index=None, is_report=True):
        self.evt_area_copy(index=index, is_report=is_report)
        #|

    def set(self, v, refresh=True, undo_push=True):
        array_length = self.rna.array_length
        if isinstance(v, str): v = calc_vec(v)

        le = len(v)
        if le < array_length:
            new_v = [0.0] * array_length
            new_v[ : le] = v
            v = new_v
        else:
            v = v[ : array_length]

        v = Vector(v).normalized()
        setattr(self.pp, self.identifier, list(v))

        if hasattr(self, "set_callback"):
            ret = self.set_callback()
            if ret is True: return
            if ret is False: refresh = False

        if refresh: update_data()

        if undo_push:
            ed_undo_push(message=f'{self.rna.name} : {getattr(self.pp, self.identifier)}')
        #|

    def upd_data(self):
        self.upd_anim_button()
        if self.blf_value.unclip_text == list(getattr(self.pp, self.identifier)): return


        v = list(getattr(self.pp, self.identifier))
        self.blf_value.unclip_text = v
        self.blf_value.text = rs_format_float6_vec(v)
        #|
    #|
    #|

@ assign(
    focus_match = c_focus_match_str)
class BuStrMatch(BuStr):
    __slots__ = (
        'box_match_case',
        'box_match_case_bg',
        'box_match_whole_word',
        'box_match_whole_word_bg',
        'box_match_end',
        'box_match_end_bg',
        'box_match_hover',
        'is_match_case',
        'is_match_whole_word',
        'is_match_end')

    def init(self):
        self.box_match_case = GpuImg_filter_match_case()
        self.box_match_whole_word = GpuImg_filter_match_whole_word()
        self.box_match_end = GpuImg_filter_match_end_left()
        self.box_match_end_bg = GpuImg_filter_match_active()
        self.box_match_whole_word_bg = GpuImg_filter_match_active()
        self.box_match_case_bg = GpuImg_filter_match_active()
        self.is_match_end = P.filter_match_end
        self.is_match_case = P.filter_match_case
        self.is_match_whole_word = P.filter_match_whole_word
        self.box_match_hover = GpuImg_filter_match_hover()
        #|

    def upd_match_button(self):
        L0, R0, B0, T0 = self.box_button.inner
        h = SIZE_widget[0]
        L0 = R0 - h
        if self.is_match_end == 1:
            if isinstance(self.box_match_end, GpuImg_filter_match_end_right):
                self.box_match_end.__class__ = GpuImg_filter_match_end_left
            self.box_match_end_bg.set_draw_state(True)
        elif self.is_match_end == 2:
            if isinstance(self.box_match_end, GpuImg_filter_match_end_left):
                self.box_match_end.__class__ = GpuImg_filter_match_end_right
            self.box_match_end_bg.set_draw_state(True)
        else:
            if isinstance(self.box_match_end, GpuImg_filter_match_end_right):
                self.box_match_end.__class__ = GpuImg_filter_match_end_left
            self.box_match_end_bg.set_draw_state(False)
        self.box_match_end.LRBT_upd(L0, R0, B0, T0)
        self.box_match_end_bg.LRBT_upd(L0, R0, B0, T0)

        R0 -= h
        L0 -= h
        self.box_match_whole_word.LRBT_upd(L0, R0, B0, T0)
        self.box_match_whole_word_bg.LRBT_upd(L0, R0, B0, T0)
        self.box_match_whole_word_bg.set_draw_state(self.is_match_whole_word)
        R0 -= h
        L0 -= h
        self.box_match_case.LRBT_upd(L0, R0, B0, T0)
        self.box_match_case_bg.LRBT_upd(L0, R0, B0, T0)
        self.box_match_case_bg.set_draw_state(self.is_match_case)
        #|

    def init_bat_anim_FULL(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim

        blf_title = self.blf_title
        if blf_title.unclip_text:
            blfSize(FONT0, D_SIZE['font_main'])
            if hasattr(self, "r_button_width"):
                blf_title.x = LL + D_SIZE['font_main_title_offset'] + self.r_button_width()
            else:
                blf_title.x = LL + D_SIZE['font_main_title_offset']

            L = blf_title.x + round(blfDimen(FONT0, blf_title.unclip_text)[0]) + D_SIZE['font_main_title_offset']
        else:
            if hasattr(self, "r_button_width"):
                L = LL + widget_rim + widget_rim + self.r_button_width()
            else:
                L = LL + widget_rim + widget_rim
            blf_title.x = L

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        B0 = B + widget_rim
        blf_y = B0 + D_SIZE['font_main_dy']
        self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
        self.blf_value.y = blf_y

        blf_title.y = blf_y

        self.box_anim.LRBT_upd(R2, RR, B0, TT - widget_rim)
        self.upd_match_button()
        return B
        #|

    def modal(self):
        # <<< 1copy (0defuiModalStrMatch0,, $$)
        if self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.focus_element = 3
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim()

        elif MOUSE[0] < self.box_button.R:
            if self.box_match_end.L <= MOUSE[0]:
                if self.focus_element != 6:

                    self.focus_element = 6
                    Admin.REDRAW()
                    self.focus_match(6)
            elif self.box_match_whole_word.L <= MOUSE[0]:
                if self.focus_element != 5:

                    self.focus_element = 5
                    Admin.REDRAW()
                    self.focus_match(5)
            elif self.box_match_case.L <= MOUSE[0]:
                if self.focus_element != 4:

                    self.focus_element = 4
                    Admin.REDRAW()
                    self.focus_match(4)
            else:
                if self.focus_element != 0:

                    self.focus_element = 0
                    Admin.REDRAW()
                    self.focus_default()
        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['dd_match_end']():
            self.evt_toggle_match_end()
            return True
        if TRIGGER['dd_match_case']():
            self.evt_toggle_match_case()
            return True
        if TRIGGER['dd_match_whole_word']():
            self.evt_toggle_match_whole_word()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_dropdown()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
            elif i == 4:
                self.evt_toggle_match_case()
                return True
            elif i == 5:
                self.evt_toggle_match_whole_word()
                return True
            elif i == 6:
                self.evt_toggle_match_end()
                return True
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):

        v = self.get()
        if isinstance(v, bytes):
            v = v.decode('utf-8')

        ddw = DropDownStringMatch(self, self.box_button.r_LRBT(), v,
            is_match_case = self.is_match_case,
            is_match_whole_word = self.is_match_whole_word,
            is_match_end = self.is_match_end)

        def fin_callfront():
            filt = ddw.areas[0].filt
            self.is_match_case = filt.match_case
            self.is_match_whole_word = filt.match_whole_word
            self.is_match_end = filt.match_end
            self.upd_match_button()

        ddw.data["fin_callfront"] = fin_callfront
        return ddw
        #|

    def evt_toggle_match_case(self, v=None):

        kill_evt_except()
        Admin.REDRAW()
        if v == None: v = not self.is_match_case
        self.is_match_case = v
        self.upd_match_button()
        if hasattr(self, "set_callback"):
            self.set_callback()
        #|
    def evt_toggle_match_whole_word(self, v=None):

        kill_evt_except()
        Admin.REDRAW()
        if v == None: v = not self.is_match_whole_word
        self.is_match_whole_word = v
        self.upd_match_button()
        if hasattr(self, "set_callback"):
            self.set_callback()
        #|
    def evt_toggle_match_end(self, v=None):

        kill_evt_except()
        Admin.REDRAW()
        if v == None:
            v = self.is_match_end + 1
            if v == 3: v = 0
        self.is_match_end = v
        self.upd_match_button()
        if hasattr(self, "set_callback"):
            self.set_callback()
        #|

    def i_draw_box(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>

        self.box_match_case_bg.bind_draw()
        self.box_match_whole_word_bg.bind_draw()
        self.box_match_end_bg.bind_draw()
        self.box_match_case.bind_draw()
        self.box_match_whole_word.bind_draw()
        self.box_match_end.bind_draw()
        #|
    def i_draw_box_match(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>

        self.box_match_hover.bind_draw()
        self.box_match_case_bg.bind_draw()
        self.box_match_whole_word_bg.bind_draw()
        self.box_match_end_bg.bind_draw()
        self.box_match_case.bind_draw()
        self.box_match_whole_word.bind_draw()
        self.box_match_end.bind_draw()
        #|
    def i_draw_box_anim(self):
        # <<< 1copy (0defuiDrawboxAnim,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        self.box_hover.bind_draw()
        # >>>

        self.box_match_case_bg.bind_draw()
        self.box_match_whole_word_bg.bind_draw()
        self.box_match_end_bg.bind_draw()
        self.box_match_case.bind_draw()
        self.box_match_whole_word.bind_draw()
        self.box_match_end.bind_draw()
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiStrDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>

        self.box_match_case.dxy_upd(dx, dy)
        self.box_match_whole_word.dxy_upd(dx, dy)
        self.box_match_end.dxy_upd(dx, dy)
        self.box_match_case_bg.dxy_upd(dx, dy)
        self.box_match_whole_word_bg.dxy_upd(dx, dy)
        self.box_match_end_bg.dxy_upd(dx, dy)
        #|
    def i_dxy_match_hover(self, dx, dy):
        self.i_dxy(dx, dy)
        self.box_match_hover.dxy_upd(dx, dy)
        #|

    def set(self, v, refresh=False, undo_push=False):
        setattr(self.pp, self.identifier, v)

        if hasattr(self, "set_callback"):
            self.set_callback()
        #|

    def upd_data(self):
        # <<< 1copy (0defuiStrUpdData,, ${
        #     ')#_REF_': ' - SIZE_widget[0] * 3)'
        # }$)
        self.upd_anim_button()
        if self.blf_value.unclip_text == getattr(self.pp, self.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.identifier)
        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if self.blf_title.unclip_text:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
            else:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (
                D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] * 3)
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] * 3)
        # >>>
        #|
    #|
    #|
@ assign(
    init_bat_anim = c_init_bat_anim_BuEnum)
class BuStrArrow(BuStr):
    __slots__ = 'box_icon_arrow'

    def init_bat_anim_FULL(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim

        blf_title = self.blf_title
        if blf_title.unclip_text:
            blfSize(FONT0, D_SIZE['font_main'])
            if hasattr(self, "r_button_width"):
                blf_title.x = LL + D_SIZE['font_main_title_offset'] + self.r_button_width()
            else:
                blf_title.x = LL + D_SIZE['font_main_title_offset']

            L = blf_title.x + round(blfDimen(FONT0, blf_title.unclip_text)[0]) + D_SIZE['font_main_title_offset']
        else:
            if hasattr(self, "r_button_width"):
                L = LL + widget_rim + widget_rim + self.r_button_width()
            else:
                L = LL + widget_rim + widget_rim
            blf_title.x = L

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        L9, R9, B9, T9 = self.box_button.inner
        self.box_icon_arrow.LRBT_upd(R9 - SIZE_widget[0], R9, B9, T9)

        blf_y = B9 + D_SIZE['font_main_dy']
        self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
        self.blf_value.y = blf_y

        blf_title.y = blf_y

        self.box_anim.LRBT_upd(R2, RR, B9, T9)
        return B
        #|

    def dark(self):
        # <<< 1copy (0defuiEnumDark,, $$)
        # <<< 1copy (0defuiStrDark,, $$)
        # <<< 1copy (0defuiDark,, ${'_box_val':'_box_text'}$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_text_ignore
        self.box_button.color_rim = COL_box_text_rim_ignore
        self.blf_value.color = COL_box_text_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        # >>>
        self.box_icon_arrow.set_draw_state(False)
        # >>>
        #|
    def light(self):
        # <<< 1copy (0defuiEnumLight,, $$)
        # <<< 1copy (0defuiStrLight,, $$)
        # <<< 1copy (0defuiLight,, ${'_box_val':'_box_text'}$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_text
        self.box_button.color_rim = COL_box_text_rim
        self.blf_value.color = COL_box_text_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        # >>>
        self.box_icon_arrow.set_draw_state(True)
        # >>>
        #|

    def i_draw_box(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        self.box_icon_arrow.bind_draw()
        #|
    def i_draw_box_anim(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        self.box_icon_arrow.bind_draw()
        self.box_hover.bind_draw()
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiStrDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        self.box_icon_arrow.dxy_upd(dx, dy)
        #|
    #|
    #|

@ assign(
    i_upd_anim_button = c_upd_button_keyframe_ENUM,
    i_upd_anim_button_dark = c_upd_button_keyframe_ENUM_dark,
    i_upd_anim_button_ov = c_upd_button_keyframe_ENUM_ov,
    i_upd_anim_button_ov_dark = c_upd_button_keyframe_ENUM_ov_dark)
class BuEnum(BuStrArrow):
    __slots__ = 'enum_items', 'geticon', 'getinfo'

    def to_dropdown(self, killevt=True, select_all=None):

        v = f'{self.get()}'

        if v in self.enum_items:
            v = self.enum_items[v].name

        if hasattr(self, "D_icon"):
            D_icon = self.D_icon
            def get_icon(e):
                if hasattr(e, "identifier"):
                    return D_icon[e.identifier]()  if e.identifier in D_icon else GpuImgNull()

                return D_icon[e.name]()  if e.name in D_icon else GpuImgNull()
        else:
            get_icon = self.get_icon  if hasattr(self, "get_icon") else None

        return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name, get_icon=get_icon)
        #|

    def set(self, v, refresh=True, undo_push=True): # ALlow INput NAme, NonE
        # <<< 1copy (0defuiSetEnum,, $$)
        # <<< 1copy (0defuiSetDriverEval,, $$)
        if isinstance(v, str):
            # v = v.strip()
            if v.startswith("#"):
                v = v[1 : ]
                if v.startswith("#"): pass
                else:
                    self.evt_add_driver(exp=v, replace=True)
                    return
            elif v.startswith(";"):
                v = v[1 : ]
                if v.startswith(";"): pass
                else:
                    v = bpyeval(v)
        # >>>

        rna = self.rna

        if v in self.enum_items:
            setattr(self.pp, self.identifier, v)

            if hasattr(self, "set_callback"):
                ret = self.set_callback()
                if ret is True: return
                if ret is False: refresh = False

            if refresh: update_data()

            if undo_push:
                ed_undo_push(message=f'{self.rna.name} : {getattr(self.pp, self.identifier)}')
        else:
            if v == None:
                if hasattr(rna, "is_never_none") and rna.is_never_none: return
            else:
                for e in self.enum_items:
                    if e.name == v:
                        setattr(self.pp, self.identifier, e.identifier)

                        if hasattr(self, "set_callback"):
                            ret = self.set_callback()
                            if ret is True: return
                            if ret is False: refresh = False

                        if refresh: update_data()

                        if undo_push:
                            ed_undo_push(message=f'{self.rna.name} : {getattr(self.pp, self.identifier)}')
                        return
        # >>>
        #|

    def upd_data(self):
        # <<< 1copy (0defuiEnumUpdData,, $$)
        self.upd_anim_button()
        if self.blf_value.unclip_text == getattr(self.pp, self.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.identifier)
        blf_value.unclip_text = v

        if v == None: v = "None"
        else:
            if v in self.enum_items: v = self.enum_items[v].name

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if hasattr(self, "r_button_width"):
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
            else:
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (D_SIZE['font_main_title_offset'] * 2 + round(blfDimen(FONT0, self.blf_title.unclip_text)[0])) - (
                D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0])
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0])
        # >>>
        #|
    #|
    #|
@ toNoAnim
class BuEnumNoAnim(BuEnum): __slots__ = ()
@ assign(
    update_icon = c_upd_icon_StrFile)
@ focusStrFile
class BuStrFile(BuStrArrow):
    __slots__ = ()

    def modal(self):
        # <<< 1copy (0defuiModalID0,, $$)
        if self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.is_trigger_anim_enable = True
                self.focus_element = 3
                Admin.REDRAW()
                self.focus_anim()

        elif MOUSE[0] < self.box_button.R:
            if self.box_icon_arrow.L <= MOUSE[0]:
                if self.focus_element != 1:

                    self.focus_element = 1
                    Admin.REDRAW()
                    self.focus_eye()

            else:
                if self.focus_element != 0:

                    self.focus_element = 0
                    Admin.REDRAW()
                    self.focus_default()

        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_dropdown()
                return True
            elif i == 1:
                if self.isdark is True: return True
                self.to_filebrowser()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        #|

    def to_filebrowser(self):


        if self.rna.subtype.startswith("DIR"):
            OpScanFolder.end_fn = self.set
            bpy.ops.wm.vmd_scan_folder("INVOKE_DEFAULT", directory=self.get())
        else:
            OpScanFile.end_fn = self.set
            bpy.ops.wm.vmd_scan_file("INVOKE_DEFAULT", filepath=self.get())
        #|

    def upd_data(self):
        # <<< 1copy (0defuiStrUpdData,, ${
        #     ')#_REF_': ' - SIZE_widget[0])'
        # }$)
        self.upd_anim_button()
        if self.blf_value.unclip_text == getattr(self.pp, self.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.identifier)
        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if self.blf_title.unclip_text:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
            else:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (
                D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0])
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0])
        # >>>
        #|
    #|
    #|

@ assign(
    r_height = c_r_height_xy,
    inside_evt = c_inside_evt_bool)
@ turnButtonStateEnum
@ focusEnumXY
class BuEnumXY(inher_different(BuEnum, {'tag_clipping_dirty'})):
    __slots__ = 'enum_value', 'row_length', 'is_trigger_enable'

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard, enum_items, row_length):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data

        self.enum_items = enum_items
        self.row_length = row_length
        self.box_button = [GpuButtonBool()  for e in enum_items]
        self.box_anim = GpuImgNull()

        self.blf_value = [BlfColor(e.name, color=COL_box_button_fg)  for e in enum_items]
        self.blf_title = BlfClipColor(unclip_text=rna.name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button
        self.enum_value = ""
        #|

    def set_button_text(self, ls):
        for s, e in zip(ls, self.blf_value):
            if s is None: continue
            e.text = s
        #|

    def init_bat_anim(self, LL, RR, TT):
        row_length = self.row_length
        box_button = self.box_button
        blf_value = self.blf_value

        widget_rim = SIZE_border[3]
        full_h = D_SIZE['widget_full_h']

        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - full_h

        B9 = B + widget_rim
        self.box_anim.LRBT_upd(R2, RR, B9, TT - widget_rim)

        y = B9 + D_SIZE['font_main_dy']
        e = self.blf_title
        e.y = y
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])

        width = (R1 - L) // row_length
        range_row = range(row_length)
        LRs = []
        R0 = L + width
        for _ in range_row:
            LRs.append([L, R0])
            L = R0
            R0 += width
        LRs[-1][1] = R1

        i = 0
        amount = len(box_button) // row_length
        for _ in range(amount):
            for r in range_row:
                # /* 0blockBuEnumXYinitbutton
                L0, R0 = LRs[r]
                box_button[i].LRBT_upd(L0, R0, B, TT, widget_rim)
                e = blf_value[i]
                e.y = y
                e.x = floor((R0 + L0 - blfDimen(FONT0, e.text)[0]) / 2)
                i += 1
                # */

            TT = B
            B -= full_h
            y -= full_h

        for r in range(len(box_button) - amount * row_length):
            # <<< 1copy (0blockBuEnumXYinitbutton,, $$)
            L0, R0 = LRs[r]
            box_button[i].LRBT_upd(L0, R0, B, TT, widget_rim)
            e = blf_value[i]
            e.y = y
            e.x = floor((R0 + L0 - blfDimen(FONT0, e.text)[0]) / 2)
            i += 1
            # >>>
        return box_button[-1].B
        #|

    def dark(self):
        # <<< 1copy (0defuiEnumXYDark,, $$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        for e in self.box_button: e.dark()
        for e in self.blf_value: e.color = COL_box_button_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        # >>>
        #|
    def light(self):
        # <<< 1copy (0defuiEnumXYLight,, $$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        for e in self.box_button: e.light()
        for e in self.blf_value: e.color = COL_box_button_fg
        self.blf_title.color = COL_block_fg
        # >>>
        #|

    def r_focus_index(self, mouse):
        for r, e in enumerate(self.box_button):
            if e.inbox(mouse): return r
        return None
        #|

    def fn(self, i):

        Admin.REDRAW()
        v = self.enum_items[i].identifier
        self.set(v)
        #|

    def inside(self, mouse):
        box_button = self.box_button
        if box_button[0].L <= mouse[0] < self.box_anim.R:
            if box_button[-1].B <= mouse[1] < self.box_button[0].T:
                return True
        return False
        #|

    def modal(self):
        # <<< 1copy (0defuiModalEnumXY0,, $$)
        if self.box_anim.inbox(MOUSE):
            if self.focus_element != 3:

                self.focus_element = 3
                self.is_trigger_anim_enable = True
                Admin.REDRAW()
                self.focus_anim()
        else:
            i = self.r_focus_index(MOUSE)
            if i is None:
                if self.focus_element != -1:

                    self.focus_element = -1
                    Admin.REDRAW()
                    self.focus_empty()
            else:
                if self.focus_element != (i, ):

                    self.focus_element = (i, )
                    self.is_trigger_enable = True
                    Admin.REDRAW()
                    self.focus_default(i)

        # <<< 1copy (0defuiCheckTriggerBool,, $$)
        if self.is_trigger_anim_enable is True and self.is_trigger_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
            self.is_trigger_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
            elif isinstance(i, tuple) and self.is_trigger_enable is True:
                self.is_trigger_enable = False
                self.fn(i[0])
                return True
        return False
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiEnumXYDxy,, $$)
        for e in self.box_button:
            e.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        for e in self.blf_value:
            e.x += dx
            e.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        #|

    def i_draw_box(self):
        for e in self.box_button:
            e.bind_draw()

        self.box_anim.bind_draw()
        #|
    def i_draw_box_anim(self):
        for e in self.box_button:
            e.bind_draw()

        self.box_anim.bind_draw()
        self.box_hover.bind_draw()
        #|
    def i_draw_blf(self):
        blfSize(FONT0, D_SIZE['font_main'])
        for e in self.blf_value:
            blfColor(FONT0, *e.color)
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)

        e = self.blf_title
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self):
        # <<< 1copy (0defuiEnumXYUpdData,, $$)
        self.upd_anim_button()
        if self.enum_value == getattr(self.pp, self.identifier): return


        v = getattr(self.pp, self.identifier)
        self.enum_value = v

        if v in self.enum_items:
            for r, e in enumerate(self.enum_items):
                if e.identifier == v:
                    self.turnon_button(r)
                else:
                    self.turnoff_button(r)
        else:
            for r, e in enumerate(self.enum_items):
                self.turnoff_button(r)
        # >>>
        #|
    #|
    #|
@ toNoAnim
class BuEnumXYNoAnim(BuEnumXY): __slots__ = ()

@ assign(
    i_upd_anim_button = c_upd_button_keyframe_ENUMFLAG,
    i_upd_anim_button_dark = c_upd_button_keyframe_ENUMFLAG_dark,
    i_upd_anim_button_ov = c_upd_button_keyframe_ENUMFLAG_ov,
    i_upd_anim_button_ov_dark = c_upd_button_keyframe_ENUMFLAG_ov_dark)
@ turnButtonState
@ focusEnumFlag
class BuEnumFlag(BuEnumXY):
    __slots__ = ()

    def r_default_value(self): return self.rna.default_flag

    def fn(self, i):

        Admin.REDRAW()
        old_v = self.get()
        enum_ident = self.enum_items[i].identifier

        if is_first_press('click') == False:
            boo = _last_bool_state[0]
        else:
            boo = enum_ident not in old_v
            _last_bool_state[0] = boo

        if boo:
            if enum_ident in old_v: pass
            else:
                new_v = old_v.copy()
                new_v.add(enum_ident)
                self.set(new_v)
        else:
            if enum_ident in old_v:
                new_v = old_v.copy()
                new_v.remove(enum_ident)
                self.set(new_v)
        #|

    def set(self, v, refresh=True, undo_push=True): # stR oR seT, NonE, alloW inpuT namE
        rna = self.rna
        if not v: v = set()

        # <<< 1copy (0defuiSetDriverEval,, $$)
        if isinstance(v, str):
            # v = v.strip()
            if v.startswith("#"):
                v = v[1 : ]
                if v.startswith("#"): pass
                else:
                    self.evt_add_driver(exp=v, replace=True)
                    return
            elif v.startswith(";"):
                v = v[1 : ]
                if v.startswith(";"): pass
                else:
                    v = bpyeval(v)
        # >>>
        #
            elif v == "":
                v = set()
            else:
                array = calc_vec(v)
                if isinstance(array, list):
                    le = len(self.enum_items)
                    new_v = set()
                    for e in array:
                        if isinstance(e, (float, int)):
                            i = int(e)
                            if i < le:
                                new_v.add(self.enum_items[i].identifier)

                    if new_v:
                        v = new_v
                else:
                    if v[ : 1] in "([{":
                        v = bpyeval(v)
                    elif v.find(",") == -1:
                        v = {v}
                    else:
                        v = {s.strip()  for s in v.split(",")}

        name_to_id = {e.name: identifier  for identifier, e in self.enum_items.items()}

        try:
            setattr(self.pp, self.identifier, {(name_to_id[v]  if v in name_to_id else v)  for v in v})

            if hasattr(self, "set_callback"):
                ret = self.set_callback()
                if ret is True: return
                if ret is False: refresh = False

            if refresh: update_data()

            if undo_push:
                ed_undo_push(message=f'{self.rna.name} : {self.get()}')
        except: return
        #|

    def upd_data(self):
        self.upd_anim_button()
        if self.enum_value == getattr(self.pp, self.identifier): return


        v = getattr(self.pp, self.identifier)
        self.enum_value = v

        if v:
            for r, e in enumerate(self.enum_items):
                self.turnon_button(r)  if e.identifier in v else self.turnoff_button(r)
        else:
            for r, e in enumerate(self.enum_items): self.turnoff_button(r)
        #|
    #|
    #|
# @ toNoAnim
# class BuEnumFlagNoAnim(BuEnumFlag): __slots__ = ()

@ assign(
    r_default_value = c_r_default_value_comb,
    set_ui_state_overridden = c_set_ui_state_overridden_comb,
    i_upd_anim_button = c_upd_button_keyframe_BOOLFLAG,
    i_upd_anim_button_dark = c_upd_button_keyframe_BOOLFLAG_dark,
    i_upd_anim_button_ov = c_upd_button_keyframe_BOOLFLAG_ov,
    i_upd_anim_button_ov_dark = c_upd_button_keyframe_BOOLFLAG_ov_dark)
@ turnButtonState
@ focusEnumFlag
@ combEvt
class BuBoolFlag(BuEnumXY):
    __slots__ = ()

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard, button_names, row_length):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = [e.identifier  for e in rna]
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data

        self.row_length = row_length
        self.box_button = [GpuButtonBool()  for e in rna]
        self.box_anim = GpuImgNull()

        self.blf_value = [BlfColor(e, color=COL_box_button_fg)  for e in button_names]
        self.blf_title = BlfClipColor(unclip_text=rna[0].name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button
        self.enum_value = None
        #|

    def dark(self, index=None):
        if index is None:
            for e in self.box_button: e.dark()
            for e in self.blf_value: e.color = COL_box_button_fg_ignore

            self.isdark = True
        else:
            self.box_button[index].dark()
            self.blf_value[index].color = COL_box_button_fg_ignore

            isdark = sum((1 << r)  if e.is_dark() is True else 0  for r, e in enumerate(self.box_button))
            if isdark == 0:
                self.isdark = False
            elif isdark == (1 << len(self.box_button)) - 1:
                self.isdark = True
            else:
                self.isdark = isdark

        if self.isdark is True:
            if self.overridden_state == 0:
                self.upd_anim_button = self.i_upd_anim_button_dark
            else:
                self.upd_anim_button = self.i_upd_anim_button_ov_dark

            self.blf_title.color = COL_block_fg_ignore
        #|
    def light(self, index=None):
        if index is None:
            for e in self.box_button: e.light()
            for e in self.blf_value: e.color = COL_box_button_fg

            self.isdark = False
        else:
            self.box_button[index].light()
            self.blf_value[index].color = COL_box_button_fg

            isdark = sum((1 << r)  if e.is_dark() is True else 0  for r, e in enumerate(self.box_button))
            if isdark == 0:
                self.isdark = False
            elif isdark == (1 << len(self.box_button)) - 1:
                self.isdark = True
            else:
                self.isdark = isdark

        if self.isdark is False:
            if self.overridden_state == 0:
                self.upd_anim_button = self.i_upd_anim_button
            else:
                self.upd_anim_button = self.i_upd_anim_button_ov

            self.blf_title.color = COL_block_fg
        #|

    def fn(self, i):

        Admin.REDRAW()
        if is_first_press('click') == False:
            self.set(_last_bool_state[0], i)
        else:
            boo = not self.get(i)
            self.set(boo, i)
            _last_bool_state[0] = boo
        #|

    def upd_data(self):
        # <<< 1copy (0defuiBoolFlagUpdData,, $$)
        self.upd_anim_button()
        pp = self.pp
        if self.enum_value == [getattr(pp, attr)  for attr in self.identifier]: return


        v = [getattr(pp, attr)  for attr in self.identifier]
        self.enum_value = v

        for r, v in enumerate(v):
            if v:
                self.turnon_button(r)
            else:
                self.turnoff_button(r)
        # >>>
        #|
    #|
    #|
@ toNoAnim
class BuBoolFlagNoAnim(BuBoolFlag): __slots__ = ()

@ assign(
    r_default_value = c_r_default_value_vec,
    set = c_set_vec,
    i_upd_anim_button = c_upd_button_keyframe_BOOL_vec_flag,
    i_upd_anim_button_dark = c_upd_button_keyframe_BOOL_vec_flag_dark,
    i_upd_anim_button_ov = c_upd_button_keyframe_BOOL_vec_flag_ov,
    i_upd_anim_button_ov_dark = c_upd_button_keyframe_BOOL_vec_flag_ov_dark,
    bufn_keyframe = c_bufn_keyframe_group)
@ turnButtonState
@ focusEnumFlag
class BuBoolVecFlag(BuEnumXY):
    __slots__ = 'array_length', 'vec_range'

    def fn(self, i):

        Admin.REDRAW()
        old_v = self.get()

        if is_first_press('click') == False:
            boo = _last_bool_state[0]
        else:
            boo = not old_v[i]
            _last_bool_state[0] = boo

        self.set(boo, i)
        #|

    def upd_data(self):
        self.upd_anim_button()
        if self.enum_value == list(getattr(self.pp, self.identifier)): return


        v = list(getattr(self.pp, self.identifier))
        self.enum_value = v

        for r, v in enumerate(v):
            if v:
                self.turnon_button(r)
            else:
                self.turnoff_button(r)
        #|
    #|
    #|

@ assign(
    i_dxy = c_dxy_BuEnumIcon,
    i_draw_box = c_draw_box_BuEnumIcon,
    i_draw_box_anim = c_draw_box_anim_BuEnumIcon)
class BuEnumIcon(BuEnum):
    __slots__ = 'box_icon', 'box_icon_cls', 'D_icon'

    def init_bat_anim(self, LL, RR, TT):
        # 0blockBuEnumInitBatAnim
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        L9, R9, B9, T9 = self.box_button.inner
        self.box_icon_arrow.LRBT_upd(R9 - SIZE_widget[0], R9, B9, T9)

        blf_y = B9 + D_SIZE['font_main_dy']
        self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
        self.blf_value.y = blf_y

        e = self.blf_title
        e.y = blf_y
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])

        self.box_anim.LRBT_upd(R2, RR, B9, T9)

        L0 = L + widget_rim
        self.box_icon.LRBT_upd(L0, L0 + SIZE_widget[0], B9, T9)
        if self.box_icon.__class__ is GpuImgNull: pass
        else:
            self.blf_value.x += SIZE_widget[0]
        return B
        #|

    def dark(self):
        # <<< 1copy (0defuiEnumDark,, $$)
        # <<< 1copy (0defuiStrDark,, $$)
        # <<< 1copy (0defuiDark,, ${'_box_val':'_box_text'}$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_text_ignore
        self.box_button.color_rim = COL_box_text_rim_ignore
        self.blf_value.color = COL_box_text_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        # >>>
        self.box_icon_arrow.set_draw_state(False)
        # >>>

        if self.blf_value.unclip_text in self.D_icon:
            self.box_icon.__class__ = GpuImg_stop_dark
        else:
            self.box_icon.__class__ = GpuImgNull
        #|
    def light(self):
        # <<< 1copy (0defuiEnumLight,, $$)
        # <<< 1copy (0defuiStrLight,, $$)
        # <<< 1copy (0defuiLight,, ${'_box_val':'_box_text'}$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_text
        self.box_button.color_rim = COL_box_text_rim
        self.blf_value.color = COL_box_text_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        # >>>
        self.box_icon_arrow.set_draw_state(True)
        # >>>

        v = self.blf_value.unclip_text
        if v in self.D_icon:
            self.box_icon.__class__ = self.D_icon[v]
        else:
            self.box_icon.__class__ = GpuImgNull
        #|

    def upd_data(self):
        self.upd_anim_button()
        if self.blf_value.unclip_text == getattr(self.pp, self.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.identifier)
        blf_value.unclip_text = v
        if v in self.D_icon:
            if self.isdark is True:
                self.box_icon.__class__ = GpuImg_stop_dark
            else:
                self.box_icon.__class__ = self.D_icon[v]
        else:
            self.box_icon.__class__ = GpuImgNull

        if v == None: v = "None"
        else:
            if v in self.enum_items: v = self.enum_items[v].name

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if hasattr(self, "r_button_width"):
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
            else:
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            if self.box_icon.__class__ is GpuImgNull:
                self.blf_value.x = self.box_button.inner[0] + D_SIZE['font_main_dx']
            else:
                self.blf_value.x = self.box_button.inner[0] + D_SIZE['font_main_dx'] + SIZE_widget[0]
                button_width -= SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (D_SIZE['font_main_title_offset'] * 2 + round(blfDimen(FONT0, self.blf_title.unclip_text)[0])) - (
                D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0])
        else:
            if self.box_icon.__class__ is GpuImgNull:
                self.blf_value.x = self.box_button.inner[0] + D_SIZE['font_main_dx']
                blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                    ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0])
            else:
                self.blf_value.x = self.box_button.inner[0] + D_SIZE['font_main_dx'] + SIZE_widget[0]
                blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                    ) - (D_SIZE['font_main_dx'] + SIZE_border[3] + SIZE_widget[0]) * 2)
        #|
    #|
    #|
@ toNoAnim
class BuEnumIconNoAnim(BuEnumIcon): __slots__ = ()

@ assign(
    init_bat_anim = c_init_bat_anim_BuEnumIcon,
    init_bat_anim_FULL = c_init_bat_anim_BuEnumIcon_FULL,
    i_draw_box = c_draw_box_BuEnumIcon,
    i_draw_box_anim = c_draw_box_anim_BuEnumIcon,
    i_dxy = c_dxy_BuEnumIcon)
@ focusID
class BuID(BuStr):
    __slots__ = 'box_icon', 'box_icon_arrow', 'idtype', 'allow_types', 'r_except_objects', 'fixed_idtype'

    def r_default_value(self): return None

    def dark(self):
        # <<< 1copy (0defuiEnumDark,, $$)
        # <<< 1copy (0defuiStrDark,, $$)
        # <<< 1copy (0defuiDark,, ${'_box_val':'_box_text'}$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_text_ignore
        self.box_button.color_rim = COL_box_text_rim_ignore
        self.blf_value.color = COL_box_text_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        # >>>
        self.box_icon_arrow.set_draw_state(False)
        # >>>
        self.update_icon()
        #|
    def light(self):
        # <<< 1copy (0defuiEnumLight,, $$)
        # <<< 1copy (0defuiStrLight,, $$)
        # <<< 1copy (0defuiLight,, ${'_box_val':'_box_text'}$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_text
        self.box_button.color_rim = COL_box_text_rim
        self.blf_value.color = COL_box_text_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        # >>>
        self.box_icon_arrow.set_draw_state(True)
        # >>>
        self.update_icon()
        #|

    def modal(self):
        # <<< 1copy (0defuiModalID0,, $$)
        if self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.is_trigger_anim_enable = True
                self.focus_element = 3
                Admin.REDRAW()
                self.focus_anim()

        elif MOUSE[0] < self.box_button.R:
            if self.box_icon_arrow.L <= MOUSE[0]:
                if self.focus_element != 1:

                    self.focus_element = 1
                    Admin.REDRAW()
                    self.focus_eye()

            else:
                if self.focus_element != 0:

                    self.focus_element = 0
                    Admin.REDRAW()
                    self.focus_default()

        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True
        if TRIGGER['ui_jump_to_target']():
            self.evt_jump_to_target()
            return True
        if TRIGGER['ui_mark_asset']():
            self.evt_mark_asset()
            return True
        if TRIGGER['dd_preview']():
            self.evt_area_preview()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_dropdown()
                return True
            elif i == 1:
                ob = self.get()
                if ob:

                    self.set(None)
                    kill_evt_except()
                else:
                    if self.idtype == "OBJECT":
                        self.to_modal_picker()
                    else:
                        self.to_dropdown()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        idtype = self.idtype
        bpy_data_type = getattr(bpy.data, D_id_blendData[idtype], None)
        if bpy_data_type is None: return

        LRBT = self.box_button.r_LRBT()
        fixed_width = LRBT[1] - LRBT[0] > SIZE_widget[0] * 12

        get_icon = None


        if idtype == "OBJECT": get_icon = geticon_Object
        if idtype == "IMAGE":
            return DropDownEnumImage(self, LRBT, self.rna.name, bpy_data_type, fixed_width=fixed_width)
        elif idtype == "TEXTURE":
            return DropDownEnumTexture(self, LRBT, self.rna.name, bpy_data_type, fixed_width=fixed_width)
        elif idtype == "MATERIAL":
            return DropDownEnumMaterial(self, LRBT, self.rna.name, bpy_data_type, fixed_width=fixed_width)

        return DropDownEnumPointer(self, LRBT, self.rna.name,
            bpy_data_type,
            self.allow_types,
            self.r_except_objects,
            get_icon = get_icon,
            fixed_width = fixed_width)
        #|
    def to_modal_picker(self):

        modal_object_picker_init(self.allow_types, self.r_except_objects, self.set)
        #|

    @ catch
    def evt_jump_to_target(self, is_report=True):

        kill_evt_except()
        pp = self.r_pp()
        self.pp = pp
        if not pp: return

        ob = self.get()
        if hasattr(ob, "visible_get"):
            if ob.visible_get():
                if object_select(ob, "EXTEND"):
                    update_scene_push(f'jump to target "{ob.name}"')
            else:
                if is_report:
                    report("Object is not visible")
        #|
    @ catch
    def evt_mark_asset(self, is_report=True):

        kill_evt_except()
        pp = self.r_pp()
        self.pp = pp
        if not pp: return
        ob = pp.id_data
        if ui_poll_library(ob, is_report) is False: return

        if self.isdark is True and self.isdarkhard is True: return

        ob = self.get()
        if hasattr(ob, "asset_data") and r_id_type(ob) in S_ALLOW_ASSET: pass
        else: return

        if ob.asset_data:
            ob.asset_clear()
            if is_report:
                report(f'"{ob.name}" is not an asset anymore')
            update_scene_push(f'Clear asset "{ob.name}"')
        else:
            ob.asset_mark()
            if is_report:
                report(f'"{ob.name}" is now an asset')
            update_scene_push(f'Mark asset "{ob.name}"')
        #|
    @ catch
    def evt_area_preview(self, is_report=True):

        kill_evt_except()
        pp = self.r_pp()
        self.pp = pp
        if not pp: return
        ob = self.get()

        if ob:
            idtype = r_id_type(ob)
            if idtype in S_ALLOW_PREVIEW:
                preview_datablock(ob)
        #|

    def set(self, v, refresh=True, undo_push=True):
        # <<< 1copy (0defuiSetID,, $$)
        if isinstance(v, str):
            if self.idtype in D_id_blendData: pass
            else: return

            datas = getattr(bpy.data, D_id_blendData[self.idtype])
            if v:
                if v.startswith(";;"):
                    v = v[1 :]
                    if v in datas: v = datas[v]
                    else:
                        if refresh: report("Object not found")
                        return
                elif v.startswith(";"):
                    try: v = bpyeval(v[1 :])
                    except:
                        if refresh: report("Eval failed")
                        return
                else:
                    if v in datas: v = datas[v]
                    else:
                        if refresh: report("Object not found")
                        return
            else:
                v = None

        try:
            if self.r_except_objects is not None and v in self.r_except_objects():
                if refresh: report("Invalid Object")
                return
        except: pass

        if hasattr(v, "type"):
            if self.allow_types is not None:
                if v.type not in self.allow_types:
                    if refresh: report("Invalid Object Type")
                    return

        setattr(self.pp, self.identifier, v)

        if hasattr(self, "set_callback"):
            ret = self.set_callback()
            if ret is True: return
            if ret is False: refresh = False

        if refresh: update_data()

        if undo_push:
            ob = getattr(self.pp, self.identifier)
            ed_undo_push(message=f'{self.rna.name} : {ob.name  if hasattr(ob, "name") else ob}')
        # >>>
        #|

    def update_icon(self, ob=0):
        if ob == 0:
            name = self.blf_value.unclip_text
            idtype = self.idtype
        else:
            idtype = self.idtype
            # GOodIDtype
            if idtype in D_id_blendData and hasattr(bpy.data, D_id_blendData[idtype]): pass
            else:
                self.isdarkhard = True
                self.dark()

            if ob:
                if self.fixed_idtype is False:
                    newidtype = r_id_type(ob)
                    if newidtype is not None:
                        self.idtype = newidtype

                name = ob.name
            else:
                name = ""

        if idtype == "OBJECT":
            if name:
                if self.isdark is True:
                    self.box_icon_arrow.__class__ = GpuImg_delete_dark
                    self.box_icon.__class__ = GpuImg_stop_dark
                else:
                    self.box_icon_arrow.__class__ = GpuImg_delete

                    if self.fixed_idtype is True and isinstance(self.allow_types, set) and len(self.allow_types) == 1:
                        self.box_icon.__class__ = getattr(blg, f"GpuImg_OUTLINER_OB_{self.allow_types.copy().pop()}", GpuImg_ID_OBJECT)
                    else:
                        self.box_icon.__class__ = GpuImg_ID_OBJECT
            else:
                if self.isdark is True:
                    self.box_icon_arrow.__class__ = GpuImg_object_picker_dark
                    self.box_icon.__class__ = GpuImg_stop_dark
                else:
                    self.box_icon_arrow.__class__ = GpuImg_object_picker

                    if self.fixed_idtype is True and isinstance(self.allow_types, set) and len(self.allow_types) == 1:
                        self.box_icon.__class__ = getattr(blg, f"GpuImg_OUTLINER_OB_{self.allow_types.copy().pop()}", GpuImg_ID_OBJECT)
                    else:
                        self.box_icon.__class__ = GpuImg_ID_OBJECT
        else:
            if self.isdark is True:
                self.box_icon.__class__ = GpuImg_stop_dark
                if name:
                    self.box_icon_arrow.__class__ = GpuImg_delete_dark
                else:
                    self.box_icon_arrow.__class__ = GpuImgNull
            else:
                self.box_icon.__class__ = getattr(blg, f"GpuImg_ID_{idtype}", GpuImgNull)
                if name:
                    self.box_icon_arrow.__class__ = GpuImg_delete
                else:
                    self.box_icon_arrow.__class__ = GpuImg_unfold
        #|
    def upd_data(self):
        # <<< 1copy (0defuiIDUpdData,, $$)
        self.upd_anim_button()
        ob = getattr(self.pp, self.identifier)
        if self.blf_value.unclip_text == (ob.name  if ob else ""): return


        blf_value = self.blf_value
        v = ob.name  if ob else ""
        blf_value.unclip_text = v
        self.update_icon(ob)

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if self.blf_title.unclip_text:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
            else:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (
                D_SIZE['font_main_dx'] + SIZE_border[3] + SIZE_widget[0]) * 2)
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3] + SIZE_widget[0]) * 2)
        # >>>
        #|
    #|
    #|

class BuPointer(BuID):
    __slots__ = 'r_items', 'icon_cls'

    def update_icon(self, ob=0):
        if ob:
            if self.isdark is True:
                self.box_icon_arrow.__class__ = GpuImg_delete_dark
                self.box_icon.__class__ = GpuImg_stop_dark
            else:
                self.box_icon_arrow.__class__ = GpuImg_delete
                self.box_icon.__class__ = self.icon_cls
        else:
            if self.isdark is True:
                self.box_icon_arrow.__class__ = GpuImgNull
                self.box_icon.__class__ = GpuImg_stop_dark
            else:
                self.box_icon_arrow.__class__ = GpuImg_unfold
                self.box_icon.__class__ = self.icon_cls
        #|

    def evt_jump_to_target(self, is_report=True):

        kill_evt_except()
        #|
    def evt_mark_asset(self, is_report=True):

        kill_evt_except()
        #|

    def to_dropdown(self, killevt=True, select_all=None):


        try: items = self.r_items()
        except: items = []
        return DropDownEnumPointer(self, self.box_button.r_LRBT(), self.rna.name, items)
        #|
    #|
    #|
class BuTexture(BuID):
    __slots__ = (
        'box_icon_fakeuser',
        'box_icon_duplicate',
        'box_icon_rename',
        'user_state',
        'link_state',
        'blf_users',
        'icon_cls')

    def __init__(self, w, rna, r_pp, ui_anim_data, text, isdarkhard):
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data

        self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_anim = GpuImgNull()

        self.blf_value = BlfClipColor("", "", 0, 0, COL_box_text_fg)
        self.blf_title = BlfClipColor(unclip_text=rna.name  if text is None else text,
            color=COL_block_fg)

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = self.i_upd_anim_button

        self.fixed_idtype = True
        self.get_icon_cls_and_idtype()
        self.allow_types = None
        self.r_except_objects = None
        self.box_icon_arrow = GpuImg_unfold()
        self.box_icon = self.icon_cls()
        self.box_icon_fakeuser = GpuImg_FAKE_USER_OFF()
        self.box_icon_duplicate = GpuImg_DUPLICATE()
        self.box_icon_rename = GpuImg_rename()
        self.init_bat = self.init_bat_anim
        self.user_state = "NONE"
        self.link_state = "NONE"
        self.blf_users = BlfClipColor("", 0, 0, 0, COL_box_text_fg)
        self.focus_element = -1
        self.update_icon()
        #|
    def get_icon_cls_and_idtype(self):
        self.idtype = "TEXTURE"
        self.icon_cls = GpuImg_ID_TEXTURE
        #|

    def init_bat_anim(self, LL, RR, TT):
        self.blf_users.unclip_text = ""
        widget_rim = SIZE_border[3]
        h = SIZE_widget[0]
        R2 = RR - h
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        L1, R9, B9, T9 = self.box_button.inner
        L9 = R9 - h
        self.box_icon_arrow.LRBT_upd(L9, R9, B9, T9)
        L9 -= h
        R9 -= h
        self.box_icon_fakeuser.LRBT_upd(L9, R9, B9, T9)
        L9 -= h
        R9 -= h
        self.box_icon_duplicate.LRBT_upd(L9, R9, B9, T9)
        L9 -= h
        R9 -= h
        self.box_icon_rename.LRBT_upd(L9, R9, B9, T9)
        L2 = L1 + h
        self.box_icon.LRBT_upd(L1, L2, B9, T9)

        blf_y = B9 + D_SIZE['font_main_dy']
        self.blf_value.x = L2 + widget_rim + D_SIZE['font_main_dx']
        self.blf_value.y = blf_y
        self.blf_users.y = blf_y

        e = self.blf_title
        e.y = blf_y
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        e.x = R0 - round(blfDimen(FONT0, e.text)[0])

        self.box_anim.LRBT_upd(R2, RR, B9, T9)
        return B
        #|
    def init_bat_anim_FULL(self, LL, RR, TT):
        self.blf_users.unclip_text = ""
        widget_rim = SIZE_border[3]
        h = SIZE_widget[0]
        R2 = RR - h
        R1 = R2 - widget_rim

        blf_title = self.blf_title
        if blf_title.unclip_text:
            blfSize(FONT0, D_SIZE['font_main'])
            if hasattr(self, "r_button_width"):
                blf_title.x = LL + D_SIZE['font_main_title_offset'] + self.r_button_width()
            else:
                blf_title.x = LL + D_SIZE['font_main_title_offset']

            L = blf_title.x + round(blfDimen(FONT0, blf_title.unclip_text)[0]) + D_SIZE['font_main_title_offset']
        else:
            if hasattr(self, "r_button_width"):
                L = LL + widget_rim + widget_rim + self.r_button_width()
            else:
                L = LL + widget_rim + widget_rim
            blf_title.x = L

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        L1, R9, B9, T9 = self.box_button.inner
        L9 = R9 - h
        self.box_icon_arrow.LRBT_upd(L9, R9, B9, T9)
        L9 -= h
        R9 -= h
        self.box_icon_fakeuser.LRBT_upd(L9, R9, B9, T9)
        L9 -= h
        R9 -= h
        self.box_icon_duplicate.LRBT_upd(L9, R9, B9, T9)
        L9 -= h
        R9 -= h
        self.box_icon_rename.LRBT_upd(L9, R9, B9, T9)
        L2 = L1 + h
        self.box_icon.LRBT_upd(L1, L2, B9, T9)

        blf_y = B9 + D_SIZE['font_main_dy']
        self.blf_value.x = L2 + widget_rim + D_SIZE['font_main_dx']
        self.blf_value.y = blf_y
        self.blf_users.y = blf_y

        blf_title.y = blf_y

        self.box_anim.LRBT_upd(R2, RR, B9, T9)
        return B
        #|

    def modal(self):
        if self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.is_trigger_anim_enable = True
                self.focus_element = 3
                Admin.REDRAW()
                self.focus_anim()

        elif MOUSE[0] < self.box_button.R:
            if self.box_icon_arrow.L <= MOUSE[0]:
                if self.focus_element != 1:

                    self.focus_element = 1
                    Admin.REDRAW()
                    self.focus_eye()

            elif self.box_icon_fakeuser.L <= MOUSE[0]:
                if self.focus_element != 4:
                    self.focus_element = 4

                    Admin.REDRAW()
                    self.focus_fakeuser()
            elif self.box_icon_duplicate.L <= MOUSE[0]:
                if self.focus_element != 5:
                    self.focus_element = 5

                    Admin.REDRAW()
                    self.focus_duplicate()
            elif self.box_icon_rename.L <= MOUSE[0]:
                if self.focus_element != 6:
                    self.focus_element = 6

                    Admin.REDRAW()
                    self.focus_rename()
            else:
                if self.focus_element != 0:

                    self.focus_element = 0
                    Admin.REDRAW()
                    self.focus_default()

        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>

        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True
        if TRIGGER['ui_jump_to_target']():
            self.evt_jump_to_target()
            return True
        if TRIGGER['ui_mark_asset']():
            self.evt_mark_asset()
            return True
        if TRIGGER['dd_preview']():
            self.evt_area_preview()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            ob = self.get()

            if i == 0:
                self.to_dropdown()
                return True
            elif i == 1:
                if ob:

                    kill_evt_except()
                    if hasattr(self, "evt_remove"):
                        self.evt_remove()
                    else:
                        self.set(None)
                else:
                    self.evt_new_item()
                return True
            elif i == 4:
                if ob:
                    self.evt_fakeuser()
                else:
                    self.to_dropdown()
                return True
            elif i == 5:
                if ob:
                    self.evt_duplicate()
                else:
                    self.to_dropdown()
                return True
            elif i == 6:
                if ob:
                    self.evt_rename()
                else:
                    self.to_dropdown()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        #|

    def focus_anim(self):
        self.draw_box = self.i_draw_box_anim
        if self.isdark is False:
            self.box_button.color = COL_box_text

            self.box_icon_arrow.__class__ = GpuImg_delete  if self.blf_value.unclip_text else GpuImg_ADD

            if self.user_state == "NONE": pass
            else:
                if self.user_state == "ASSET":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                elif self.user_state == "FAKEUSER":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF

                self.box_icon_duplicate.__class__ = GpuImgNull
                self.blf_users.color = COL_box_text_fg

                if self.link_state == "LINK":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                elif self.link_state == "OVERRIDE":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                else:
                    self.box_icon_rename.__class__ = GpuImg_rename

            if self.box_anim.__class__ is GpuImgNull:
                self.box_hover = GpuImgNull()
            else:
                self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
                self.box_hover.upd()
                self.dxy = self.i_dxy_anim_hover
        else:
            self.box_hover = GpuImgNull()
        #|
    def focus_eye(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text_fo

            self.box_icon_arrow.__class__ = GpuImg_delete_focus  if self.blf_value.unclip_text else GpuImg_ADD_focus

            if self.user_state == "NONE": pass
            else:
                if self.user_state == "ASSET":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                elif self.user_state == "FAKEUSER":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF

                self.box_icon_duplicate.__class__ = GpuImgNull
                self.blf_users.color = COL_box_text_fg

                if self.link_state == "LINK":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                elif self.link_state == "OVERRIDE":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                else:
                    self.box_icon_rename.__class__ = GpuImg_rename
        #|
    def focus_fakeuser(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text_fo

            self.box_icon_arrow.__class__ = GpuImg_delete  if self.blf_value.unclip_text else GpuImg_ADD

            if self.user_state == "NONE": pass
            else:
                if self.user_state == "ASSET":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB_focus
                elif self.user_state == "FAKEUSER":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON_focus
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF_focus

                self.box_icon_duplicate.__class__ = GpuImgNull
                self.blf_users.color = COL_box_text_fg

                if self.link_state == "LINK":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                elif self.link_state == "OVERRIDE":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                else:
                    self.box_icon_rename.__class__ = GpuImg_rename
        #|
    def focus_duplicate(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text_fo

            self.box_icon_arrow.__class__ = GpuImg_delete  if self.blf_value.unclip_text else GpuImg_ADD

            if self.user_state == "NONE": pass
            else:
                if self.user_state == "ASSET":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                elif self.user_state == "FAKEUSER":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF

                if self.blf_value.unclip_text:
                    self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE_focus
                self.blf_users.color = FLO_0000

                if self.link_state == "LINK":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                elif self.link_state == "OVERRIDE":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                else:
                    self.box_icon_rename.__class__ = GpuImg_rename
        #|
    def focus_rename(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text_fo

            self.box_icon_arrow.__class__ = GpuImg_delete  if self.blf_value.unclip_text else GpuImg_ADD

            if self.user_state == "NONE": pass
            else:
                if self.user_state == "ASSET":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                elif self.user_state == "FAKEUSER":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF

                self.box_icon_duplicate.__class__ = GpuImgNull
                self.blf_users.color = COL_box_text_fg

                if self.link_state == "LINK":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK_focus
                elif self.link_state == "OVERRIDE":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE_focus
                else:
                    self.box_icon_rename.__class__ = GpuImg_rename_focus
        #|
    def focus_default(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text_fo

            self.box_icon_arrow.__class__ = GpuImg_delete  if self.blf_value.unclip_text else GpuImg_ADD

            if self.user_state == "NONE": pass
            else:
                if self.user_state == "ASSET":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                elif self.user_state == "FAKEUSER":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF

                self.box_icon_duplicate.__class__ = GpuImgNull
                self.blf_users.color = COL_box_text_fg

                if self.link_state == "LINK":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                elif self.link_state == "OVERRIDE":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                else:
                    self.box_icon_rename.__class__ = GpuImg_rename
        #|
    def focus_empty(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text

            self.box_icon_arrow.__class__ = GpuImg_delete  if self.blf_value.unclip_text else GpuImg_ADD

            if self.user_state == "NONE": pass
            else:
                if self.user_state == "ASSET":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB
                elif self.user_state == "FAKEUSER":
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON
                else:
                    self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF

                self.box_icon_duplicate.__class__ = GpuImgNull
                self.blf_users.color = COL_box_text_fg

                if self.link_state == "LINK":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK
                elif self.link_state == "OVERRIDE":
                    self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE
                else:
                    self.box_icon_rename.__class__ = GpuImg_rename
        #|

    @ catch
    def evt_fakeuser(self, is_report=True):

        kill_evt_except()
        pp = self.r_pp()
        self.pp = pp
        if not pp: return
        if self.isdark is True and self.isdarkhard is True: return
        if ui_poll_library(pp.id_data, is_report) is False: return

        ob = self.get()
        if not ob: return
        if ui_poll_library(ob, is_report) is False: return

        if hasattr(ob, "asset_data") and ob.asset_data:
            if not hasattr(ob, "asset_clear"): return
            ob.asset_clear()
            update_scene_push(f"{type(ob).__name__} Asset Clear")
        elif ob.use_fake_user:
            ob.use_fake_user = False
            update_scene_push(f"{type(ob).__name__} Fake User disable")
        else:
            ob.use_fake_user = True
            update_scene_push(f"{type(ob).__name__} Fake User enable")
        #|
    @ catch
    def evt_duplicate(self, is_report=True):

        kill_evt_except()
        pp = self.r_pp()
        self.pp = pp
        if not pp: return
        if self.isdark is True and self.isdarkhard is True: return
        if ui_poll_library(pp.id_data, is_report) is False: return

        ob = self.get()
        if not ob: return

        self.set(ob.copy(), refresh=False, undo_push=False)
        update_scene_push(f"{type(ob).__name__} Duplicate")
        #|
    @ catch
    def evt_rename(self, is_report=True):

        kill_evt_except()
        pp = self.r_pp()
        self.pp = pp
        if not pp: return
        if self.isdark is True and self.isdarkhard is True: return
        if ui_poll_library(pp.id_data, is_report) is False: return

        ob = self.get()
        if not ob: return
        if ui_poll_library(ob, False) is False:
            dialog_override_create(self, ob)
            return

        if hasattr(self, "link_state"):
            if self.link_state == "OVERRIDE":
                dialog_override_clear(self, ob)
                return

        L, R, B, T = self.box_button.r_LRBT()

        DropDownEnumRename(None, (L, R, B, T), ob, ob, is_report=is_report)
        #|
    @ catch
    def evt_new_item(self, is_report=True):

        kill_evt_except()
        pp = self.r_pp()
        self.pp = pp
        if not pp: return
        if self.isdark is True and self.isdarkhard is True: return
        if ui_poll_library(pp.id_data, is_report) is False: return

        e = bpy.data.textures.new("", "IMAGE")
        self.set(e)
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiStrDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        self.box_icon_arrow.dxy_upd(dx, dy)
        self.box_icon.dxy_upd(dx, dy)

        self.box_icon_fakeuser.dxy_upd(dx, dy)
        self.box_icon_duplicate.dxy_upd(dx, dy)
        self.box_icon_rename.dxy_upd(dx, dy)

        self.blf_users.x += dx
        self.blf_users.y += dy
        #|

    def i_draw_box(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        self.box_icon_arrow.bind_draw()
        self.box_icon.bind_draw()
        self.box_icon_fakeuser.bind_draw()
        self.box_icon_duplicate.bind_draw()
        self.box_icon_rename.bind_draw()
        #|
    def i_draw_box_anim(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        self.box_icon_arrow.bind_draw()
        self.box_icon.bind_draw()
        self.box_icon_fakeuser.bind_draw()
        self.box_icon_duplicate.bind_draw()
        self.box_icon_rename.bind_draw()

        self.box_hover.bind_draw()
        #|
    def i_draw_blf(self):
        # <<< 1copy (0defuiDrawblf,, $$)
        e = self.blf_value
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)

        e = self.blf_title
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        # >>>

        e = self.blf_users
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def update_icon(self, ob=0):
        if ob == 0:
            ob = self.blf_value.unclip_text

        i = self.focus_element

        if self.isdark is False:
            self.box_icon.__class__ = self.icon_cls
            if ob:
                self.box_icon_arrow.__class__ = GpuImg_delete_focus  if i == 1 else GpuImg_delete
            else:
                self.box_icon_arrow.__class__ = GpuImg_ADD_focus  if i == 1 else GpuImg_ADD

            if self.user_state == "ASSET":
                self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_LIB_focus  if i == 4 else GpuImg_FAKE_USER_LIB
            elif self.user_state == "FAKEUSER":
                self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_ON_focus  if i == 4 else GpuImg_FAKE_USER_ON
            elif self.user_state == "FAKEUSER_OFF":
                self.box_icon_fakeuser.__class__ = GpuImg_FAKE_USER_OFF_focus  if i == 4 else GpuImg_FAKE_USER_OFF
            else:
                self.box_icon_fakeuser.__class__ = GpuImgNull

            if ob:
                if i == 5:
                    self.box_icon_duplicate.__class__ = GpuImg_DUPLICATE_focus
                    self.blf_users.color = FLO_0000
                else:
                    self.box_icon_duplicate.__class__ = GpuImgNull
                    self.blf_users.color = COL_box_text_fg
            else:
                self.blf_users.color = COL_box_text_fg
                self.box_icon_duplicate.__class__ = GpuImgNull

            if self.link_state == "LINK":
                self.box_icon_rename.__class__ = GpuImg_FAKE_USER_LINK_focus  if i == 6 else GpuImg_FAKE_USER_LINK
            elif self.link_state == "OVERRIDE":
                self.box_icon_rename.__class__ = GpuImg_FAKE_USER_OVERRIDE_focus  if i == 6 else GpuImg_FAKE_USER_OVERRIDE
            elif self.link_state == "DEFAULT":
                self.box_icon_rename.__class__ = GpuImg_rename  if i == 6 else GpuImg_rename
            else:
                self.box_icon_rename.__class__ = GpuImgNull
        else:
            self.box_icon.__class__ = GpuImg_stop_dark
            if ob:
                self.box_icon_arrow.__class__ = GpuImg_delete_dark
            else:
                self.box_icon_arrow.__class__ = GpuImgNull

            self.box_icon_fakeuser.__class__ = GpuImgNull
            self.box_icon_duplicate.__class__ = GpuImgNull
            self.box_icon_rename.__class__ = GpuImgNull
            self.blf_users.color = COL_box_text_fg_ignore
        #|
    def upd_data(self):
        self.upd_anim_button()
        ob = getattr(self.pp, self.identifier)
        if ob:
            if hasattr(ob, "asset_data") and ob.asset_data:
                user_state = "ASSET"
            else:
                user_state = "FAKEUSER"  if ob.use_fake_user else "FAKEUSER_OFF"

            if ob.library:
                link_state = "LINK"
            else:
                link_state = "OVERRIDE"  if hasattr(ob, "override_library") and ob.override_library else "DEFAULT"

            v = ob.name
            num_users = ob.users
        else:
            user_state = "NONE"
            link_state = "NONE"
            v = ""
            num_users = -1

        if self.blf_value.unclip_text == v and self.user_state == user_state and self.link_state == link_state and self.blf_users.unclip_text == num_users: return
        self.user_state = user_state
        self.link_state = link_state
        self.blf_users.unclip_text = num_users
        if num_users <= 9:
            self.blf_users.text = ""  if num_users == -1 else str(num_users)
        else:
            self.blf_users.text = "9+"


        blf_value = self.blf_value
        blf_value.unclip_text = v
        self.update_icon(ob)

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        self.blf_users.x = round(self.box_icon_duplicate.r_center_x_float() - blfDimen(FONT0, self.blf_users.text)[0] / 2)

        if self.init_bat == self.init_bat_anim_FULL:
            if hasattr(self, "r_button_width"):
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
            else:
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (D_SIZE['font_main_title_offset'] * 2 + round(blfDimen(FONT0, self.blf_title.unclip_text)[0])) - (
                D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] * 5)
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] * 5)
        #|
    #|
    #|
class BuCacheFile(BuTexture):
    __slots__ = ()

    def get_icon_cls_and_idtype(self):
        self.idtype = "CACHEFILE"
        self.icon_cls = GpuImg_ID_CACHEFILE
        #|

    @ catch
    def evt_new_item(self):
        def end_fn(s):
            try:
                caches = [e for e in bpy.data.cache_files]
                bpy.ops.cachefile.open(filepath=s)
                new_cac = next(e for e in bpy.data.cache_files  if e not in caches)

                new_cac.user_clear()
                self.set(new_cac, undo_push=False)
                update_scene_push("Import Cache File")
            except: pass

        OpScanFile.end_fn = end_fn
        bpy.ops.wm.vmd_scan_file("INVOKE_DEFAULT", filepath="", filter_glob="*.abc")
        #|
    #|
    #|
class BuNodeTree(BuTexture):
    __slots__ = ()

    def get_icon_cls_and_idtype(self):
        self.idtype = "NODETREE"
        self.icon_cls = GpuImg_ID_NODETREE
        #|

    @ catch
    def evt_new_item(self):

        kill_evt_except()
        pp = self.r_pp()
        self.pp = pp
        if not pp: return
        if self.isdark is True and self.isdarkhard is True: return
        if ui_poll_library(pp.id_data, True) is False: return

        self.set(add_empty_geometry_node_group())
        #|
    #|
    #|
class BuParticleSettings(BuTexture):
    __slots__ = ()

    def get_icon_cls_and_idtype(self):
        self.idtype = "PARTICLE"
        self.icon_cls = GpuImg_ID_PARTICLE
        #|

    @ catch
    def evt_new_item(self):

        kill_evt_except()
        #|
    def evt_remove(self):
        report("This property cannot be None")
        #|
    #|
    #|

class BuIDNoArrow(BuID):
    __slots__ = ()

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1 - D_SIZE['widget_full_h'] - widget_rim, B, TT, widget_rim)

        L9, R9, B9, T9 = self.box_button.inner

        blf_y = B9 + D_SIZE['font_main_dy']
        self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
        self.blf_value.y = blf_y

        e = self.blf_title
        e.y = blf_y
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'], R0)
        x = R0 - round(blfDimen(FONT0, e.text)[0])
        e.x = x

        x -= D_SIZE['font_main_title_offset']
        self.box_anim.LRBT_upd(x - SIZE_widget[0], x, B9, T9)

        L0 = L + widget_rim
        self.box_icon.LRBT_upd(L0, L0 + SIZE_widget[0], B9, T9)
        self.blf_value.x += SIZE_widget[0]
        return B
        #|

    def set_align(self, ty, r_offset_width=None):
        TODO
        #|

    def inside(self, mouse):
        if self.box_button.B <= mouse[1] < self.box_button.T:
            if self.box_anim.L <= mouse[0] < self.box_button.R: return True
        return False
        #|

    def dark(self):
        # <<< 1copy (0defuiStrDark,, $$)
        # <<< 1copy (0defuiDark,, ${'_box_val':'_box_text'}$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_text_ignore
        self.box_button.color_rim = COL_box_text_rim_ignore
        self.blf_value.color = COL_box_text_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        # >>>
        self.update_icon()
        #|
    def light(self):
        # <<< 1copy (0defuiStrLight,, $$)
        # <<< 1copy (0defuiLight,, ${'_box_val':'_box_text'}$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_text
        self.box_button.color_rim = COL_box_text_rim
        self.blf_value.color = COL_box_text_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        # >>>
        self.update_icon()
        #|

    def modal(self):
        if MOUSE[0] < self.box_anim.R:
            if self.focus_element != 3:

                self.is_trigger_anim_enable = True
                self.focus_element = 3
                Admin.REDRAW()
                self.focus_anim()

        elif self.box_button.L <= MOUSE[0] < self.box_button.R:
            if self.focus_element != 0:

                self.focus_element = 0
                Admin.REDRAW()
                self.focus_default()

        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>

        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True
        if TRIGGER['ui_jump_to_target']():
            self.evt_jump_to_target()
            return True
        if TRIGGER['ui_mark_asset']():
            self.evt_mark_asset()
            return True
        if TRIGGER['dd_preview']():
            self.evt_area_preview()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_dropdown()
                return True
            elif i == 1:
                ob = self.get()
                if ob:

                    self.set(None)
                    kill_evt_except()
                else:
                    if self.idtype == "OBJECT":
                        self.to_modal_picker()
                    else:
                        self.to_dropdown()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        #|

    def update_icon(self, ob=0):
        if ob == 0:
            name = self.blf_value.unclip_text
            idtype = self.idtype
        else:
            idtype = self.idtype
            # GOodIDtype
            if idtype in D_id_blendData and hasattr(bpy.data, D_id_blendData[idtype]): pass
            else:
                self.isdarkhard = True
                self.dark()

            if ob:
                newidtype = r_id_type(ob)
                if newidtype is not None:
                    self.idtype = newidtype

                name = ob.name
            else:
                name = ""

        if idtype == "OBJECT":
            if name:
                if self.isdark is True:
                    self.box_icon.__class__ = GpuImg_stop_dark
                else:
                    if self.fixed_idtype is True and isinstance(self.allow_types, set) and len(self.allow_types) == 1:
                        self.box_icon.__class__ = getattr(blg, f"GpuImg_OUTLINER_OB_{self.allow_types.copy().pop()}", GpuImg_ID_OBJECT)
                    else:
                        self.box_icon.__class__ = GpuImg_ID_OBJECT
            else:
                if self.isdark is True:
                    self.box_icon.__class__ = GpuImg_stop_dark
                else:
                    if self.fixed_idtype is True and isinstance(self.allow_types, set) and len(self.allow_types) == 1:
                        self.box_icon.__class__ = getattr(blg, f"GpuImg_OUTLINER_OB_{self.allow_types.copy().pop()}", GpuImg_ID_OBJECT)
                    else:
                        self.box_icon.__class__ = GpuImg_ID_OBJECT
        else:
            if self.isdark is True:
                self.box_icon.__class__ = GpuImg_stop_dark
            else:
                self.box_icon.__class__ = getattr(blg, f"GpuImg_ID_{idtype}", GpuImgNull)
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiStrDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        self.box_icon.dxy_upd(dx, dy)
        #|
    def i_draw_box(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        self.box_icon.bind_draw()
        #|
    def i_draw_box_anim(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        self.box_icon.bind_draw()
        self.box_hover.bind_draw()
        #|

    def focus_anim(self):
        self.draw_box = self.i_draw_box_anim
        if self.isdark is False:
            self.box_button.color = COL_box_text

            if self.box_anim.__class__ is GpuImgNull:
                self.box_hover = GpuImgNull()
            else:
                self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
                self.box_hover.upd()
                self.dxy = self.i_dxy_anim_hover
        else:
            self.box_hover = GpuImgNull()
        #|
    def focus_default(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text_fo
        #|
    def focus_empty(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text
        #|

    def upd_data(self):
        # <<< 1copy (0defuiIDUpdData,, ${
        #     'SIZE_border[3] + SIZE_widget[0]) * 2)': "SIZE_border[3] + SIZE_widget[0]) * 2 - D_SIZE['widget_full_h'] - SIZE_border[3])"
        # }$)
        self.upd_anim_button()
        ob = getattr(self.pp, self.identifier)
        if self.blf_value.unclip_text == (ob.name  if ob else ""): return


        blf_value = self.blf_value
        v = ob.name  if ob else ""
        blf_value.unclip_text = v
        self.update_icon(ob)

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if self.blf_title.unclip_text:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
            else:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (
                D_SIZE['font_main_dx'] + SIZE_border[3] + SIZE_widget[0]) * 2 - D_SIZE['widget_full_h'] - SIZE_border[3])
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3] + SIZE_widget[0]) * 2 - D_SIZE['widget_full_h'] - SIZE_border[3])
        # >>>
        #|
    #|
    #|

@ assign(
    set = c_set,
    init_bat_anim = c_init_bat_anim_BuEnumIcon,
    init_bat_anim_FULL = c_init_bat_anim_BuEnumIcon_FULL,
    init_bat_anim_title_offset_inv = c_init_bat_anim_title_offset_inv_BuEnumIcon,
    update_icon = c_upd_icon_StrSearch)
@ focusID
@ toNoAnim
class BuStrSearch(BuEnumIcon):
    __slots__ = 'pollred'

    def to_dropdown(self, killevt=True, select_all=None):


        return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name,
            items = self.enum_items(),
            get_icon = getattr(self, 'geticon', None),
            get_info = getattr(self, 'getinfo', None))
        #|

    def dark(self):
        # <<< 1copy (0defuiEnumDark,, $$)
        # <<< 1copy (0defuiStrDark,, $$)
        # <<< 1copy (0defuiDark,, ${'_box_val':'_box_text'}$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_text_ignore
        self.box_button.color_rim = COL_box_text_rim_ignore
        self.blf_value.color = COL_box_text_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        # >>>
        self.box_icon_arrow.set_draw_state(False)
        # >>>
        self.update_icon()
        #|
    def light(self):
        # <<< 1copy (0defuiEnumLight,, $$)
        # <<< 1copy (0defuiStrLight,, $$)
        # <<< 1copy (0defuiLight,, ${'_box_val':'_box_text'}$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_text
        self.box_button.color_rim = COL_box_text_rim
        self.blf_value.color = COL_box_text_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        # >>>
        self.box_icon_arrow.set_draw_state(True)
        # >>>
        self.update_icon()
        #|

    def modal(self):
        # <<< 1copy (0defuiModalID0,, $$)
        if self.box_anim.L <= MOUSE[0]:
            if self.focus_element != 3:

                self.is_trigger_anim_enable = True
                self.focus_element = 3
                Admin.REDRAW()
                self.focus_anim()

        elif MOUSE[0] < self.box_button.R:
            if self.box_icon_arrow.L <= MOUSE[0]:
                if self.focus_element != 1:

                    self.focus_element = 1
                    Admin.REDRAW()
                    self.focus_eye()

            else:
                if self.focus_element != 0:

                    self.focus_element = 0
                    Admin.REDRAW()
                    self.focus_default()

        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>
        # >>>
        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if hasattr(self, "evt_attr_toggle"):
            if TRIGGER['ui_attr_toggle']():
                self.evt_attr_toggle()
                return True
        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_dropdown()
                return True
            elif i == 1:
                s = self.get()
                if s:
                    self.set("")
                    kill_evt_except()
                else:
                    self.to_dropdown()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        #|

    def upd_data(self):
        # <<< 1copy (0defuiStrUpdData,, ${
        #     ')#_REF_': ' - SIZE_widget[0] * 2)'
        # }$)
        self.upd_anim_button()
        if self.blf_value.unclip_text == getattr(self.pp, self.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.identifier)
        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if self.blf_title.unclip_text:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
            else:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (
                D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] * 2)
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] * 2)
        # >>>

        self.update_icon(v)
        #|
    #|
    #|

class BuStrSearchNoArrow(BuStrSearch):
    __slots__ = ()

    def init_bat_anim(self, LL, RR, TT):
        # 0blockBuEnumInitBatAnim
        h = SIZE_widget[0]
        widget_rim = SIZE_border[3]
        R1 = RR - h - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1 - D_SIZE['widget_full_h'] - widget_rim, B, TT, widget_rim)

        L9, R9, B9, T9 = self.box_button.inner

        blf_y = B9 + D_SIZE['font_main_dy']
        self.blf_value.x = L + widget_rim + D_SIZE['font_main_dx']
        self.blf_value.y = blf_y

        e = self.blf_title
        e.y = blf_y
        R0 = L - D_SIZE['font_main_title_offset']
        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        e.text = r_blf_clipping_end(e.unclip_text, LL + D_SIZE['font_main_dx'] + h + D_SIZE['font_main_title_offset'], R0)
        x = R0 - round(blfDimen(FONT0, e.text)[0])
        e.x = x

        x -= D_SIZE['font_main_title_offset']
        self.box_anim.LRBT_upd(x - h, x, B9, T9)

        L0 = L + widget_rim
        self.box_icon.LRBT_upd(L0, L0 + h, B9, T9)
        if self.box_icon.__class__ is GpuImgNull: pass
        else:
            self.blf_value.x += h
        return B
        #|

    def set_align(self, ty, r_offset_width=None):
        TODO
        #|

    def inside(self, mouse):
        if self.box_button.B <= mouse[1] < self.box_button.T:
            if self.box_anim.L <= mouse[0] < self.box_button.R: return True
        return False
        #|

    def dark(self):
        # <<< 1copy (0defuiStrDark,, $$)
        # <<< 1copy (0defuiDark,, ${'_box_val':'_box_text'}$)
        self.isdark = True
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button_dark
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov_dark

        self.box_button.color = COL_box_text_ignore
        self.box_button.color_rim = COL_box_text_rim_ignore
        self.blf_value.color = COL_box_text_fg_ignore
        self.blf_title.color = COL_block_fg_ignore
        Admin.REDRAW()
        # >>>
        # >>>
        self.update_icon()
        #|
    def light(self):
        # <<< 1copy (0defuiStrLight,, $$)
        # <<< 1copy (0defuiLight,, ${'_box_val':'_box_text'}$)
        self.isdark = False
        if self.overridden_state == 0:
            self.upd_anim_button = self.i_upd_anim_button
        else:
            self.upd_anim_button = self.i_upd_anim_button_ov

        self.box_button.color = COL_box_text
        self.box_button.color_rim = COL_box_text_rim
        self.blf_value.color = COL_box_text_fg
        self.blf_title.color = COL_block_fg
        Admin.REDRAW()
        # >>>
        # >>>
        self.update_icon()
        #|

    def modal(self):
        if MOUSE[0] < self.box_anim.R:
            if self.focus_element != 3:

                self.is_trigger_anim_enable = True
                self.focus_element = 3
                Admin.REDRAW()
                self.focus_anim()

        elif self.box_button.L <= MOUSE[0] < self.box_button.R:
            if self.focus_element != 0:

                self.focus_element = 0
                Admin.REDRAW()
                self.focus_default()

        else:
            if self.focus_element != -1:

                self.focus_element = -1
                Admin.REDRAW()
                self.focus_empty()

        # <<< 1copy (0defuiCheckTrigger,, $$)
        if self.is_trigger_anim_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        elif EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
            self.is_trigger_anim_enable = True
        # >>>

        # <<< 1copy (0defuiModalTriggerStr,, $$)
        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['dd_cut']():
            self.evt_area_cut()
            return True
        if TRIGGER['dd_paste']():
            self.evt_area_paste(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['dd_copy']():
            self.evt_area_copy(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_reset_all']():
            self.evt_area_reset_all()
            return True
        if TRIGGER['valbox_reset_single']():
            self.evt_area_reset_single(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['valbox_dd']():
            self.to_dropdown()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if TRIGGER['ui_format_toggle']():
            self.evt_area_format()
            return True
        # >>>
        # <<< 1copy (0defuiModalTriggerAnim,, $$)
        if TRIGGER['ui_remove_from_keying_set_all']():
            self.evt_remove_from_keying_set(index=-1)
            return True
        if TRIGGER['ui_add_to_keying_set_all']():
            self.evt_add_to_keying_set(index=-1)
            return True
        if TRIGGER['ui_remove_from_keying_set']():
            self.evt_remove_from_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_to_keying_set']():
            self.evt_add_to_keying_set(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_full_data_path']():
            self.evt_copy_full_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_copy_data_path']():
            self.evt_copy_data_path(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_paste_full_data_path_as_driver']():
            self.evt_paste_full_data_path_as_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_driver']():
            self.evt_delete_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_add_driver']():
            self.evt_add_driver(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None, use_editor=True)
            return True
        if TRIGGER['ui_clear_keyframe']():
            self.evt_clear_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_delete_keyframe']():
            self.evt_delete_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        if TRIGGER['ui_insert_keyframe']():
            self.evt_insert_keyframe(index=self.focus_element[0]  if isinstance(self.focus_element, tuple) else None)
            return True
        # >>>

        if TRIGGER['ui_batch']():
            self.evt_batch()
            return True

        if TRIGGER['click']():
            if self.isdark is True and self.isdarkhard is True: return True
            i = self.focus_element
            if i == 0:
                self.to_dropdown()
                return True
            elif i == 1:
                s = self.get()
                if s:
                    self.set("")
                    kill_evt_except()
                else:
                    self.to_dropdown()
                return True
            elif i == 3:
                # <<< 1copy (0defuiClickAnim,, $$)
                if self.is_trigger_anim_enable is True:
                    self.is_trigger_anim_enable = False
                    if is_first_press('click') == False:
                        boo = self.box_anim.__class__ in S_icon_keyframe_true
                        if _last_bool_state[0] != boo:
                            self.bufn_keyframe()
                    else:
                        self.bufn_keyframe()
                        _last_bool_state[0] = self.box_anim.__class__ in S_icon_keyframe_true
                return True
                # >>>
        return False
        #|

    def update_icon(self, ob=""):
        if self.pollred is True and self.isdark is False:
            enumitems = self.enum_items()
            s = self.blf_value.unclip_text
            if hasattr(enumitems, "foreach_get"):
                self.blf_value.color = COL_box_text_fg  if s in enumitems else COL_box_val_fg_error
            elif hasattr(enumitems, "__getitem__"):
                self.blf_value.color = COL_box_text_fg  if any(e.name == s  for e in enumitems) else COL_box_val_fg_error

        if self.blf_value.unclip_text:
            if self.isdark is True:
                self.box_icon.__class__ = GpuImg_stop_dark
            else:
                self.box_icon.__class__ = self.box_icon_cls
        else:
            if self.isdark is True:
                self.box_icon.__class__ = GpuImg_stop_dark
            else:
                self.box_icon.__class__ = self.box_icon_cls
        #|

    def i_dxy(self, dx, dy):
        # <<< 1copy (0defuiStrDxy,, $$)
        self.box_button.dxy_upd(dx, dy)
        self.box_anim.dxy_upd(dx, dy)

        self.blf_value.x += dx
        self.blf_value.y += dy
        self.blf_title.x += dx
        self.blf_title.y += dy
        # >>>
        self.box_icon.dxy_upd(dx, dy)
        #|
    def i_draw_box(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        self.box_icon.bind_draw()
        #|
    def i_draw_box_anim(self):
        # <<< 1copy (0defuiDrawbox,, $$)
        self.box_button.bind_draw()
        self.box_anim.bind_draw()
        # >>>
        self.box_icon.bind_draw()
        self.box_hover.bind_draw()
        #|

    def focus_anim(self):
        self.draw_box = self.i_draw_box_anim
        if self.isdark is False:
            self.box_button.color = COL_box_text

            if self.box_anim.__class__ is GpuImgNull:
                self.box_hover = GpuImgNull()
            else:
                self.box_hover = GpuImg_area_icon_hover(*self.box_anim.r_LRBT())
                self.box_hover.upd()
                self.dxy = self.i_dxy_anim_hover
        else:
            self.box_hover = GpuImgNull()
        #|
    def focus_default(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text_fo
        #|
    def focus_empty(self):
        self.draw_box = self.i_draw_box
        self.dxy = self.i_dxy
        if self.isdark is False:
            self.box_button.color = COL_box_text
        #|

    def upd_data(self):
        # <<< 1copy (0defuiStrUpdData,, ${
        #     ')#_REF_': " - SIZE_widget[0] - D_SIZE['widget_full_h'] - SIZE_border[3])"
        # }$)
        self.upd_anim_button()
        if self.blf_value.unclip_text == getattr(self.pp, self.identifier): return


        blf_value = self.blf_value
        v = getattr(self.pp, self.identifier)
        blf_value.unclip_text = v

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>

        if self.init_bat == self.init_bat_anim_FULL:
            if self.blf_title.unclip_text:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
            else:
                if hasattr(self, "r_button_width"):
                    if self.r_button_width.__defaults__ is None:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                    else:
                        button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

            blf_value.text = r_blf_clipping_end_with(v, button_width - (
                D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] - D_SIZE['widget_full_h'] - SIZE_border[3])
        else:
            blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
                ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] - D_SIZE['widget_full_h'] - SIZE_border[3])
        # >>>

        self.update_icon(v)
        #|
    #|
    #|


@ assign(
    r_height = c_r_height_int)
class BuFunction:
    __slots__ = (
        'w',
        'rna',
        'fn',
        'box_button',
        'blf_value',
        'is_trigger_enable',
        'is_repeat',
        'isdark',
        'isdarkhard',
        'isdarkhard_prev',
        'r_button_width',
        'init_bat')

    def __init__(self, w, rna, fn, isdarkhard):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = GpuButton()
        self.blf_value = BlfClipColor("", rna.default, 0, 0, COL_box_button_fg)
        #|

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        L = R1 - (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        d = D_SIZE['font_main_dx'] + widget_rim
        blf_value = self.blf_value
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text, d, R1 - L - d)

        blf_value.x = floor((R1 + L - blfDimen(FONT0, blf_value.text)[0]) / 2)
        blf_value.y = B + widget_rim + D_SIZE['font_main_dy']
        return B
        #|
    def init_bat_L(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        L = LL + widget_rim
        R1 = L + (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])

        B = TT - D_SIZE['widget_full_h']
        self.box_button.LRBT_upd(L, R1, B, TT, widget_rim)

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        d = D_SIZE['font_main_dx'] + widget_rim
        blf_value = self.blf_value
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text, d, R1 - L - d)

        blf_value.x = floor((R1 + L - blfDimen(FONT0, blf_value.text)[0]) / 2)
        blf_value.y = B + widget_rim + D_SIZE['font_main_dy']
        return B
        #|

    def r_height(self, width): return D_SIZE['widget_full_h']
    def set_button_text(self, s):
        e = self.box_button
        L = e.L
        R = e.R
        B = e.B
        self.blf_value.unclip_text = self.blf_value.text = s
        blfSize(FONT0, D_SIZE['font_main'])
        self.blf_value.x = floor((R + L - blfDimen(FONT0, s)[0]) / 2)
        self.blf_value.y = B + SIZE_border[3] + D_SIZE['font_main_dy']
        #|
    def set_ui_state_link(self):
        self.isdarkhard = True
        self.dark()
        #|
    def set_ui_state_default(self):
        self.isdarkhard = self.isdarkhard_prev
        self.light()
        #|

    def dark(self):
        self.isdark = True
        self.box_button.dark()
        self.blf_value.color = COL_box_button_fg_ignore
        #|
    def light(self):
        self.isdark = False
        self.box_button.light()
        self.blf_value.color = COL_box_button_fg
        #|

    def inside(self, mouse): return self.box_button.inbox(mouse)
    def inside_evt(self):
        Admin.REDRAW()
        self.box_button.set_state_focus()
        self.is_trigger_enable = True
        #|
    def outside_evt(self):
        if self.is_repeat:
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
        Admin.REDRAW()
        self.box_button.set_state_default()
        #|

    def modal(self):
        if self.is_trigger_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        else:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                if self.is_repeat:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                self.is_trigger_enable = True
                if self.isdark is False:
                    self.box_button.set_state_focus()
                Admin.REDRAW()

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if self.is_trigger_enable is True:
            if TRIGGER['click']():
                if is_first_press('click') == False: return False
                if self.isdark is True and self.isdarkhard is True: return True
                Admin.REDRAW()
                self.is_trigger_enable = False
                self.box_button.set_state_press()
                self.fn()  if self.fn.__defaults__ is None else self.fn(self)
                if self.is_repeat: self.reg_repeat_timer()
                return True
        return False
        #|

    def to_modal_rm(self):

        kill_evt_except()
        if not self.rna: return

        items = [("detail", self.evt_area_detail)]
        append_rm_item_operator(items, self.rna)

        DropDownRMKeymap(self, MOUSE, items, title=self.rna.name)
        #|
    def evt_area_detail(self):

        kill_evt_except()
        if not self.rna: return
        Detail(Detail.r_rna_info(self.rna))
        #|

    def reg_repeat_timer(self):
        global _timer_button_fn
        _timer_button_fn = self.fn

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    def dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        self.blf_value.x += dx
        self.blf_value.y += dy
        #|
    def draw_box(self):
        self.box_button.bind_draw()
        #|
    def draw_blf(self):
        e = self.blf_value
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, e.y, 0)
        blfDraw(FONT0, e.text)
        #|

    def upd_data(self): pass
    #|
    #|
class BuFunction2(BuFunction):
    __slots__ = 'focus_element'

    def __init__(self, w, rna, fn, isdarkhard):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = [GpuButton(), GpuButton()]
        self.blf_value = [
            BlfClipColor("", rna[0].default, 0, 0, COL_box_button_fg),
            BlfClipColor("", rna[1].default, 0, 0, COL_box_button_fg)
        ]
        #|

    def init_bat_anim(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        widget_width = (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])
        L = R1 - widget_width

        B = TT - D_SIZE['widget_full_h']
        self.box_button[1].LRBT_upd(L, R1, B, TT, widget_rim)

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        d = D_SIZE['font_main_dx'] + widget_rim
        blf_value = self.blf_value[1]
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text, d, R1 - L - d)

        blf_value.x = floor((R1 + L - blfDimen(FONT0, blf_value.text)[0]) / 2)

        R1 = L - widget_rim
        L = R1 - widget_width
        self.box_button[0].LRBT_upd(L, R1, B, TT, widget_rim)

        blf_value = self.blf_value[0]
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text, d, R1 - L - d)

        blf_value.x = floor((R1 + L - blfDimen(FONT0, blf_value.text)[0]) / 2)
        blf_value.y = B + widget_rim + D_SIZE['font_main_dy']
        return B
        #|
    def init_bat_anim_half(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        R2 = RR - SIZE_widget[0]
        R1 = R2 - widget_rim
        widget_width = (self.r_button_width() if hasattr(self, "r_button_width") else D_SIZE['widget_width'])
        widget_width_half = (widget_width - widget_rim) // 2
        L = R1 - widget_width_half

        B = TT - D_SIZE['widget_full_h']
        self.box_button[1].LRBT_upd(L, R1, B, TT, widget_rim)

        # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
        blfSize(FONT0, D_SIZE['font_main'])
        blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
        # >>>
        d = D_SIZE['font_main_dx'] + widget_rim
        blf_value = self.blf_value[1]
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text, d, R1 - L - d)

        blf_value.x = floor((R1 + L - blfDimen(FONT0, blf_value.text)[0]) / 2)

        L0 = R1 - widget_width
        R1 = L - widget_rim
        L = L0
        self.box_button[0].LRBT_upd(L, R1, B, TT, widget_rim)

        blf_value = self.blf_value[0]
        blf_value.text = r_blf_clipping_end(blf_value.unclip_text, d, R1 - L - d)

        blf_value.x = floor((R1 + L - blfDimen(FONT0, blf_value.text)[0]) / 2)
        blf_value.y = B + widget_rim + D_SIZE['font_main_dy']
        return B
        #|
    def init_bat_L(self, LL, RR, TT): TODO

    def set_button_text(self, s, index):
        e = self.box_button[index]
        o = self.blf_value[index]
        L = e.L
        R = e.R
        B = e.B
        o.unclip_text = o.text = s
        blfSize(FONT0, D_SIZE['font_main'])
        o.x = floor((R + L - blfDimen(FONT0, o.text)[0]) / 2)
        o.y = B + SIZE_border[3] + D_SIZE['font_main_dy']
        #|

    def dark(self, index=None):
        if index is None:
            self.isdark = True
            self.box_button[0].dark()
            self.blf_value[0].color = COL_box_button_fg_ignore
            self.box_button[1].dark()
            self.blf_value[1].color = COL_box_button_fg_ignore
        else:
            if self.isdark is True: pass
            elif self.isdark is False:
                self.isdark = 1 << index
            else:
                self.isdark |= 1 << index
                if self.isdark == 0:
                    self.isdark = False
                elif self.isdark == 3:
                    self.isdark = True

            self.box_button[index].dark()
            self.blf_value[index].color = COL_box_button_fg_ignore
        #|
    def light(self, index=None):
        if index is None:
            self.isdark = False
            self.box_button[0].light()
            self.blf_value[0].color = COL_box_button_fg
            self.box_button[1].light()
            self.blf_value[1].color = COL_box_button_fg
        else:
            if self.isdark is True:
                self.isdark = 3 ^ 1 << index
            elif self.isdark is False: pass
            else:
                self.isdark &= ~ (1 << index)
                if self.isdark == 0:
                    self.isdark = False
                elif self.isdark == 3:
                    self.isdark = True

            self.box_button[index].light()
            self.blf_value[index].color = COL_box_button_fg
        #|

    def inside(self, mouse):
        if self.box_button[0].B <= mouse[1] < self.box_button[0].T:
            if self.box_button[0].L <= mouse[0] < self.box_button[0].R: return True
            if self.box_button[1].L <= mouse[0] < self.box_button[1].R: return True
        return False
        #|
    def inside_evt(self):
        Admin.REDRAW()
        self.is_trigger_enable = True
        self.focus_element = -1
        #|
    def outside_evt(self):
        if self.is_repeat:
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
        Admin.REDRAW()
        self.box_button[0].set_state_default()
        self.box_button[1].set_state_default()
        #|

    def modal(self):
        if self.is_trigger_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        else:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                if self.is_repeat:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                self.is_trigger_enable = True
                self.focus_element = -1
                Admin.REDRAW()

        if self.box_button[0].L <= MOUSE[0] < self.box_button[0].R:
            if self.focus_element != 0:
                self.focus_element = 0
                self.is_trigger_enable = True

                if self.isdark in {False, 2}:
                    self.box_button[0].set_state_focus()
                self.box_button[1].set_state_default()
                Admin.REDRAW()

        elif self.box_button[1].L <= MOUSE[0] < self.box_button[1].R:
            if self.focus_element != 1:
                self.focus_element = 1
                self.is_trigger_enable = True

                if self.isdark in {False, 1}:
                    self.box_button[1].set_state_focus()
                self.box_button[0].set_state_default()
                Admin.REDRAW()

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True

        if self.is_trigger_enable is True:
            if TRIGGER['click']():
                if is_first_press('click') == False: return False
                if self.isdark is True and self.isdarkhard is True: return True
                self.is_trigger_enable = False

                if self.focus_element in {0, 1}:
                    if self.isdark is False: pass
                    elif self.isdarkhard is True:
                        if self.isdark == self.isdark & 1 << self.focus_element: return True
                    Admin.REDRAW()
                    index = self.focus_element
                    self.box_button[index].set_state_press()
                    self.fn[index]()  if self.fn[index].__defaults__ is None else self.fn[index](self)
                    if self.is_repeat: self.reg_repeat_timer()

                return True
        return False
        #|

    def to_modal_rm(self):

        kill_evt_except()
        index = self.focus_element
        if index not in {0, 1}: return

        items = [("detail", self.evt_area_detail)]
        append_rm_item_operator(items, self.rna[index])

        DropDownRMKeymap(self, MOUSE, items, title=self.rna[index].name)
        #|
    def evt_area_detail(self):

        kill_evt_except()
        index = self.focus_element
        if index not in {0, 1}: return

        Detail(Detail.r_rna_info(self.rna[index]))
        #|

    def dxy(self, dx, dy):
        self.box_button[0].dxy_upd(dx, dy)
        self.box_button[1].dxy_upd(dx, dy)
        self.blf_value[0].x += dx
        self.blf_value[0].y += dy
        self.blf_value[1].x += dx
        #|
    def draw_box(self):
        self.box_button[0].bind_draw()
        self.box_button[1].bind_draw()
        #|
    def draw_blf(self):
        e = self.blf_value[0]
        y = e.y
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, y, 0)
        blfDraw(FONT0, e.text)

        e = self.blf_value[1]
        blfColor(FONT0, *e.color)
        blfPos(FONT0, e.x, y, 0)
        blfDraw(FONT0, e.text)
        #|

    def reg_repeat_timer(self): pass
    #|
    #|

@ assign(
    r_height = c_r_height_vec)
class BuLabels:
    __slots__ = (
        'w',
        'blf_label',
        'array_length',
        'text_color',
        'r_button_width')

    def __init__(self, w, lines, text_color):
        self.w = w
        self.blf_label = [Blf(s)  for s in lines]
        self.blf_label[0].color = text_color
        self.text_color = text_color
        self.array_length = len(lines)
        #|

    def init_bat(self, LL, RR, TT):
        h = SIZE_widget[0]

        if hasattr(self, "r_button_width"):
            self.blf_label[0].x = LL + D_SIZE['font_main_title_offset'] + self.r_button_width()
        else:
            self.blf_label[0].x = LL + D_SIZE['font_main_title_offset']

        blf_y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        for e in self.blf_label:
            e.y = blf_y
            blf_y -= h

        return TT - D_SIZE['widget_full_h'] - (self.array_length - 1) * h
        #|

    def dark(self):
        self.blf_label[0].color = COL_block_fg_ignore
        #|
    def light(self):
        self.blf_label[0].color = self.text_color
        #|

    def inside(self, mouse): return False
    def inside_evt(self): pass
    def outside_evt(self): pass

    def modal(self): return False

    def dxy(self, dx, dy):
        self.blf_label[0].x += dx
        for e in self.blf_label:
            e.y += dy
        #|

    def draw_box(self): pass
    def draw_blf(self):
        e = self.blf_label[0]
        x = e.x
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *e.color)

        for e in self.blf_label:
            blfPos(FONT0, x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def upd_data(self): pass
    #|
    #|
class BuLabelsR(BuLabels):
    __slots__ = ()

    def init_bat(self, LL, RR, TT):
        h = SIZE_widget[0]

        if hasattr(self, "r_button_width"):
            R0 = RR - D_SIZE['font_main_title_offset'] - self.r_button_width()
        else:
            R0 = RR - D_SIZE['font_main_title_offset']

        blfSize(FONT0, D_SIZE['font_main'])
        blf_y = TT - SIZE_border[3] - D_SIZE['font_main_dT']
        for e in self.blf_label:
            e.x = R0 - round(blfDimen(FONT0, e.text)[0])
            e.y = blf_y
            blf_y -= h

        return TT - D_SIZE['widget_full_h'] - (self.array_length - 1) * h
        #|

    def dxy(self, dx, dy):
        for e in self.blf_label:
            e.x += dx
            e.y += dy
        #|

    def draw_blf(self):
        blfSize(FONT0, D_SIZE['font_main'])
        blfColor(FONT0, *self.blf_label[0].color)

        for e in self.blf_label:
            blfPos(FONT0, e.x, e.y, 0)
            blfDraw(FONT0, e.text)
        #|

    def set_text_with(self, s, index=0):
        blfSize(FONT0, D_SIZE['font_main'])
        e = self.blf_label[index]
        R0 = e.x + round(blfDimen(FONT0, e.text)[0])
        e.text = s
        e.x = R0 - round(blfDimen(FONT0, s)[0])
        #|
    def set_text(self, s, index=0):
        e = self.blf_label[index]
        R0 = e.x + round(blfDimen(FONT0, e.text)[0])
        e.text = s
        e.x = R0 - round(blfDimen(FONT0, s)[0])
        #|
    #|
    #|

@ assign(
    r_height = c_r_height_int)
class BuFnImgHover:
    __slots__ = (
        'w',
        'rna',
        'fn',
        'box_button',
        'is_trigger_enable',
        'is_repeat',
        'isdark',
        'isdarkhard',
        'isdarkhard_prev',
        'focus_element',
        'box_hover',
        'icon_cls',
        'icon_cls_dark',
        'inside',
        'dxy',
        'draw_box',
        'init_bat',
        'r_button_width')

    def __init__(self, w, rna, fn, isdarkhard, icon_cls, icon_cls_dark):
        self.w = w
        self.rna = rna
        self.fn = fn
        self.icon_cls = icon_cls
        self.icon_cls_dark = icon_cls_dark
        self.isdark = False
        self.isdarkhard = isdarkhard
        self.isdarkhard_prev = isdarkhard
        self.is_repeat = True  if hasattr(rna, "is_repeat") and rna.is_repeat else False
        self.box_button = icon_cls()
        self.inside = self.box_button.inbox
        self.draw_box = self.box_button.bind_draw
        self.dxy = self.box_button.dxy_upd
        #|

    def r_B(self): return self.box_button.B - SIZE_border[3]
    def r_T(self): return self.box_button.T + SIZE_border[3]

    def init_bat_L(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        if hasattr(self, "r_button_width"):
            LL += widget_rim + widget_rim + self.r_button_width()
        else:
            LL += widget_rim + widget_rim

        T = TT - widget_rim
        self.box_button.LRBT_upd(LL, LL + SIZE_widget[0], T - SIZE_widget[0], T)
        return TT - D_SIZE['widget_full_h']
        #|
    def init_bat_R(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        if hasattr(self, "r_button_width"):
            RR -= widget_rim + widget_rim + self.r_button_width()
        else:
            RR -= widget_rim + widget_rim

        T = TT - widget_rim
        self.box_button.LRBT_upd(RR - SIZE_widget[0], RR, T - SIZE_widget[0], T)
        return TT - D_SIZE['widget_full_h']
        #|

    def set_align(self, ty, r_offset_width=None):
        if ty == "R":
            self.init_bat = self.init_bat_R

        if r_offset_width is None: return

        self.r_button_width = r_offset_width
        #|

    def dark(self):
        self.box_button.__class__ = self.icon_cls
        Admin.REDRAW()
        #|
    def light(self):
        self.box_button.__class__ = self.icon_cls_dark
        Admin.REDRAW()
        #|

    def inside_evt(self):
        Admin.REDRAW()
        self.box_hover = GpuImg_area_icon_hover(*self.box_button.r_LRBT())
        self.box_hover.upd()
        self.is_trigger_enable = True
        self.draw_box = self.i_draw_box_hover
        self.dxy = self.i_dxy_hover
        self.focus_element = 0
        #|
    def outside_evt(self):
        if self.is_repeat:
            # <<< 1copy (0block_unreg_timer_button_safe,, $$)
            if timer_isreg(timer_button):
                timer_unreg(timer_button)

            # >>>
            # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
            if timer_isreg(timer_hold):
                timer_unreg(timer_hold)

            # >>>
        Admin.REDRAW()
        self.draw_box = self.box_button.bind_draw
        self.dxy = self.box_button.dxy_upd
        self.focus_element = -1
        #|

    def modal(self):
        if self.focus_element != 0:
            self.focus_element = 0
            self.box_hover.LRBT_upd(*self.box_button.r_LRBT())
            Admin.REDRAW()

        if self.is_trigger_enable is True: pass
        elif EVT_TYPE[0] == "TIMER_REPORT": pass
        else:
            if EVT_TYPE[1] == 'RELEASE' or (EVT_TYPE[1] == 'NOTHING' and Admin.EVT.value_prev == 'RELEASE'):
                if self.is_repeat:
                    # <<< 1copy (0block_unreg_timer_button_safe,, $$)
                    if timer_isreg(timer_button):
                        timer_unreg(timer_button)

                    # >>>
                    # <<< 1copy (0block_unreg_timer_hold_safe,, $$)
                    if timer_isreg(timer_hold):
                        timer_unreg(timer_hold)

                    # >>>
                self.is_trigger_enable = True
                # self.box_button.set_state_focus()
                Admin.REDRAW()

        if TRIGGER['rm']():
            self.to_modal_rm()
            return True
        if TRIGGER['detail']():
            self.evt_area_detail()
            return True
        if self.is_trigger_enable is True:
            if TRIGGER['click']():
                if is_first_press('click') == False: return False
                if self.isdark is True and self.isdarkhard is True: return True
                Admin.REDRAW()
                self.box_hover.LRBT_upd(0, 0, 0, 0)
                self.focus_element = -1
                self.is_trigger_enable = False
                self.fn()  if self.fn.__defaults__ is None else self.fn(self)
                if self.is_repeat: self.reg_repeat_timer()
                return True
        return False
        #|

    def to_modal_rm(self):

        kill_evt_except()
        if self.rna == None: return

        items = [
            ("detail", self.evt_area_detail),
        ]

        append_rm_item_operator(items, self.rna)

        DropDownRMKeymap(self, MOUSE, items, title=self.rna.name)
        #|

    def evt_area_detail(self):

        kill_evt_except()
        if self.rna == None: return
        Detail(Detail.r_rna_info(self.rna))
        #|

    def reg_repeat_timer(self):
        global _timer_button_fn
        _timer_button_fn = self.fn

        _timer_button_fn()
        # <<< 1copy (0block_reg_timer_hold_safe,, $$)
        if timer_isreg(timer_hold) == False:
            timer_reg(timer_hold, first_interval=P.button_repeat_time)

        # >>>
        #|

    def i_dxy_hover(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)
        if hasattr(self, "focus_element"):
            if self.focus_element != -1:
                self.focus_element = -1
                self.box_hover.LRBT_upd(0, 0, 0, 0)
        #|
    def i_draw_box_hover(self):
        self.box_hover.bind_draw()
        self.box_button.bind_draw()
        #|
    def draw_blf(self): pass
    def upd_data(self): pass
    #|
    #|

@ assign(
    set_ui_state_overridden = c_pass,
    set_ui_state_link = c_pass,
    set_ui_state_default = c_pass,
    dark_anim = c_pass,
    get = c_get,
    r_default_value = c_r_default_value)
class BuStrXYRead__TODO(BuValueSlots):
    __slots__ = 'column_len'

    def __init__(self, w, rna, r_pp, ui_anim_data, column_len):
        self.isdark = False
        self.isdarkhard = False
        self.isdarkhard_prev = False
        self.overridden_state = 0
        self.w = w
        self.rna = rna
        self.identifier = rna.identifier
        self.r_pp = r_pp
        self.pp = r_pp()
        self.ui_anim_data = ui_anim_data
        self.column_len = column_len

        # self.box_button = GpuRim(COL_box_text, COL_box_text_rim)
        self.box_button = GpuRim(COL_box_text_read, COL_box_text_read_rim)

        self.blf_value = []

        self.draw_blf = self.i_draw_blf
        self.dxy = self.i_dxy

        self.draw_box = self.i_draw_box
        self.upd_anim_button = N1
        #|

    def init_bat(self, LL, RR, TT):
        widget_rim = SIZE_border[3]
        h = SIZE_widget[0]
        B = TT - D_SIZE['widget_full_h'] - (self.column_len - 1) * h
        self.box_button.LRBT_upd(LL, RR, B, TT, widget_rim)

        y = self.box_button.inner[3] - widget_rim - D_SIZE['font_main_dT']
        for e in self.blf_value:
            e.y = y
            y -= h
        #|

    def r_height(self, width): return D_SIZE['widget_full_h'] + (self.column_len - 1) * SIZE_widget[0]

    def dark(self): pass
    def light(self): pass

    def modal(self): pass

    def i_dxy(self, dx, dy):
        self.box_button.dxy_upd(dx, dy)

        for e in self.blf_value:
            e.x += dx
            e.y += dy
        #|
    #|
    #|


D_riches = {
    "TEXTURE": BuTexture,
    "CACHEFILE": BuCacheFile,
    "NODETREE": BuNodeTree,
    "PARTICLE": BuParticleSettings}

#_c4#_c4#_c4#_c4
def update_scene_gn(pp):
    bpy.context.scene.update_tag()
    P.refresh = True
    try:
        pp.id_data.data.update()
    except: pass
    #|
def geticon_obj_attr(e):
    if hasattr(e, "domain"):
        return D_geticon_domain.get(e.domain, GpuImgNull)()
    if hasattr(e, "lock_weight"):
        return GpuImg_POINT()
    return GpuImgNull()
def getinfo_obj_attr(e):
    if hasattr(e, "data_type"):
        if e.data_type in data_type_enum_items:
            return data_type_enum_items[e.data_type].name
        return e.data_type
    if hasattr(e, "lock_weight"):
        return "Float"
    return ""

def c_getGn(self):
    return self.pp[self.identifier]
    #|
def c_setGn(self, v, refresh=True, undo_push=True):
    # <<< 1copy (0defuiSet,, ${
    #     'setattr(self.pp, self.identifier, v)': 'self.pp[self.identifier] = v',
    #     'getattr(self.pp, self.identifier)': 'self.pp[self.identifier]',
    #     'update_data()': 'update_scene_gn(self.r_pp())'
    # }$)
    # <<< 1copy (0defuiSetDriverEval,, $$)
    if isinstance(v, str):
        # v = v.strip()
        if v.startswith("#"):
            v = v[1 : ]
            if v.startswith("#"): pass
            else:
                self.evt_add_driver(exp=v, replace=True)
                return
        elif v.startswith(";"):
            v = v[1 : ]
            if v.startswith(";"): pass
            else:
                v = bpyeval(v)
    # >>>

    self.pp[self.identifier] = v

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_scene_gn(self.r_pp())

    if undo_push:
        ed_undo_push(message=f'{self.rna.name} : {self.pp[self.identifier]}')
    # >>>
    #|
def c_setGn_vec(self, v, index, refresh=True, undo_push=True):
    # <<< 1copy (0defuiSetvec,, ${
    #     'getattr(self.pp, self.identifier)': 'self.pp[self.identifier]',
    #     'update_data()': 'update_scene_gn(self.r_pp())'
    # }$)
    if isinstance(index, int):
        if isinstance(v, str):
            v = v.strip()
            if v.startswith("#"):
                self.evt_add_driver(index=index, exp=v[1 :], replace=True)
                return
            elif v.startswith(";"):
                v = v[1 : ]
                if v.startswith(";"): pass
                else:
                    v = bpyeval(v)
    else:
        if isinstance(v[0], str) and v[0].startswith("#"):
            i = index[0]
            for v in v:
                self.evt_add_driver(index=i, exp=v[1 :], replace=True)
                i += 1
            return

    array = self.pp[self.identifier]

    if isinstance(index, int): array[index] = v
    else:
        l = list(array)
        l[index[0] : index[1]] = v
        array[:] = l
        # crash when array is EULER
        # array[index[0] : index[1]] = v

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_scene_gn(self.r_pp())

    if undo_push:
        s = ", ".join(f"{v:.4f}"  for v in self.pp[self.identifier])
        ed_undo_push(message=f'{self.rna.name} : {s}')
    # >>>
    #|
def c_setGn_ID(self, v, refresh=True, undo_push=True):
    # <<< 1copy (0defuiSetID,, ${
    #     'setattr(self.pp, self.identifier, v)': 'self.pp[self.identifier] = v',
    #     'getattr(self.pp, self.identifier)': 'self.pp[self.identifier]',
    #     'update_data()': 'update_scene_gn(self.r_pp())'
    # }$)
    if isinstance(v, str):
        if self.idtype in D_id_blendData: pass
        else: return

        datas = getattr(bpy.data, D_id_blendData[self.idtype])
        if v:
            if v.startswith(";;"):
                v = v[1 :]
                if v in datas: v = datas[v]
                else:
                    if refresh: report("Object not found")
                    return
            elif v.startswith(";"):
                try: v = bpyeval(v[1 :])
                except:
                    if refresh: report("Eval failed")
                    return
            else:
                if v in datas: v = datas[v]
                else:
                    if refresh: report("Object not found")
                    return
        else:
            v = None

    try:
        if self.r_except_objects is not None and v in self.r_except_objects():
            if refresh: report("Invalid Object")
            return
    except: pass

    if hasattr(v, "type"):
        if self.allow_types is not None:
            if v.type not in self.allow_types:
                if refresh: report("Invalid Object Type")
                return

    self.pp[self.identifier] = v

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_scene_gn(self.r_pp())

    if undo_push:
        ob = self.pp[self.identifier]
        ed_undo_push(message=f'{self.rna.name} : {ob.name  if hasattr(ob, "name") else ob}')
    # >>>
    #|

def c_upd_data_GnVal(self):
    # <<< 1copy (0defuiUpdDataFormat,, ${'getattr(self.pp, self.identifier)':'self.pp[self.identifier]'}$)
    self.upd_anim_button()
    if self.blf_value.unclip_text == self.pp[self.identifier]: return


    v = self.pp[self.identifier]
    self.blf_value.unclip_text = v
    self.blf_value.text = self.text_format(v)
    # >>>
    #|
def c_upd_data_GnStr(self):
    # <<< 1copy (0defuiStrUpdData,, ${'getattr(self.pp, self.identifier)':'self.pp[self.identifier]'}$)
    self.upd_anim_button()
    if self.blf_value.unclip_text == self.pp[self.identifier]: return


    blf_value = self.blf_value
    v = self.pp[self.identifier]
    blf_value.unclip_text = v

    # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
    blfSize(FONT0, D_SIZE['font_main'])
    blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
    # >>>

    if self.init_bat == self.init_bat_anim_FULL:
        if self.blf_title.unclip_text:
            if hasattr(self, "r_button_width"):
                if self.r_button_width.__defaults__ is None:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
            else:
                button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
        else:
            if hasattr(self, "r_button_width"):
                if self.r_button_width.__defaults__ is None:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
            else:
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

        blf_value.text = r_blf_clipping_end_with(v, button_width - (
            D_SIZE['font_main_dx'] + SIZE_border[3]) * 2)#_REF_
    else:
        blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
            ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2)#_REF_
    # >>>
    #|
def c_upd_data_GnStrSearch(self):
    # <<< 1copy (0defuiStrUpdData,, ${
    #     'getattr(self.pp, self.identifier)': 'self.pp[self.identifier]',
    #     ')#_REF_': ' - SIZE_widget[0] * 2)'
    # }$)
    self.upd_anim_button()
    if self.blf_value.unclip_text == self.pp[self.identifier]: return


    blf_value = self.blf_value
    v = self.pp[self.identifier]
    blf_value.unclip_text = v

    # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
    blfSize(FONT0, D_SIZE['font_main'])
    blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
    # >>>

    if self.init_bat == self.init_bat_anim_FULL:
        if self.blf_title.unclip_text:
            if hasattr(self, "r_button_width"):
                if self.r_button_width.__defaults__ is None:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
            else:
                button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
        else:
            if hasattr(self, "r_button_width"):
                if self.r_button_width.__defaults__ is None:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
            else:
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

        blf_value.text = r_blf_clipping_end_with(v, button_width - (
            D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] * 2)
    else:
        blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
            ) - (D_SIZE['font_main_dx'] + SIZE_border[3]) * 2 - SIZE_widget[0] * 2)
    # >>>

    self.update_icon(v)
    #|
def c_upd_data_GnBool(self):
    # <<< 1copy (0defuiBoolUpdData,, ${'getattr(self.pp, self.identifier)':'self.pp[self.identifier]'}$)
    self.upd_anim_button()
    self.box_button.value = self.pp[self.identifier]
    # >>>
    #|
def c_upd_data_GnVec(self):
    # <<< 1copy (0defuiUpdDataFormatVec,, ${'getattr(self.pp, self.identifier)':'self.pp[self.identifier]'}$)
    self.upd_anim_button()
    for e, o in zip(self.blf_value, self.pp[self.identifier]):
        if e.unclip_text == o: continue

        e.unclip_text = o
        e.text = self.text_format(o)
    # >>>
    #|
def c_upd_data_GnID(self):
    # <<< 1copy (0defuiIDUpdData,, ${'getattr(self.pp, self.identifier)':'self.pp[self.identifier]'}$)
    self.upd_anim_button()
    ob = self.pp[self.identifier]
    if self.blf_value.unclip_text == (ob.name  if ob else ""): return


    blf_value = self.blf_value
    v = ob.name  if ob else ""
    blf_value.unclip_text = v
    self.update_icon(ob)

    # <<< 1copy (init_blf_clipping_end,, ${'font_size':'font_main'}$)
    blfSize(FONT0, D_SIZE['font_main'])
    blg.CLIPPING_END_STR_DIMEN = floor(blfDimen(FONT0, blg.CLIPPING_END_STR)[0])
    # >>>

    if self.init_bat == self.init_bat_anim_FULL:
        if self.blf_title.unclip_text:
            if hasattr(self, "r_button_width"):
                if self.r_button_width.__defaults__ is None:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width()
                else:
                    button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0]) - self.r_button_width() - SIZE_widget[0]
            else:
                button_width = self.w.r_width_input(self) - SIZE_widget[0] - SIZE_border[3] - D_SIZE['font_main_title_offset'] * 2 - round(blfDimen(FONT0, self.blf_title.unclip_text)[0])
        else:
            if hasattr(self, "r_button_width"):
                if self.r_button_width.__defaults__ is None:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width()
                else:
                    button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0] - self.r_button_width() - SIZE_widget[0]
            else:
                button_width = self.w.r_width_input(self) - SIZE_border[3] * 3 - SIZE_widget[0]

        blf_value.text = r_blf_clipping_end_with(v, button_width - (
            D_SIZE['font_main_dx'] + SIZE_border[3] + SIZE_widget[0]) * 2)
    else:
        blf_value.text = r_blf_clipping_end_with(v, (self.r_button_width()  if hasattr(self, "r_button_width") else D_SIZE['widget_width']
            ) - (D_SIZE['font_main_dx'] + SIZE_border[3] + SIZE_widget[0]) * 2)
    # >>>
    #|
def c_upd_data_GnColor(self):
    # <<< 1copy (0defBuColor_upd_data,, ${'getattr(self.pp, self.identifier)':'self.pp[self.identifier]'}$)
    self.upd_anim_button()
    if list(self.pp[self.identifier]) == self.color_value: return


    v = self.pp[self.identifier]
    self.color_value[:] = v
    self.set_box_color(v)
    # >>>
    #|

def c_r_default_value_GnPointer(self):
    s = self.rna.default
    if s:
        bl_data_attr = D_id_blendData.get(self.idtype, None)
        if bl_data_attr:
            bl_data = getattr(bpy.data, bl_data_attr, None)
            if bl_data:
                if s in bl_data:
                    return bl_data[s]
    return None
    #|

def c_to_dropdown_gn_attributes(self, killevt=True, select_all=None):


    return DropDownEnum(self, self.box_button.r_LRBT(), self.rna.name,
        items = self.enum_items(),
        get_icon = geticon_obj_attr,
        get_info = getinfo_obj_attr)
    #|

def gnVal(cls):
    cls.get = c_getGn
    cls.set = c_setGn

    cls.evt_attr_toggle = c_evt_attr_toggle

    cls.i_upd_anim_button = c_upd_button_keyframe_VAL_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_VAL_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_VAL_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_VAL_ov_dark_cprop

    cls.upd_data = c_upd_data_GnVal
    return cls
    #|
def gnAttribute(cls):
    cls.get = c_getGn
    cls.set = c_setGn

    cls.evt_attr_toggle = c_evt_attr_toggle
    cls.to_dropdown = c_to_dropdown_gn_attributes

    cls.i_upd_anim_button = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_STR_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_STR_ov_dark_cprop

    cls.upd_data = c_upd_data_GnStrSearch
    return cls
    #|
def gnAttributeOutput(cls):
    cls.get = c_getGn
    cls.set = c_setGn

    cls.to_dropdown = c_to_dropdown_gn_attributes

    cls.i_upd_anim_button = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_STR_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_STR_ov_dark_cprop

    cls.upd_data = c_upd_data_GnStrSearch
    return cls
    #|
def gnStr(cls):
    cls.get = c_getGn
    cls.set = c_setGn

    cls.i_upd_anim_button = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_STR_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_STR_ov_dark_cprop

    cls.upd_data = c_upd_data_GnStr
    return cls
    #|
def gnBool(cls):
    cls.get = c_getGn
    cls.set = c_setGn

    cls.evt_attr_toggle = c_evt_attr_toggle

    cls.i_upd_anim_button = c_upd_button_keyframe_BOOL_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_BOOL_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_BOOL_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_BOOL_ov_dark_cprop

    cls.upd_data = c_upd_data_GnBool
    return cls
    #|
def gnVec(cls):
    cls.get = c_getGn
    cls.set = c_setGn_vec

    cls.evt_attr_toggle = c_evt_attr_toggle

    cls.i_upd_anim_button = c_upd_button_keyframe_VAL_vec_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_VAL_vec_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_VAL_vec_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_VAL_vec_ov_dark_cprop

    cls.upd_data = c_upd_data_GnVec
    return cls
    #|
def gnID(cls):
    cls.get = c_getGn
    cls.set = c_setGn_ID

    cls.i_upd_anim_button = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_STR_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_STR_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_STR_ov_dark_cprop

    cls.upd_data = c_upd_data_GnID
    cls.r_default_value = c_r_default_value_GnPointer
    return cls
def gnColor(cls):
    cls.get = c_getGn
    cls.set = c_setGn_vec

    cls.evt_attr_toggle = c_evt_attr_toggle

    cls.i_upd_anim_button = c_upd_button_keyframe_COLOR_cprop
    cls.i_upd_anim_button_dark = c_upd_button_keyframe_COLOR_dark_cprop
    cls.i_upd_anim_button_ov = c_upd_button_keyframe_COLOR_ov_cprop
    cls.i_upd_anim_button_ov_dark = c_upd_button_keyframe_COLOR_ov_dark_cprop

    cls.upd_data = c_upd_data_GnColor
    return cls
    #|

buGn_slots = ('identifier_escape', )
@ gnVal
class BuGnInt(BuInt): __slots__ = buGn_slots
@ gnVal
class BuGnFloat(BuFloat): __slots__ = buGn_slots
@ gnAttribute
class BuGnAttribute(BuStrSearch): __slots__ = buGn_slots
@ gnAttributeOutput
class BuGnAttributeOutput(BuStrSearch): __slots__ = buGn_slots
@ gnStr
class BuGnStr(BuStr): __slots__ = buGn_slots
@ gnBool
class BuGnBool(BuBool): __slots__ = buGn_slots
@ gnVec
class BuGnFloatVec(BuFloatVec): __slots__ = buGn_slots
@ gnVec
class BuGnFloatVecSub(BuFloatVecSub): __slots__ = buGn_slots
@ gnVec
class BuGnFloatVecColor(BuFloatVecColor): __slots__ = buGn_slots
@ gnID
class BuGnID(BuID): __slots__ = buGn_slots
@ gnColor
class BuGnColor(BuColor): __slots__ = buGn_slots

@ toNoAnimGn
class BuGnFloatVecColorNoAnim(BuGnFloatVecColor): __slots__ = ()
@ toNoAnimGn
class BuGnFloatVecSubNoAnim(BuGnFloatVecSub): __slots__ = ()


def rr_items_gn_attributes(r_object):
    def r_items_gn_attributes():
        ob = r_object()
        if hasattr(ob, "data") and hasattr(ob.data, "attributes") and ob.data.attributes:
            return list(ob.vertex_groups) + list(e  for e in ob.data.attributes  if not e.is_internal)
        return []
    return r_items_gn_attributes
    #|
def rr_object(r_pp):
    def r_object():
        return getattr(r_pp(), "id_data", None)
    return r_object
    #|

def r_crna_String(pp, rna):
    crna = RnaString(
        identifier = rna.identifier,
        name = rna.name,
        description = rna.description,
        default = rna.default_value)

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = False
    crna.is_input = True
    return crna
    #|
def r_crna_Int(pp, rna):
    # /* 0defcprop_use_attribute
    use_attribute = f'{rna.identifier}_use_attribute'
    if use_attribute in pp and pp[use_attribute]:
        crna = RnaString(
            identifier = f'{rna.identifier}_attribute_name',
            name = rna.name,
            description = rna.description,
            default = rna.default_attribute_name)

        crna.bl_socket_idname = rna.bl_socket_idname
        crna.use_attribute = True
        crna.is_input = True
        return crna
    # */
    crna = RnaInt(
        identifier = rna.identifier,
        name = rna.name,
        description = rna.description,
        default = rna.default_value,
        subtype = rna.subtype,
        is_animatable = True,
        soft_min = rna.min_value,
        soft_max = rna.max_value)

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = False
    crna.is_input = True
    return crna
    #|
def r_crna_Float(pp, rna):
    # <<< 1copy (0defcprop_use_attribute,, $$)
    use_attribute = f'{rna.identifier}_use_attribute'
    if use_attribute in pp and pp[use_attribute]:
        crna = RnaString(
            identifier = f'{rna.identifier}_attribute_name',
            name = rna.name,
            description = rna.description,
            default = rna.default_attribute_name)

        crna.bl_socket_idname = rna.bl_socket_idname
        crna.use_attribute = True
        crna.is_input = True
        return crna
    # >>>

    crna = RnaFloat(
        identifier = rna.identifier,
        name = rna.name,
        description = rna.description,
        default = rna.default_value,
        subtype = rna.subtype,
        unit = D_gn_subtype_unit.get(rna.subtype, "NONE"),
        is_animatable = True,
        soft_min = rna.min_value,
        soft_max = rna.max_value)

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = False
    crna.is_input = True
    return crna
    #|
def r_crna_Color(pp, rna):
    # <<< 1copy (0defcprop_use_attribute,, $$)
    use_attribute = f'{rna.identifier}_use_attribute'
    if use_attribute in pp and pp[use_attribute]:
        crna = RnaString(
            identifier = f'{rna.identifier}_attribute_name',
            name = rna.name,
            description = rna.description,
            default = rna.default_attribute_name)

        crna.bl_socket_idname = rna.bl_socket_idname
        crna.use_attribute = True
        crna.is_input = True
        return crna
    # >>>

    crna = RnaFloatVector(
        identifier = rna.identifier,
        name = rna.name,
        description = rna.description,
        default = list(rna.default_value),
        subtype = "COLOR",
        unit = "NONE",
        is_animatable = True)

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = False
    crna.is_input = True
    return crna
    #|
def r_crna_Bool(pp, rna):
    # <<< 1copy (0defcprop_use_attribute,, $$)
    use_attribute = f'{rna.identifier}_use_attribute'
    if use_attribute in pp and pp[use_attribute]:
        crna = RnaString(
            identifier = f'{rna.identifier}_attribute_name',
            name = rna.name,
            description = rna.description,
            default = rna.default_attribute_name)

        crna.bl_socket_idname = rna.bl_socket_idname
        crna.use_attribute = True
        crna.is_input = True
        return crna
    # >>>

    crna = RnaBool(
        identifier = rna.identifier,
        name = rna.name,
        description = rna.description,
        default = rna.default_value,
        is_animatable = True)

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = False
    crna.is_input = True
    return crna
    #|
def r_crna_Rotation(pp, rna):
    # <<< 1copy (0defcprop_use_attribute,, $$)
    use_attribute = f'{rna.identifier}_use_attribute'
    if use_attribute in pp and pp[use_attribute]:
        crna = RnaString(
            identifier = f'{rna.identifier}_attribute_name',
            name = rna.name,
            description = rna.description,
            default = rna.default_attribute_name)

        crna.bl_socket_idname = rna.bl_socket_idname
        crna.use_attribute = True
        crna.is_input = True
        return crna
    # >>>

    crna = RnaFloatVector(
        identifier = rna.identifier,
        name = rna.name,
        description = rna.description,
        default = list(rna.default_value),
        subtype = "EULER",
        unit = "ROTATION",
        is_animatable = True)

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = False
    crna.is_input = True
    return crna
    #|
def r_crna_Vector(pp, rna):
    # <<< 1copy (0defcprop_use_attribute,, $$)
    use_attribute = f'{rna.identifier}_use_attribute'
    if use_attribute in pp and pp[use_attribute]:
        crna = RnaString(
            identifier = f'{rna.identifier}_attribute_name',
            name = rna.name,
            description = rna.description,
            default = rna.default_attribute_name)

        crna.bl_socket_idname = rna.bl_socket_idname
        crna.use_attribute = True
        crna.is_input = True
        return crna
    # >>>

    crna = RnaFloatVector(
        identifier = rna.identifier,
        name = rna.name,
        description = rna.description,
        default = list(rna.default_value),
        subtype = rna.subtype,
        unit = D_gn_subtype_unit.get(rna.subtype, "NONE"),
        is_animatable = True,
        soft_min = rna.min_value,
        soft_max = rna.max_value)

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = False
    crna.is_input = True
    return crna
    #|
def r_crna_Pointer(pp, rna):
    ob = rna.default_value
    if ob:
        ob = (ob.name, ob.library.filepath)  if ob.library else ob.name

    crna = RnaPointer(
        identifier = rna.identifier,
        name = rna.name,
        description = rna.description,
        default = ob)

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = False
    crna.is_input = True
    return crna
    #|
def r_crna_Output(pp, rna):
    crna = RnaString(
        identifier = f'{rna.identifier}_attribute_name',
        name = rna.name,
        description = rna.description,
        default = "")

    crna.bl_socket_idname = rna.bl_socket_idname
    crna.use_attribute = True
    crna.is_input = False
    return crna
    #|
def r_crna_Panel(pp, rna):
    crna = RnaString(
        identifier = "",
        name = rna.name,
        description = rna.description,
        default = "")

    crna.bl_socket_idname = "Panel"
    crna.use_attribute = len(rna.interface_items)
    crna.is_input = rna.default_closed
    return crna
    #|

def crna_compare_STRING(rna0, rna1):
    if rna0.type == rna1.type: pass
    else: return False
    if rna0.bl_socket_idname == rna1.bl_socket_idname: pass
    else: return False
    if rna0.identifier == rna1.identifier: pass
    else: return False
    if rna0.name == rna1.name: pass
    else: return False
    if rna0.description == rna1.description: pass
    else: return False
    if rna0.default == rna1.default: pass
    else: return False
    if rna0.use_attribute == rna1.use_attribute: pass
    else: return False
    return True
    #|
def crna_compare_INT(rna0, rna1):
    if rna0.type == rna1.type: pass
    else: return False
    if rna0.is_array is True:
        if rna1.is_array is False: return False
        if rna0.default_array == rna1.default_array: pass
        else: return False
    else:
        if rna1.is_array is True: return False
        if rna0.default == rna1.default: pass
        else: return False
    if rna0.is_array == rna1.is_array: pass
    else: return False
    if rna0.identifier == rna1.identifier: pass
    else: return False
    if rna0.name == rna1.name: pass
    else: return False
    if rna0.description == rna1.description: pass
    else: return False
    if rna0.subtype == rna1.subtype: pass
    else: return False
    if rna0.soft_min == rna1.soft_min: pass
    else: return False
    if rna0.soft_max == rna1.soft_max: pass
    else: return False
    return True
    #|
def crna_compare_FLOAT(rna0, rna1):
    if rna0.type == rna1.type: pass
    else: return False
    if rna0.is_array is True:
        if rna1.is_array is False: return False
        if rna0.default_array == rna1.default_array: pass
        else: return False
    else:
        if rna1.is_array is True: return False
        if rna0.default == rna1.default: pass
        else: return False
    if rna0.identifier == rna1.identifier: pass
    else: return False
    if rna0.name == rna1.name: pass
    else: return False
    if rna0.description == rna1.description: pass
    else: return False
    if rna0.subtype == rna1.subtype: pass
    else: return False
    if rna0.unit == rna1.unit: pass
    else: return False
    if rna0.soft_min == rna1.soft_min: pass
    else: return False
    if rna0.soft_max == rna1.soft_max: pass
    else: return False
    return True
    #|
def crna_compare_BOOLEAN(rna0, rna1):
    if rna0.type == rna1.type: pass
    else: return False
    if rna0.identifier == rna1.identifier: pass
    else: return False
    if rna0.name == rna1.name: pass
    else: return False
    if rna0.description == rna1.description: pass
    else: return False
    if rna0.default == rna1.default: pass
    else: return False
    return True
    #|
def crna_compare_POINTER(rna0, rna1):
    if rna0.type == rna1.type: pass
    else: return False
    if rna0.bl_socket_idname == rna1.bl_socket_idname: pass
    else: return False
    if rna0.identifier == rna1.identifier: pass
    else: return False
    if rna0.name == rna1.name: pass
    else: return False
    if rna0.description == rna1.description: pass
    else: return False
    if rna0.default == rna1.default: pass
    else: return False
    return True
    #|

def cprop_STRING(self, crna, text=None, isdarkhard=False, options={}):
    if crna.use_attribute:
        out = BuGnAttribute(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)

        out.identifier_escape = f'["{out.identifier}"]'
        out.init_bat = out.init_bat_anim
        out.enum_items = rr_items_gn_attributes(rr_object(self.r_pp))
        out.pollred = False
        out.box_icon_arrow = GpuImg_unfold()
        out.box_icon = GpuImg_SPREADSHEET()
        out.box_icon_cls = GpuImg_SPREADSHEET
    else:
        out = BuGnStr(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)
        out.identifier_escape = f'["{out.identifier}"]'
        out.init_bat = out.init_bat_anim

    self.props[(out.identifier, )] = out
    self.items.append(out)
    #|
def cprop_INT(self, crna, text=None, isdarkhard=False, options={}):
    out = BuGnInt(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)
    out.identifier_escape = f'["{out.identifier}"]'
    out.init_bat = out.init_bat_anim

    self.props[(out.identifier, )] = out
    self.items.append(out)
    #|
def cprop_FLOAT(self, crna, text=None, isdarkhard=False, options={}):
    if crna.is_array is True:
        if crna.subtype == "NONE":
            out = BuGnFloatVec(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)
            out.init_bat = out.init_bat_anim
        elif crna.subtype == "COLOR":
            out = BuGnColor(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard, "Scene Linear")
            out.init_bat = out.init_bat_anim_4
        else:
            out = BuGnFloatVecSub(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)
            out.init_subtype("XYZ")
            out.init_bat = out.init_bat_anim
    else:
        out = BuGnFloat(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)
        out.init_bat = out.init_bat_anim

    out.identifier_escape = f'["{out.identifier}"]'

    self.props[(out.identifier, )] = out
    self.items.append(out)
    #|
def cprop_BOOLEAN(self, crna, text=None, isdarkhard=False, options={}):
    out = BuGnBool(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)
    out.identifier_escape = f'["{out.identifier}"]'

    if "FLIP" in options:
        out.init_bat = out.init_bat_anim
    elif "HEAD" in options:
        out.init_bat = out.init_bat_animH
    else:
        out.init_bat = out.init_bat_animR

    self.props[(out.identifier, )] = out
    self.items.append(out)
    #|
def cprop_POINTER(self, crna, text=None, isdarkhard=False, options={}):
    out = BuGnID(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)
    out.identifier_escape = f'["{out.identifier}"]'

    out.idtype = D_gn_pointer[crna.bl_socket_idname]
    out.allow_types = None
    out.fixed_idtype = True
    out.r_except_objects = None
    out.box_icon_arrow = GpuImg_unfold()
    out.box_icon = GpuImgNull()
    out.init_bat = out.init_bat_anim
    out.update_icon()

    self.props[(out.identifier, )] = out
    self.items.append(out)
    #|
def cprop_OUTPUT(self, crna, text=None, isdarkhard=False, options={}):
    out = BuGnAttributeOutput(self.w, crna, self.r_pp, self.ui_anim_data, text, isdarkhard)

    out.identifier_escape = f'["{out.identifier}"]'
    out.init_bat = out.init_bat_anim
    out.enum_items = rr_items_gn_attributes(rr_object(self.r_pp))
    out.pollred = False
    out.box_icon_arrow = GpuImg_unfold()
    out.box_icon = GpuImg_SPREADSHEET()
    out.box_icon_cls = GpuImg_SPREADSHEET

    self.props[(out.identifier, )] = out
    self.items.append(out)
    #|

D_cprop = {
    "STRING": cprop_STRING,
    "INT": cprop_INT,
    "FLOAT": cprop_FLOAT,
    "BOOLEAN": cprop_BOOLEAN,
    "POINTER": cprop_POINTER}
D_crna_compare = {
    "STRING": crna_compare_STRING,
    "INT": crna_compare_INT,
    "FLOAT": crna_compare_FLOAT,
    "BOOLEAN": crna_compare_BOOLEAN,
    "POINTER": crna_compare_POINTER}
D_crna = {
    "NodeSocketString": r_crna_String,
    "NodeSocketBool": r_crna_Bool,
    "NodeSocketMaterial": r_crna_Pointer,
    "NodeSocketVector": r_crna_Vector,
    "NodeSocketInt": r_crna_Int,
    "NodeSocketCollection": r_crna_Pointer,
    "NodeSocketTexture": r_crna_Pointer,
    "NodeSocketFloat": r_crna_Float,
    "NodeSocketColor": r_crna_Color,
    "NodeSocketObject": r_crna_Pointer,
    "NodeSocketRotation": r_crna_Rotation,
    "NodeSocketImage": r_crna_Pointer}
D_gn_pointer = {
    "NodeSocketMaterial": "MATERIAL",
    "NodeSocketCollection": "COLLECTION",
    "NodeSocketTexture": "TEXTURE",
    "NodeSocketObject": "OBJECT",
    "NodeSocketImage": "IMAGE"}
S_crna_output = {
    "NodeSocketBool",
    "NodeSocketVector",
    "NodeSocketInt",
    "NodeSocketMenu",
    "NodeSocketFloat",
    "NodeSocketColor",
    "NodeSocketRotation",
    "NodeSocketMatrix"}
D_gn_subtype_unit = {
    "NONE": "NONE",
    "TRANSLATION": "LENGTH",
    "DIRECTION": "LENGTH",
    "VELOCITY": "VELOCITY",
    "ACCELERATION": "ACCELERATION",
    "EULER": "ROTATION",
    "XYZ": "NONE",

    "PERCENTAGE": "NONE",
    "FACTOR": "NONE",
    "ANGLE": "ROTATION",
    "TIME": "TIME",
    "TIME_ABSOLUTE": "TIME_ABSOLUTE",
    "DISTANCE": "LENGTH"}

def r_button_width_str_title_fit(head=None):
    return SIZE_border[3] - D_SIZE['font_main_title_offset']
    #|
def r_button_width_str_title_full(head=None):
    return 0
def r_layout_format_gn(format_codes):
    indent = None
    sep = None
    align = None

    for code in format_codes[1 : ]:
        code = code.strip()
        if code.startswith("#"):
            try:
                indent = min(max(int(code[1 : ]), -10), 9)
            except: pass
        elif code.startswith("sep(") and code.endswith(")"):
            try:
                sep = min(max(float(code[4 : -1]), 0.0), 64.0)
            except: pass
        elif code.startswith("align(") and code.endswith(")"):
            align = code[6 : -1].strip()

    return indent, sep, align
    #|
def is_gn_rna_dirty(self, md, items_stacks, uianim, uianim_output, uianim_panel, old_crna_panels):
    crna_inputs = []
    crna_outputs = []
    crna_panels = []
    crna_panels_item = []

    for rna in md.node_group.interface.items_tree:
        if rna.item_type == "PANEL":
            crna_panels.append(r_crna_Panel(md, rna))
            crna_panels_item.append([D_crna[e.bl_socket_idname](md, e)  for e in rna.interface_items  if e.bl_socket_idname in D_crna and not e.hide_in_modifier])
            continue

        if rna.parent.parent is None:
            if rna.in_out == "INPUT":
                if rna.bl_socket_idname in D_crna:
                    if rna.hide_in_modifier: continue

                    crna_inputs.append(D_crna[rna.bl_socket_idname](md, rna))
            else:
                if rna.bl_socket_idname in S_crna_output:
                    crna_outputs.append(r_crna_Output(md, rna))

    if len(crna_inputs) == len(uianim.props):
        is_dirty_inputs = any(D_crna_compare[crna.type](crna, button.rna) is False  for crna, button in zip(crna_inputs, uianim.props.values()))
    else:
        is_dirty_inputs = True
    if is_dirty_inputs is True:
        b1 = items_stacks[1]
        uianim.props.clear()
        b1.items.clear()
        indent_stacks = [b1]
        active_stack = b1

        for crna in crna_inputs:
            # /* 0defgn_layout_inputs
            if crna.description.startswith(";"):
                indent, sep, align = r_layout_format_gn(crna.description.split(";"))

                if indent is not None:
                    old_len = len(indent_stacks)
                    if indent < 0:
                        indent += old_len + 1
                    indent = min(max(0, indent), old_len)

                    if indent == old_len:
                        # <<< 1copy (0defgn_layout_new_stack,, $$)
                        if sep is None: pass
                        else:
                            active_stack.sep(sep)

                        if crna.type == "BOOLEAN":
                            if align == "left":
                                D_cprop[crna.type](active_stack, crna, options={"FLIP"})
                            elif align == "right":
                                D_cprop[crna.type](active_stack, crna)
                            elif align == "hide":
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items.pop()
                                active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                indent_stacks.append(active_stack)
                                continue
                            else:
                                D_cprop[crna.type](active_stack, crna, options={"HEAD"})
                        elif crna.type == "STRING":
                            if align == "full":
                                D_cprop[crna.type](active_stack, crna, text="")
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_full
                                o.set_align("FULL")
                            elif align == "fit":
                                D_cprop[crna.type](active_stack, crna)
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_fit
                                o.set_align("FULL")
                            elif align in {"hide", None}:
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items.pop()
                                active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                indent_stacks.append(active_stack)
                                continue
                            else:
                                D_cprop[crna.type](active_stack, crna)
                        elif crna.type == "POINTER":
                            if align == "full":
                                D_cprop[crna.type](active_stack, crna, text="")
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_full
                                o.set_align("FULL")
                            elif align == "fit":
                                D_cprop[crna.type](active_stack, crna)
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_fit
                                o.set_align("FULL")
                            elif align == "hide":
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items.pop()
                                active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                indent_stacks.append(active_stack)
                                continue
                            else:
                                D_cprop[crna.type](active_stack, crna)
                        else:
                            if align == "hide":
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items.pop()
                                active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                indent_stacks.append(active_stack)
                                continue
                            else:
                                D_cprop[crna.type](active_stack, crna, options={"HEAD"})

                        active_stack = active_stack.new_block(title=active_stack.items.pop(), heavy=True)
                        indent_stacks.append(active_stack)
                        # >>>
                        continue
                    elif indent == old_len - 1 and indent != 0:
                        del indent_stacks[indent : ]
                        active_stack = indent_stacks[-1]

                        # <<< 1copy (0defgn_layout_new_stack,, $$)
                        if sep is None: pass
                        else:
                            active_stack.sep(sep)

                        if crna.type == "BOOLEAN":
                            if align == "left":
                                D_cprop[crna.type](active_stack, crna, options={"FLIP"})
                            elif align == "right":
                                D_cprop[crna.type](active_stack, crna)
                            elif align == "hide":
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items.pop()
                                active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                indent_stacks.append(active_stack)
                                continue
                            else:
                                D_cprop[crna.type](active_stack, crna, options={"HEAD"})
                        elif crna.type == "STRING":
                            if align == "full":
                                D_cprop[crna.type](active_stack, crna, text="")
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_full
                                o.set_align("FULL")
                            elif align == "fit":
                                D_cprop[crna.type](active_stack, crna)
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_fit
                                o.set_align("FULL")
                            elif align in {"hide", None}:
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items.pop()
                                active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                indent_stacks.append(active_stack)
                                continue
                            else:
                                D_cprop[crna.type](active_stack, crna)
                        elif crna.type == "POINTER":
                            if align == "full":
                                D_cprop[crna.type](active_stack, crna, text="")
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_full
                                o.set_align("FULL")
                            elif align == "fit":
                                D_cprop[crna.type](active_stack, crna)
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_fit
                                o.set_align("FULL")
                            elif align == "hide":
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items.pop()
                                active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                indent_stacks.append(active_stack)
                                continue
                            else:
                                D_cprop[crna.type](active_stack, crna)
                        else:
                            if align == "hide":
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items.pop()
                                active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                indent_stacks.append(active_stack)
                                continue
                            else:
                                D_cprop[crna.type](active_stack, crna, options={"HEAD"})

                        active_stack = active_stack.new_block(title=active_stack.items.pop(), heavy=True)
                        indent_stacks.append(active_stack)
                        # >>>
                        continue
                    else:
                        del indent_stacks[indent + 1 : ]
                        active_stack = indent_stacks[-1]

                if align is None:
                    D_cprop[crna.type](active_stack, crna)
                else:
                    if crna.type == "BOOLEAN":
                        if align == "left":
                            D_cprop[crna.type](active_stack, crna, options={"FLIP"})
                        elif align == "right":
                            D_cprop[crna.type](active_stack, crna)
                        else:
                            D_cprop[crna.type](active_stack, crna, options={"HEAD"})
                    elif crna.type in {"STRING", "POINTER"}:
                        if align == "full":
                            D_cprop[crna.type](active_stack, crna, text="")
                            active_stack.items[-1].set_align("FULL")
                        elif align == "fit":
                            D_cprop[crna.type](active_stack, crna)
                            active_stack.items[-1].set_align("FULL")
                        else:
                            D_cprop[crna.type](active_stack, crna)
                    else:
                        D_cprop[crna.type](active_stack, crna)

                if sep is None: pass
                else:
                    active_stack.sep(sep)
            else:
                D_cprop[crna.type](active_stack, crna)
            # */


    if len(crna_panels) == len(old_crna_panels):
        is_dirty_panels = any(crna_compare_STRING(crna, old) is False  for crna, old in zip(crna_panels, old_crna_panels))

        if is_dirty_panels is False:
            is_dirty_panels = any(D_crna_compare[crna.type](crna, button.rna) is False  for crna, button in zip(sum(crna_panels_item, []), uianim_panel.props.values()))
    else:
        is_dirty_panels = True
    if is_dirty_panels is True:
        old_crna_panels[:] = crna_panels
        uianim_panel.props.clear()
        ui = Ui(self)
        self.items += [items_stacks[0].w, items_stacks[1].w]
        ui.set_pp_from(uianim_panel)

        for panel, crnas in zip(crna_panels, crna_panels_item):
            ui.set_fold_state(panel.is_input)
            b1 = ui.new_block(title=panel.name, heavy=True)
            indent_stacks = [b1]
            active_stack = b1

            for crna in crnas:
                # <<< 1copy (0defgn_layout_inputs,, $$)
                if crna.description.startswith(";"):
                    indent, sep, align = r_layout_format_gn(crna.description.split(";"))

                    if indent is not None:
                        old_len = len(indent_stacks)
                        if indent < 0:
                            indent += old_len + 1
                        indent = min(max(0, indent), old_len)

                        if indent == old_len:
                            # <<< 1copy (0defgn_layout_new_stack,, $$)
                            if sep is None: pass
                            else:
                                active_stack.sep(sep)

                            if crna.type == "BOOLEAN":
                                if align == "left":
                                    D_cprop[crna.type](active_stack, crna, options={"FLIP"})
                                elif align == "right":
                                    D_cprop[crna.type](active_stack, crna)
                                elif align == "hide":
                                    D_cprop[crna.type](active_stack, crna)
                                    active_stack.items.pop()
                                    active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                    indent_stacks.append(active_stack)
                                    continue
                                else:
                                    D_cprop[crna.type](active_stack, crna, options={"HEAD"})
                            elif crna.type == "STRING":
                                if align == "full":
                                    D_cprop[crna.type](active_stack, crna, text="")
                                    o = active_stack.items[-1]
                                    o.r_button_width = r_button_width_str_title_full
                                    o.set_align("FULL")
                                elif align == "fit":
                                    D_cprop[crna.type](active_stack, crna)
                                    o = active_stack.items[-1]
                                    o.r_button_width = r_button_width_str_title_fit
                                    o.set_align("FULL")
                                elif align in {"hide", None}:
                                    D_cprop[crna.type](active_stack, crna)
                                    active_stack.items.pop()
                                    active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                    indent_stacks.append(active_stack)
                                    continue
                                else:
                                    D_cprop[crna.type](active_stack, crna)
                            elif crna.type == "POINTER":
                                if align == "full":
                                    D_cprop[crna.type](active_stack, crna, text="")
                                    o = active_stack.items[-1]
                                    o.r_button_width = r_button_width_str_title_full
                                    o.set_align("FULL")
                                elif align == "fit":
                                    D_cprop[crna.type](active_stack, crna)
                                    o = active_stack.items[-1]
                                    o.r_button_width = r_button_width_str_title_fit
                                    o.set_align("FULL")
                                elif align == "hide":
                                    D_cprop[crna.type](active_stack, crna)
                                    active_stack.items.pop()
                                    active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                    indent_stacks.append(active_stack)
                                    continue
                                else:
                                    D_cprop[crna.type](active_stack, crna)
                            else:
                                if align == "hide":
                                    D_cprop[crna.type](active_stack, crna)
                                    active_stack.items.pop()
                                    active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                    indent_stacks.append(active_stack)
                                    continue
                                else:
                                    D_cprop[crna.type](active_stack, crna, options={"HEAD"})

                            active_stack = active_stack.new_block(title=active_stack.items.pop(), heavy=True)
                            indent_stacks.append(active_stack)
                            # >>>
                            continue
                        elif indent == old_len - 1 and indent != 0:
                            del indent_stacks[indent : ]
                            active_stack = indent_stacks[-1]

                            # <<< 1copy (0defgn_layout_new_stack,, $$)
                            if sep is None: pass
                            else:
                                active_stack.sep(sep)

                            if crna.type == "BOOLEAN":
                                if align == "left":
                                    D_cprop[crna.type](active_stack, crna, options={"FLIP"})
                                elif align == "right":
                                    D_cprop[crna.type](active_stack, crna)
                                elif align == "hide":
                                    D_cprop[crna.type](active_stack, crna)
                                    active_stack.items.pop()
                                    active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                    indent_stacks.append(active_stack)
                                    continue
                                else:
                                    D_cprop[crna.type](active_stack, crna, options={"HEAD"})
                            elif crna.type == "STRING":
                                if align == "full":
                                    D_cprop[crna.type](active_stack, crna, text="")
                                    o = active_stack.items[-1]
                                    o.r_button_width = r_button_width_str_title_full
                                    o.set_align("FULL")
                                elif align == "fit":
                                    D_cprop[crna.type](active_stack, crna)
                                    o = active_stack.items[-1]
                                    o.r_button_width = r_button_width_str_title_fit
                                    o.set_align("FULL")
                                elif align in {"hide", None}:
                                    D_cprop[crna.type](active_stack, crna)
                                    active_stack.items.pop()
                                    active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                    indent_stacks.append(active_stack)
                                    continue
                                else:
                                    D_cprop[crna.type](active_stack, crna)
                            elif crna.type == "POINTER":
                                if align == "full":
                                    D_cprop[crna.type](active_stack, crna, text="")
                                    o = active_stack.items[-1]
                                    o.r_button_width = r_button_width_str_title_full
                                    o.set_align("FULL")
                                elif align == "fit":
                                    D_cprop[crna.type](active_stack, crna)
                                    o = active_stack.items[-1]
                                    o.r_button_width = r_button_width_str_title_fit
                                    o.set_align("FULL")
                                elif align == "hide":
                                    D_cprop[crna.type](active_stack, crna)
                                    active_stack.items.pop()
                                    active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                    indent_stacks.append(active_stack)
                                    continue
                                else:
                                    D_cprop[crna.type](active_stack, crna)
                            else:
                                if align == "hide":
                                    D_cprop[crna.type](active_stack, crna)
                                    active_stack.items.pop()
                                    active_stack = active_stack.new_block(title=crna.name, heavy=True)
                                    indent_stacks.append(active_stack)
                                    continue
                                else:
                                    D_cprop[crna.type](active_stack, crna, options={"HEAD"})

                            active_stack = active_stack.new_block(title=active_stack.items.pop(), heavy=True)
                            indent_stacks.append(active_stack)
                            # >>>
                            continue
                        else:
                            del indent_stacks[indent + 1 : ]
                            active_stack = indent_stacks[-1]

                    if align is None:
                        D_cprop[crna.type](active_stack, crna)
                    else:
                        if crna.type == "BOOLEAN":
                            if align == "left":
                                D_cprop[crna.type](active_stack, crna, options={"FLIP"})
                            elif align == "right":
                                D_cprop[crna.type](active_stack, crna)
                            else:
                                D_cprop[crna.type](active_stack, crna, options={"HEAD"})
                        elif crna.type in {"STRING", "POINTER"}:
                            if align == "full":
                                D_cprop[crna.type](active_stack, crna, text="")
                                active_stack.items[-1].set_align("FULL")
                            elif align == "fit":
                                D_cprop[crna.type](active_stack, crna)
                                active_stack.items[-1].set_align("FULL")
                            else:
                                D_cprop[crna.type](active_stack, crna)
                        else:
                            D_cprop[crna.type](active_stack, crna)

                    if sep is None: pass
                    else:
                        active_stack.sep(sep)
                else:
                    D_cprop[crna.type](active_stack, crna)
                # >>>

        self.items += [e.w  for e in items_stacks[2 : ]]


    if len(crna_outputs) == len(uianim_output.props):
        is_dirty_outputs = any(crna_compare_STRING(crna, button.rna) is False  for crna, button in zip(crna_outputs, uianim_output.props.values()))
    else:
        is_dirty_outputs = True
    if is_dirty_outputs is True:
        b2 = items_stacks[2]
        uianim_output.props.clear()
        b2.items.clear()
        indent_stacks = [b2]
        active_stack = b2

        for crna in crna_outputs:
            if crna.description.startswith(";"):
                indent, sep, align = r_layout_format_gn(crna.description.split(";"))

                if indent is not None:
                    old_len = len(indent_stacks)
                    if indent < 0:
                        indent += old_len + 1
                    indent = min(max(0, indent), old_len)

                    if indent == old_len:
                        # /* 0defgn_layout_output_new_stack
                        if align in {"hide", None}:
                            if sep is None: pass
                            else:
                                active_stack.sep(sep)

                            cprop_OUTPUT(active_stack, crna)
                            active_stack.items.pop()

                            active_stack = active_stack.new_block(title=crna.name, heavy=True)
                            indent_stacks.append(active_stack)
                        else:
                            if align == "full":
                                cprop_OUTPUT(active_stack, crna, text="")
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_full
                                o.set_align("FULL")
                            elif align == "fit":
                                cprop_OUTPUT(active_stack, crna)
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_fit
                                o.set_align("FULL")
                            else:
                                cprop_OUTPUT(active_stack, crna)

                            active_stack = active_stack.new_block(title=active_stack.items.pop(), heavy=True)
                            indent_stacks.append(active_stack)
                        # */
                        continue
                    elif indent == old_len - 1 and indent != 0:
                        del indent_stacks[indent : ]
                        active_stack = indent_stacks[-1]

                        # <<< 1copy (0defgn_layout_output_new_stack,, $$)
                        if align in {"hide", None}:
                            if sep is None: pass
                            else:
                                active_stack.sep(sep)

                            cprop_OUTPUT(active_stack, crna)
                            active_stack.items.pop()

                            active_stack = active_stack.new_block(title=crna.name, heavy=True)
                            indent_stacks.append(active_stack)
                        else:
                            if align == "full":
                                cprop_OUTPUT(active_stack, crna, text="")
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_full
                                o.set_align("FULL")
                            elif align == "fit":
                                cprop_OUTPUT(active_stack, crna)
                                o = active_stack.items[-1]
                                o.r_button_width = r_button_width_str_title_fit
                                o.set_align("FULL")
                            else:
                                cprop_OUTPUT(active_stack, crna)

                            active_stack = active_stack.new_block(title=active_stack.items.pop(), heavy=True)
                            indent_stacks.append(active_stack)
                        # >>>
                        continue
                    else:
                        del indent_stacks[indent + 1 : ]
                        active_stack = indent_stacks[-1]

                if align is None:
                    cprop_OUTPUT(active_stack, crna)
                else:
                    if align == "full":
                        cprop_OUTPUT(active_stack, crna, text="")
                        o = active_stack.items[-1]
                        o.r_button_width = r_button_width_str_title_full
                        o.set_align("FULL")
                    elif align == "fit":
                        cprop_OUTPUT(active_stack, crna)
                        o = active_stack.items[-1]
                        o.r_button_width = r_button_width_str_title_fit
                        o.set_align("FULL")
                    else:
                        cprop_OUTPUT(active_stack, crna)

                if sep is None: pass
                else:
                    active_stack.sep(sep)
            else:
                cprop_OUTPUT(active_stack, crna)

    return is_dirty_inputs is True or is_dirty_outputs is True or is_dirty_panels is True
    #|
def is_gn_rna_dirty_no_layout(self, md, items_stacks, uianim, uianim_output, uianim_panel, old_crna_panels):
    crna_inputs = []
    crna_outputs = []
    crna_panels = []
    crna_panels_item = []

    for rna in md.node_group.interface.items_tree:
        if rna.item_type == "PANEL":
            crna_panels.append(r_crna_Panel(md, rna))
            crna_panels_item.append([D_crna[e.bl_socket_idname](md, e)  for e in rna.interface_items  if e.bl_socket_idname in D_crna and not e.hide_in_modifier])
            continue

        if rna.parent.parent is None:
            if rna.in_out == "INPUT":
                if rna.bl_socket_idname in D_crna:
                    if rna.hide_in_modifier: continue

                    crna_inputs.append(D_crna[rna.bl_socket_idname](md, rna))
            else:
                if rna.bl_socket_idname in S_crna_output:
                    crna_outputs.append(r_crna_Output(md, rna))

    if len(crna_inputs) == len(uianim.props):
        is_dirty_inputs = any(D_crna_compare[crna.type](crna, button.rna) is False  for crna, button in zip(crna_inputs, uianim.props.values()))
    else:
        is_dirty_inputs = True
    if is_dirty_inputs is True:
        b1 = items_stacks[1]
        uianim.props.clear()
        b1.items.clear()
        indent_stacks = [b1]
        active_stack = b1

        for crna in crna_inputs:
            D_cprop[crna.type](active_stack, crna)


    if len(crna_panels) == len(old_crna_panels):
        is_dirty_panels = any(crna_compare_STRING(crna, old) is False  for crna, old in zip(crna_panels, old_crna_panels))

        if is_dirty_panels is False:
            is_dirty_panels = any(D_crna_compare[crna.type](crna, button.rna) is False  for crna, button in zip(sum(crna_panels_item, []), uianim_panel.props.values()))
    else:
        is_dirty_panels = True
    if is_dirty_panels is True:
        old_crna_panels[:] = crna_panels
        uianim_panel.props.clear()
        ui = Ui(self)
        self.items += [items_stacks[0].w, items_stacks[1].w]
        ui.set_pp_from(uianim_panel)

        for panel, crnas in zip(crna_panels, crna_panels_item):
            ui.set_fold_state(panel.is_input)
            b1 = ui.new_block(title=panel.name, heavy=True)
            indent_stacks = [b1]
            active_stack = b1

            for crna in crnas:
                D_cprop[crna.type](active_stack, crna)

        self.items += [e.w  for e in items_stacks[2 : ]]


    if len(crna_outputs) == len(uianim_output.props):
        is_dirty_outputs = any(crna_compare_STRING(crna, button.rna) is False  for crna, button in zip(crna_outputs, uianim_output.props.values()))
    else:
        is_dirty_outputs = True
    if is_dirty_outputs is True:
        b2 = items_stacks[2]
        uianim_output.props.clear()
        b2.items.clear()
        indent_stacks = [b2]
        active_stack = b2

        for crna in crna_outputs:
            cprop_OUTPUT(active_stack, crna)

    return is_dirty_inputs is True or is_dirty_outputs is True or is_dirty_panels is True
    #|

#_c4#_c4#_c4#_c4

def c_set_pref(self, v, refresh=True, undo_push=True):
    # <<< 1copy (0defuiSetDriverEval,, $$)
    if isinstance(v, str):
        # v = v.strip()
        if v.startswith("#"):
            v = v[1 : ]
            if v.startswith("#"): pass
            else:
                self.evt_add_driver(exp=v, replace=True)
                return
        elif v.startswith(";"):
            v = v[1 : ]
            if v.startswith(";"): pass
            else:
                v = bpyeval(v)
    # >>>

    oldvalue = getattr(self.pp, self.identifier)
    setattr(self.pp, self.identifier, v)

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_data()

    if undo_push:
        # /* 0block_set_pref_undo_push
        newvalue = getattr(self.pp, self.identifier)
        if oldvalue == newvalue: return

        PREF_HISTORY.push_context = HistoryValue(oldvalue, newvalue,
            lambda v: self.set(v, refresh=True, undo_push=False),
            self.rna.name)
        PREF_HISTORY.push()
        # */
    #|
def c_set_vec_pref(self, v, index, refresh=True, undo_push=True):
    if isinstance(index, int):
        if isinstance(v, str):
            v = v.strip()
            if v.startswith("#"):
                self.evt_add_driver(index=index, exp=v[1 :], replace=True)
                return
            elif v.startswith(";"):
                v = v[1 : ]
                if v.startswith(";"): pass
                else:
                    v = bpyeval(v)
    else:
        if isinstance(v[0], str) and v[0].startswith("#"):
            i = index[0]
            for v in v:
                self.evt_add_driver(index=i, exp=v[1 :], replace=True)
                i += 1
            return

    array = getattr(self.pp, self.identifier)
    oldvalue = list(array)

    if isinstance(index, int): array[index] = v
    else:
        l = list(array)
        l[index[0] : index[1]] = v
        array[:] = l
        # crash when array is EULER
        # array[index[0] : index[1]] = v

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_data()

    if undo_push:
        newvalue = list(array)
        if oldvalue == newvalue: return

        PREF_HISTORY.push_context = HistoryValue(oldvalue, newvalue,
            lambda v: self.set(v, (0, len(newvalue)), refresh=True, undo_push=False),
            self.rna.name)
        PREF_HISTORY.push()
    #|
def c_set_enum_pref(self, v, refresh=True, undo_push=True): # ALlow INput NAme, NonE
    # <<< 1copy (0defuiSetDriverEval,, $$)
    if isinstance(v, str):
        # v = v.strip()
        if v.startswith("#"):
            v = v[1 : ]
            if v.startswith("#"): pass
            else:
                self.evt_add_driver(exp=v, replace=True)
                return
        elif v.startswith(";"):
            v = v[1 : ]
            if v.startswith(";"): pass
            else:
                v = bpyeval(v)
    # >>>

    rna = self.rna

    if v in self.enum_items:
        oldvalue = getattr(self.pp, self.identifier)
        setattr(self.pp, self.identifier, v)

        if hasattr(self, "set_callback"):
            ret = self.set_callback()
            if ret is True: return
            if ret is False: refresh = False

        if refresh: update_data()

        if undo_push:
            # <<< 1copy (0block_set_pref_undo_push,, $$)
            newvalue = getattr(self.pp, self.identifier)
            if oldvalue == newvalue: return

            PREF_HISTORY.push_context = HistoryValue(oldvalue, newvalue,
                lambda v: self.set(v, refresh=True, undo_push=False),
                self.rna.name)
            PREF_HISTORY.push()
            # >>>
    else:
        if v == None:
            if hasattr(rna, "is_never_none") and rna.is_never_none: return
        else:
            for e in self.enum_items:
                if e.name == v:
                    oldvalue = getattr(self.pp, self.identifier)
                    setattr(self.pp, self.identifier, e.identifier)

                    if hasattr(self, "set_callback"):
                        ret = self.set_callback()
                        if ret is True: return
                        if ret is False: refresh = False

                    if refresh: update_data()

                    if undo_push:
                        # <<< 1copy (0block_set_pref_undo_push,, $$)
                        newvalue = getattr(self.pp, self.identifier)
                        if oldvalue == newvalue: return

                        PREF_HISTORY.push_context = HistoryValue(oldvalue, newvalue,
                            lambda v: self.set(v, refresh=True, undo_push=False),
                            self.rna.name)
                        PREF_HISTORY.push()
                        # >>>
                    return
    #|
def c_set_str_pref(self, v, refresh=True, undo_push=True):
    if isinstance(v, str):
        if v.startswith(";"):
            v = v[1 : ]
            if v.startswith(";"): pass
            else:
                v = bpyeval(v)

    oldvalue = getattr(self.pp, self.identifier)
    setattr(self.pp, self.identifier, v)

    if hasattr(self, "set_callback"):
        ret = self.set_callback()
        if ret is True: return
        if ret is False: refresh = False

    if refresh: update_data()

    if undo_push:
        # <<< 1copy (0block_set_pref_undo_push,, $$)
        newvalue = getattr(self.pp, self.identifier)
        if oldvalue == newvalue: return

        PREF_HISTORY.push_context = HistoryValue(oldvalue, newvalue,
            lambda v: self.set(v, refresh=True, undo_push=False),
            self.rna.name)
        PREF_HISTORY.push()
        # >>>
    #|

@ assign(
    set = c_set_pref)
@ toPref
class BuBoolPref(BuBool): __slots__ = ()

@ assign(
    set = c_set_pref)
@ toPref
class BuIntPref(BuInt): __slots__ = ()

@ assign(
    set = c_set_pref)
@ toPref
class BuFloatPref(BuFloat): __slots__ = ()

@ assign(
    set = c_set_vec_pref)
@ toPref
class BuIntVecPref(BuIntVec): __slots__ = ()

@ assign(
    set = c_set_vec_pref)
@ toPref
class BuFloatVecPref(BuFloatVec): __slots__ = ()

@ assign(
    set = c_set_vec_pref)
@ toPref
class BuIntVecSubPref(BuIntVecSub): __slots__ = ()

@ assign(
    set = c_set_vec_pref)
@ toPref
class BuFloatVecSubPref(BuFloatVecSub): __slots__ = ()

@ assign(
    set = c_set_enum_pref)
@ toPref
class BuEnumPref(BuEnum): __slots__ = ()

@ assign(
    set = c_set_str_pref)
@ toPref
class BuStrPref(BuStr): __slots__ = ()

@ assign(
    set = c_set_str_pref)
@ toPref
class BuStrFilePref(BuStrFile): __slots__ = ()

@ assign(
    set = c_set_vec_pref)
@ toPref
class BuColorPref(BuColorNoAnim):
    __slots__ = ()

    def to_dropdown(self):

        self.pp = self.r_pp()

        ddw = DropDownBuColor(self)

        oldvalue = list(self.get())
        ddw.data["fin_callfront"] = lambda: self.set(oldvalue, (0, len(oldvalue)), refresh=False, undo_push=False)
        #|
    #|
#_c4#_c4#_c4#_c4

class UiAnimData:
    __slots__ = (
        'fcurves',
        'drivers',
        'pp',
        'pp_ref',
        'pp_name',
        'library_state',
        'r_pp',
        'r_pp_ref',
        'props',
        'rnas',
        'dph',
        'r_dph')

    def __init__(self, r_pp, r_pp_ref, r_dph, rnas):
        self.fcurves = None
        self.drivers = None
        self.pp = r_pp()
        self.pp_ref = None
        self.pp_name = ""
        self.library_state = 0
        self.r_pp = r_pp
        self.r_pp_ref = r_pp_ref
        self.props = {}
        self.rnas = rnas
        self.r_dph = r_dph
        #|

    def tag_update(self):
        self.library_state = -2
        #|

    def update_with(self, fn_darklight):
        # /* 0defUiAnimData_update
        fcurves = None
        drivers = None
        pp = self.r_pp()

        if pp:
            self.pp = pp
            self.dph = self.r_dph()
            if hasattr(pp, "name"):
                self.pp_name = pp.name

            if self.library_state == -1:

                for e in self.props.values():
                    e.isdarkhard = e.isdarkhard_prev
        else:
            self.pp = None
            self.dph = "-1"

            if self.library_state != -1:
                self.library_state = -1

                for e in self.props.values():
                    e.pp = None
                    e.isdarkhard = True
                    e.dark()
                    e.dark_anim()

            fn_darklight(None)
            return True

        ob = pp.id_data

        if hasattr(ob, "animation_data"):
            animation_data = ob.animation_data
            if hasattr(animation_data, "action"):
                if hasattr(animation_data.action, "fcurves"):
                    fcurves = animation_data.action.fcurves
            if hasattr(animation_data, "drivers"):
                drivers = animation_data.drivers

        if fcurves is None:
            self.fcurves = {}
        else:
            self.fcurves = {e.data_path  if e.array_index == 0 else (e.data_path, e.array_index): e  for e in fcurves}
        if drivers is None:
            self.drivers = {}
        else:
            self.drivers = {e.data_path  if e.array_index == 0 else (e.data_path, e.array_index): e  for e in drivers}

        if ob.library:
            if self.library_state != 1:
                self.library_state = 1
                self.pp_ref = None
                for e in self.props.values():
                    e.set_ui_state_link()

        elif ob.override_library:
            if ob.override_library.is_system_override:
                if self.library_state != 1:
                    self.library_state = 1
                    self.pp_ref = None
                    for e in self.props.values():
                        e.set_ui_state_link()

            else:
                self.pp_ref = self.r_pp_ref()

                if self.library_state != 2:
                    self.library_state = 2
                    for e in self.props.values():
                        e.set_ui_state_overridden()

        else:
            if self.library_state != 0:
                self.library_state = 0
                self.pp_ref = None
                for e in self.props.values():
                    e.set_ui_state_default()


        if fn_darklight(pp) is True: return True

        for e in self.props.values():
            e.pp = pp
            e.upd_data()
        # */
    #|
    #|
class Ui:
    __slots__ = (
        'w',
        'items',
        'props',
        'rnas',
        'r_pp',
        'ui_anim_data')

    def __init__(self, w):
        self.w = w
        items = w.items  if hasattr(w, "items") else w.buttons
        items.clear()
        self.items = items
        #|

    def set_fold_state(self, boo):
        BlockUtil.DEFAULT_FOLD_STATE = boo
        #|

    def new_block(self, title=None, heavy=False):
        if title is None:
            e = Blocks(self.w)
            e.buttons = []
        else:
            if isinstance(title, str):
                e = (BlockUtilHeavy  if heavy is True else BlockUtil)(self.w, [], title=title)
            elif isinstance(title, list):
                e = BlockUtils(self.w, [], title)
            else:
                e = (BlockUtilHeavy  if heavy is True else BlockUtil)(self.w, [], title)

        self.items.append(e)
        if hasattr(self, "r_pp"):
            new_ui = Ui(e)
            new_ui.r_pp = self.r_pp
            new_ui.rnas = self.rnas
            new_ui.ui_anim_data = self.ui_anim_data
            new_ui.props = self.props
            return new_ui
        return Ui(e)
        #|

    def set_pp(self, r_pp, bl_cls=None, r_dph=None):
        self.r_pp = r_pp

        if r_dph is None: pass
        else:
            self.rnas = bl_cls.bl_rna.properties
            self.an_dph(r_pp, r_dph)
            return self.ui_anim_data

        if bl_cls is None:
            pp = r_pp()
            self.rnas = pp.bl_rna.properties

            if pp.id_data is pp:
                self.an_Object(r_pp)
            else:
                if isinstance(pp, bpytypes.Modifier):
                    self.an_Modifier(r_pp)
                else:
                    TODO
        else:
            self.rnas = bl_cls.bl_rna.properties

            getattr(self, f'an_{bl_cls.__name__}')(r_pp)

        return self.ui_anim_data
        #|
    def set_pp_id_data(self, r_pp, bl_cls=None):
        self.r_pp = r_pp
        if bl_cls is None:
            self.rnas = r_pp().bl_rna.properties
        else:
            self.rnas = bl_cls.bl_rna.properties
        self.an_Object(r_pp)
        return self.ui_anim_data
        #|

    def set_pp_from(self, ui_anim_data):
        self.ui_anim_data = ui_anim_data
        self.r_pp = ui_anim_data.r_pp
        self.rnas = ui_anim_data.rnas
        self.props = ui_anim_data.props
        #|

    def an_dph(self, r_pp, r_dph):
        def r_pp_ref():
            try:
                return r_pp().id_data.override_library.reference.path_resolve(r_dph())
            except:
                return None

        ui_anim_data = UiAnimData(r_pp, r_pp_ref, r_dph, self.rnas)

        self.ui_anim_data = ui_anim_data
        self.props = ui_anim_data.props
        #|
    def an_Modifier(self, r_pp):
        def r_pp_ref():
            _pp = r_pp()
            ref_modifiers = _pp.id_data.override_library.reference.modifiers
            if _pp.name in ref_modifiers:
                return ref_modifiers[_pp.name]
            return None

        def r_dph(): return f'modifiers["{escape_identifier(ui_anim_data.pp_name)}"]'

        ui_anim_data = UiAnimData(r_pp, r_pp_ref, r_dph, self.rnas)

        self.ui_anim_data = ui_anim_data
        self.props = ui_anim_data.props
        #|
    def an_Object(self, r_pp):
        def r_pp_ref():
            return r_pp().override_library.reference

        ui_anim_data = UiAnimData(r_pp, r_pp_ref, NS, self.rnas)

        self.ui_anim_data = ui_anim_data
        self.props = ui_anim_data.props
        #|

    def prop(self, attr, text=None, isdarkhard=False, options={}):
        # /* 0defUi_prop
        rna = self.rnas[attr]
        group = None

        ty = rna.type
        if ty == "INT":
            if rna.is_array:
                out = (BuIntVec  if rna.is_animatable else BuIntVecNoAnim)(
                    self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)

                out.init_bat = out.init_bat_anim
            else:
                out = (BuInt  if rna.is_animatable else BuIntNoAnim)(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
        elif ty == "FLOAT":
            if rna.is_array:
                if rna.subtype in D_subtype_display:
                    out = (BuFloatVecSub  if rna.is_animatable else BuFloatVecSubNoAnim)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                    out.init_subtype(D_subtype_display[rna.subtype])
                    out.init_bat = out.init_bat_anim
                else:
                    if rna.subtype == "COLOR":
                        out = (BuColor  if rna.is_animatable else BuColorNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard,
                            options["COLOR_SPACE"]  if "COLOR_SPACE" in options else "Scene Linear")

                        if rna.array_length == 3:
                            out.init_bat = out.init_bat_anim_3
                        else:
                            out.init_bat = out.init_bat_anim_4
                    elif rna.subtype == "COLOR_GAMMA":
                        out = (BuColor  if rna.is_animatable else BuColorNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard,
                            options["COLOR_SPACE"]  if "COLOR_SPACE" in options else "sRGB")

                        if rna.array_length == 3:
                            out.init_bat = out.init_bat_anim_3
                        else:
                            out.init_bat = out.init_bat_anim_4
                    elif rna.subtype == "STRING_VECTOR":
                        out = BuStrVec(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                        out.init_bat = out.init_bat_anim
                    else:
                        out = (BuFloatVec  if rna.is_animatable else BuFloatVecNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)

                        out.init_bat = out.init_bat_anim
            else:
                out = (BuFloat  if rna.is_animatable else BuFloatNoAnim)(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
        elif ty == "BOOLEAN":
            if rna.is_array:
                array_length = rna.array_length
                if "NAMES" in options:
                    enum_items = [Name(e)  for e in options["NAMES"]]

                    out = (BuBoolVecFlag  if rna.is_animatable else TODO)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard, enum_items,
                        (options["ROW_LENGTH"]  if "ROW_LENGTH" in options else array_length))
                    out.array_length = array_length
                    out.vec_range = range(array_length)
                    out.init_bat = out.init_bat_anim
                else:
                    out = (BuBoolVec  if rna.is_animatable else TODO)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                    out.init_subtype([str(r)  for r in out.vec_range])
                    out.init_bat = out.init_bat_anim
            else:
                if "icon_cls" in options:
                    out = (BuBoolIcon  if rna.is_animatable else BuBoolIconNoAnim)(
                        self.w, rna, self.r_pp, self.ui_anim_data, isdarkhard, options["icon_cls"])

                    out.init_bat = out.init_bat_anim
                else:
                    if isinstance(text, tuple):
                        texthead, text = text
                        out = (BuBool  if rna.is_animatable else BuBoolNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)

                        out.init_bat = out.init_bat_animR
                        group = ButtonOverlayTitle(self.w, TitleR(texthead), out)
                    else:
                        out = (BuBool  if rna.is_animatable else BuBoolNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)

                        if "FLIP" in options:
                            out.init_bat = out.init_bat_anim
                        elif "HEAD" in options:
                            out.init_bat = out.init_bat_animH
                        else:
                            out.init_bat = out.init_bat_animR
        elif ty == "STRING":
            if rna.subtype == "NONE":
                out = BuStr(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
            elif rna.subtype in {"DIR_PATH", "FILE_PATH"}:
                out = BuStrFile(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.box_icon_arrow = GpuImg_FILE_FOLDER()
                out.init_bat = out.init_bat_anim
            elif rna.subtype == "SEARCH":
                out = BuStrMatch(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init()
                out.init_bat = out.init_bat_anim_FULL
            else:
                out = BuStr(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
        elif ty == "ENUM":
            if rna.is_enum_flag:
                enum_items = rna.enum_items
                out = (BuEnumFlag  if rna.is_animatable else BuEnumFlagNoAnim)(
                    self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard, enum_items,
                    (options["ROW_LENGTH"]  if "ROW_LENGTH" in options else len(enum_items)))
                out.init_bat = out.init_bat_anim
            else:
                if "D_icon" in options:
                    out = (BuEnumIcon  if rna.is_animatable else BuEnumIconNoAnim)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                    out.box_icon_arrow = GpuImg_unfold()
                    out.enum_items = rna.enum_items
                    out.box_icon = GpuImgNull()
                    out.init_bat = out.init_bat_anim
                    out.D_icon = options["D_icon"]
                else:
                    out = (BuEnum  if rna.is_animatable else BuEnumNoAnim)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                    out.box_icon_arrow = GpuImg_unfold()
                    out.enum_items = rna.enum_items
                    out.init_bat = out.init_bat_anim
        elif ty == "POINTER":
            if "r_items" in options:
                fixed_type = rna.fixed_type
                out = BuPointer(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.fixed_idtype = True
                out.box_icon_arrow = GpuImg_unfold()
                out.init_bat = out.init_bat_anim
                out.r_items = options["r_items"]

                if isinstance(fixed_type, ShapeKey):
                    out.icon_cls = GpuImg_SHAPEKEY
                    out.box_icon = GpuImg_SHAPEKEY()
                elif isinstance(fixed_type, ParticleSystem):
                    out.icon_cls = GpuImg_PARTICLE_SYSTEM
                    out.box_icon = GpuImg_PARTICLE_SYSTEM()
                else:

                    TODO

                out.update_icon()
            elif "RICH" in options:
                out = D_riches[options["RICH"]](self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
            else:
                IDs = options["ID"]
                if isinstance(IDs, set):
                    TODO
                else:
                    r_pp = self.r_pp
                    out = BuID(self.w, rna, r_pp, self.ui_anim_data, text, isdarkhard)
                    out.idtype = IDs
                    if "TYPES" in options:
                        out.allow_types = options["TYPES"]
                    else:
                        out.allow_types = None
                    out.fixed_idtype = True
                    out.r_except_objects = lambda: {r_pp().id_data}
                    out.box_icon_arrow = GpuImg_unfold()
                    out.box_icon = GpuImgNull()
                    out.init_bat = out.init_bat_anim
                    out.update_icon()
        else:
            TODO

        self.props[attr] = out
        # */
        if group is None:
            self.items.append(out)
        else:
            self.items.append(group)
        #|
    def r_prop(self, attr, text=None, isdarkhard=False, options={}):
        # <<< 1copy (0defUi_prop,, $$)
        rna = self.rnas[attr]
        group = None

        ty = rna.type
        if ty == "INT":
            if rna.is_array:
                out = (BuIntVec  if rna.is_animatable else BuIntVecNoAnim)(
                    self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)

                out.init_bat = out.init_bat_anim
            else:
                out = (BuInt  if rna.is_animatable else BuIntNoAnim)(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
        elif ty == "FLOAT":
            if rna.is_array:
                if rna.subtype in D_subtype_display:
                    out = (BuFloatVecSub  if rna.is_animatable else BuFloatVecSubNoAnim)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                    out.init_subtype(D_subtype_display[rna.subtype])
                    out.init_bat = out.init_bat_anim
                else:
                    if rna.subtype == "COLOR":
                        out = (BuColor  if rna.is_animatable else BuColorNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard,
                            options["COLOR_SPACE"]  if "COLOR_SPACE" in options else "Scene Linear")

                        if rna.array_length == 3:
                            out.init_bat = out.init_bat_anim_3
                        else:
                            out.init_bat = out.init_bat_anim_4
                    elif rna.subtype == "COLOR_GAMMA":
                        out = (BuColor  if rna.is_animatable else BuColorNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard,
                            options["COLOR_SPACE"]  if "COLOR_SPACE" in options else "sRGB")

                        if rna.array_length == 3:
                            out.init_bat = out.init_bat_anim_3
                        else:
                            out.init_bat = out.init_bat_anim_4
                    elif rna.subtype == "STRING_VECTOR":
                        out = BuStrVec(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                        out.init_bat = out.init_bat_anim
                    else:
                        out = (BuFloatVec  if rna.is_animatable else BuFloatVecNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)

                        out.init_bat = out.init_bat_anim
            else:
                out = (BuFloat  if rna.is_animatable else BuFloatNoAnim)(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
        elif ty == "BOOLEAN":
            if rna.is_array:
                array_length = rna.array_length
                if "NAMES" in options:
                    enum_items = [Name(e)  for e in options["NAMES"]]

                    out = (BuBoolVecFlag  if rna.is_animatable else TODO)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard, enum_items,
                        (options["ROW_LENGTH"]  if "ROW_LENGTH" in options else array_length))
                    out.array_length = array_length
                    out.vec_range = range(array_length)
                    out.init_bat = out.init_bat_anim
                else:
                    out = (BuBoolVec  if rna.is_animatable else TODO)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                    out.init_subtype([str(r)  for r in out.vec_range])
                    out.init_bat = out.init_bat_anim
            else:
                if "icon_cls" in options:
                    out = (BuBoolIcon  if rna.is_animatable else BuBoolIconNoAnim)(
                        self.w, rna, self.r_pp, self.ui_anim_data, isdarkhard, options["icon_cls"])

                    out.init_bat = out.init_bat_anim
                else:
                    if isinstance(text, tuple):
                        texthead, text = text
                        out = (BuBool  if rna.is_animatable else BuBoolNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)

                        out.init_bat = out.init_bat_animR
                        group = ButtonOverlayTitle(self.w, TitleR(texthead), out)
                    else:
                        out = (BuBool  if rna.is_animatable else BuBoolNoAnim)(
                            self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)

                        if "FLIP" in options:
                            out.init_bat = out.init_bat_anim
                        elif "HEAD" in options:
                            out.init_bat = out.init_bat_animH
                        else:
                            out.init_bat = out.init_bat_animR
        elif ty == "STRING":
            if rna.subtype == "NONE":
                out = BuStr(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
            elif rna.subtype in {"DIR_PATH", "FILE_PATH"}:
                out = BuStrFile(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.box_icon_arrow = GpuImg_FILE_FOLDER()
                out.init_bat = out.init_bat_anim
            elif rna.subtype == "SEARCH":
                out = BuStrMatch(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init()
                out.init_bat = out.init_bat_anim_FULL
            else:
                out = BuStr(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
        elif ty == "ENUM":
            if rna.is_enum_flag:
                enum_items = rna.enum_items
                out = (BuEnumFlag  if rna.is_animatable else BuEnumFlagNoAnim)(
                    self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard, enum_items,
                    (options["ROW_LENGTH"]  if "ROW_LENGTH" in options else len(enum_items)))
                out.init_bat = out.init_bat_anim
            else:
                if "D_icon" in options:
                    out = (BuEnumIcon  if rna.is_animatable else BuEnumIconNoAnim)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                    out.box_icon_arrow = GpuImg_unfold()
                    out.enum_items = rna.enum_items
                    out.box_icon = GpuImgNull()
                    out.init_bat = out.init_bat_anim
                    out.D_icon = options["D_icon"]
                else:
                    out = (BuEnum  if rna.is_animatable else BuEnumNoAnim)(
                        self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                    out.box_icon_arrow = GpuImg_unfold()
                    out.enum_items = rna.enum_items
                    out.init_bat = out.init_bat_anim
        elif ty == "POINTER":
            if "r_items" in options:
                fixed_type = rna.fixed_type
                out = BuPointer(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
                out.fixed_idtype = True
                out.box_icon_arrow = GpuImg_unfold()
                out.init_bat = out.init_bat_anim
                out.r_items = options["r_items"]

                if isinstance(fixed_type, ShapeKey):
                    out.icon_cls = GpuImg_SHAPEKEY
                    out.box_icon = GpuImg_SHAPEKEY()
                elif isinstance(fixed_type, ParticleSystem):
                    out.icon_cls = GpuImg_PARTICLE_SYSTEM
                    out.box_icon = GpuImg_PARTICLE_SYSTEM()
                else:

                    TODO

                out.update_icon()
            elif "RICH" in options:
                out = D_riches[options["RICH"]](self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
            else:
                IDs = options["ID"]
                if isinstance(IDs, set):
                    TODO
                else:
                    r_pp = self.r_pp
                    out = BuID(self.w, rna, r_pp, self.ui_anim_data, text, isdarkhard)
                    out.idtype = IDs
                    if "TYPES" in options:
                        out.allow_types = options["TYPES"]
                    else:
                        out.allow_types = None
                    out.fixed_idtype = True
                    out.r_except_objects = lambda: {r_pp().id_data}
                    out.box_icon_arrow = GpuImg_unfold()
                    out.box_icon = GpuImgNull()
                    out.init_bat = out.init_bat_anim
                    out.update_icon()
        else:
            TODO

        self.props[attr] = out
        # >>>
        return out
        #|

    def prop_flag(self, attr, text=None, isdarkhard=False, options={}):
        # /* 0defUi_prop_flag
        if isinstance(attr, list):
            rnas = self.rnas
            rna = rnas[attr[0]]
        else:
            rna = self.rnas[attr]

        ty = rna.type
        if ty == "BOOLEAN":
            row_length = options["ROW_LENGTH"]  if "ROW_LENGTH" in options else len(attr)

            out = (BuBoolFlag  if rna.is_animatable else BuBoolFlagNoAnim)(
                self.w, [rnas[att]  for att in attr], self.r_pp, self.ui_anim_data, text, isdarkhard, options["NAMES"], row_length)
            out.init_bat = out.init_bat_anim

            self.props[attr[0]] = out

        elif ty == "ENUM":
            enum_items = rna.enum_items

            out = (BuEnumXY  if rna.is_animatable else BuEnumXYNoAnim)(
                self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard, enum_items,
                (options["ROW_LENGTH"]  if "ROW_LENGTH" in options else len(enum_items)))
            out.init_bat = out.init_bat_anim

            self.props[attr] = out
        else:
            TODO

        # */
        self.items.append(out)
        #|
    def r_prop_flag(self, attr, text=None, isdarkhard=False, options={}):
        # <<< 1copy (0defUi_prop_flag,, $$)
        if isinstance(attr, list):
            rnas = self.rnas
            rna = rnas[attr[0]]
        else:
            rna = self.rnas[attr]

        ty = rna.type
        if ty == "BOOLEAN":
            row_length = options["ROW_LENGTH"]  if "ROW_LENGTH" in options else len(attr)

            out = (BuBoolFlag  if rna.is_animatable else BuBoolFlagNoAnim)(
                self.w, [rnas[att]  for att in attr], self.r_pp, self.ui_anim_data, text, isdarkhard, options["NAMES"], row_length)
            out.init_bat = out.init_bat_anim

            self.props[attr[0]] = out

        elif ty == "ENUM":
            enum_items = rna.enum_items

            out = (BuEnumXY  if rna.is_animatable else BuEnumXYNoAnim)(
                self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard, enum_items,
                (options["ROW_LENGTH"]  if "ROW_LENGTH" in options else len(enum_items)))
            out.init_bat = out.init_bat_anim

            self.props[attr] = out
        else:
            TODO

        # >>>
        return out
        #|

    def prop_search(self, attr, icon_cls, r_items, text=None, isdarkhard=False, pollred=True, options={}):
        # /* 0defUi_prop_search
        rna = self.rnas[attr]

        if rna.type == "STRING":
            out = BuStrSearch(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
            out.init_bat = out.init_bat_anim
            out.enum_items = r_items
            out.pollred = pollred
            out.box_icon_arrow = GpuImg_unfold()
            out.box_icon = icon_cls()
            out.box_icon_cls = icon_cls
        else:
            TODO

        self.props[attr] = out
        # */
        self.items.append(out)
        #|
    def r_prop_search(self, attr, icon_cls, r_items, text=None, isdarkhard=False, pollred=True, options={}):
        # <<< 1copy (0defUi_prop_search,, $$)
        rna = self.rnas[attr]

        if rna.type == "STRING":
            out = BuStrSearch(self.w, rna, self.r_pp, self.ui_anim_data, text, isdarkhard)
            out.init_bat = out.init_bat_anim
            out.enum_items = r_items
            out.pollred = pollred
            out.box_icon_arrow = GpuImg_unfold()
            out.box_icon = icon_cls()
            out.box_icon_cls = icon_cls
        else:
            TODO

        self.props[attr] = out
        # >>>
        return out
        #|

    def prop_inv(self, attr_inv, attr, text=None, isdarkhard=False, options={}):
        r_pp = self.r_pp
        rna_inv = self.rnas[attr_inv]
        o_inv = (BuBoolIcon  if rna_inv.is_animatable else BuBoolIconNoAnim)(
            self.w, rna_inv, r_pp, self.ui_anim_data, isdarkhard, GpuImg_invert)
        o_inv.init_bat = o_inv.init_bat_anim

        IDs = options["ID"]
        if isinstance(IDs, set):
            TODO
        else:
            out = BuIDNoArrow(self.w, self.rnas[attr], r_pp, self.ui_anim_data, text, isdarkhard)
            out.idtype = IDs
            if "TYPES" in options:
                out.allow_types = options["TYPES"]
            else:
                out.allow_types = None
            out.fixed_idtype = True
            out.r_except_objects = lambda: {r_pp().id_data}
            out.box_icon = GpuImgNull()
            out.init_bat = out.init_bat_anim
            out.update_icon()

        self.props[attr] = out
        self.props[attr_inv] = o_inv
        self.items.append(ButtonOverlay(self.w, out, o_inv))
        #|
    def prop_inv_vg(self, attr_inv, attr_vg, r_vertex_groups, text=None, isdarkhard=False, pollred=True):
        r_pp = self.r_pp
        rna_inv = self.rnas[attr_inv]
        o_inv = (BuBoolIcon  if rna_inv.is_animatable else BuBoolIconNoAnim)(
            self.w, rna_inv, r_pp, self.ui_anim_data, isdarkhard, GpuImg_invert)
        o_inv.init_bat = o_inv.init_bat_anim

        o_vg = BuStrSearchNoArrow(self.w, self.rnas[attr_vg], r_pp, self.ui_anim_data, text, isdarkhard)
        o_vg.init_bat = o_vg.init_bat_anim
        o_vg.enum_items = r_vertex_groups
        o_vg.pollred = pollred
        o_vg.box_icon = GpuImg_GROUP_VERTEX()
        o_vg.box_icon_cls = GpuImg_GROUP_VERTEX

        self.props[attr_vg] = o_vg
        self.props[attr_inv] = o_inv
        self.items.append(ButtonOverlay(self.w, o_vg, o_inv))
        #|
    def prop_inv_search(self, attr_inv, attr, icon_cls, r_items, text=None, isdarkhard=False, pollred=True):
        r_pp = self.r_pp
        rna_inv = self.rnas[attr_inv]
        o_inv = (BuBoolIcon  if rna_inv.is_animatable else BuBoolIconNoAnim)(
            self.w, rna_inv, r_pp, self.ui_anim_data, isdarkhard, GpuImg_invert)
        o_inv.init_bat = o_inv.init_bat_anim

        o_vg = BuStrSearchNoArrow(self.w, self.rnas[attr], r_pp, self.ui_anim_data, text, isdarkhard)
        o_vg.init_bat = o_vg.init_bat_anim
        o_vg.enum_items = r_items
        o_vg.pollred = pollred
        o_vg.box_icon = icon_cls()
        o_vg.box_icon_cls = icon_cls

        self.props[attr] = o_vg
        self.props[attr_inv] = o_inv
        self.items.append(ButtonOverlay(self.w, o_vg, o_inv))
        #|
    def propY(self, attr, text, isdarkhard=False, r_gap=0):
        rnas = self.rnas
        r_pp = self.r_pp
        ui_anim_data = self.ui_anim_data
        props = self.props
        ty = rnas[attr[0]].type

        if ty == "BOOLEAN":
            g_buttons = []
            group = ButtonGroupY(self.w, g_buttons)

            for attr, text in zip(attr, text):
                rna = rnas[attr]
                out = (BuBoolJ  if rna.is_animatable else TODO)(
                    group, rna, r_pp, ui_anim_data, text, isdarkhard)
                out.init_bat = out.init_bat_anim
                g_buttons.append(out)
                props[attr] = out
        else:
            TODO

        self.items.append(group)
        #|
    def join_prop(self, attr, text=None, isdarkhard=False, options={}):
        out = self.r_prop(attr, text, isdarkhard, options)

        if type(self.items[-1]) is ButtonJoinColumn:
            group = self.items[-1]
            out.w = group
            group.buttons.append(out)
        else:
            group = ButtonJoinColumn(self.w, None)
            out.w = group
            e = self.items.pop()
            e.w = group
            group.buttons = [e, out]
            self.items.append(group)
        #|
    def join_bool(self, attr, text=None, isdarkhard=False, options={}):
        rna = self.rnas[attr]
        r_pp = self.r_pp
        out = (BuBoolJ  if rna.is_animatable else TODO)(
            None, rna, r_pp, self.ui_anim_data, text, isdarkhard)
        out.init_bat = out.init_bat_anim

        group = ButtonOverlay(self.w, out, self.items.pop())
        self.props[attr] = out
        self.items.append(group)
        #|
    def function(self, rna, fn, isdarkhard=False, options={}):
        # /* 0defUi_function
        if hasattr(rna, "__len__"):
            out = BuFunction2(self.w, rna, fn, isdarkhard)
            out.init_bat = out.init_bat_anim
        else:
            if "icon_cls" in options:
                out = BuFnImgHover(self.w, rna, fn, isdarkhard, options["icon_cls"], options["icon_cls_dark"])
                out.init_bat = out.init_bat_L
            else:
                out = BuFunction(self.w, rna, fn, isdarkhard)
                out.init_bat = out.init_bat_anim
        # */
        self.items.append(out)
        return out
        #|
    def r_function(self, rna, fn, isdarkhard=False, options={}):
        # <<< 1copy (0defUi_function,, $$)
        if hasattr(rna, "__len__"):
            out = BuFunction2(self.w, rna, fn, isdarkhard)
            out.init_bat = out.init_bat_anim
        else:
            if "icon_cls" in options:
                out = BuFnImgHover(self.w, rna, fn, isdarkhard, options["icon_cls"], options["icon_cls_dark"])
                out.init_bat = out.init_bat_L
            else:
                out = BuFunction(self.w, rna, fn, isdarkhard)
                out.init_bat = out.init_bat_anim
        # >>>
        return out
        #|
    def label(self, lines, align=""):
        # /* 0defUi_label
        if align.startswith("R"):
            out = BuLabelsR(self.w, lines, COL_block_fg)
            if align.endswith("1"):
                out.r_button_width = self.r_button_width_R1
        else:
            out = BuLabels(self.w, lines, COL_block_fg)
        # */
        self.items.append(out)
        return out
        #|
    def r_label(self, lines, align=""):
        # <<< 1copy (0defUi_label,, $$)
        if align.startswith("R"):
            out = BuLabelsR(self.w, lines, COL_block_fg)
            if align.endswith("1"):
                out.r_button_width = self.r_button_width_R1
        else:
            out = BuLabels(self.w, lines, COL_block_fg)
        # >>>
        return out
        #|
    def info(self, text):
        # /* 0defUi_info
        out = AreaStringPre(self.w, text)
        # */
        self.items.append(out)
        return out
        #|
    def r_info(self, text):
        # <<< 1copy (0defUi_info,, $$)
        out = AreaStringPre(self.w, text)
        # >>>
        return out
        #|

    def sep(self, factor=1.0):
        self.items.append(ButtonSep(factor))
        #|
    def overlay(self, button0, button1):
        out = ButtonOverlay(self.w, button0, button1)
        self.items.append(out)
        return out
        #|

    @ staticmethod
    def r_button_width_R1():
        return SIZE_widget[0] + SIZE_border[3] - D_SIZE['font_main_title_offset']
        #|
    @ staticmethod
    def r_button_width_FULL_1t():
        return SIZE_widget[0] + SIZE_block[1] + SIZE_border[3] * 2 - D_SIZE['font_main_title_offset']
        #|
    @ staticmethod
    def r_button_width_FULL_1():
        return SIZE_widget[0] + SIZE_block[1] + SIZE_border[3] * 2
        #|
    #|
    #|

def allot_callback(uiprops, attr, callback, option, drag_untag=False):
    button = uiprops[attr]
    _option = option.copy()
    _option["button"] = button

    if button.rna.is_array and button.rna.subtype != "STRING_VECTOR":
        def set_callback():
            try:
                callback(_option, button.get()[button.focus_element[0]])
            except:
                pass

            return False
    else:
        def set_callback():
            try:
                callback(_option, button.get())
            except:
                pass

            return False

    button.set_callback = set_callback
    if drag_untag is True:
        button.drag_untag()
    #|
def allot_callback_unpush(button):
    def set_callback():
        Admin.REDRAW()
        button.upd_data()
        return True

    button.set_callback = set_callback
    #|
def allot_inout_draw_view(button, fn_draw):
    appended = [False]
    def append_fn_draw():
        if appended[0] is False:
            draw_view_append(fn_draw)
            appended[0] = True
    def remove_fn_draw():
        if appended[0] is True:
            draw_view_remove(fn_draw)
            appended[0] = False

    button.inside_callback = append_fn_draw
    button.outside_callback = remove_fn_draw
    #|

def wrapper_push(fn, rna, push_method="", use_try=False):
    if use_try is True:
        def newfn():
            try:
                fn()
                if push_method == "PUSH":
                    ed_undo_push(message=f'{rna.name}')
                elif push_method == "UPDATE":
                    update_scene_push(rna.name)
                elif push_method == "MESH_EDIT":
                    object_mode_set("OBJECT")
                    object_mode_set("EDIT")
                    ed_undo_push(message=f'{rna.name}')
            except:
                pass

    else:
        def newfn():
            fn()
            if push_method == "PUSH":
                ed_undo_push(message=f'{rna.name}')
            elif push_method == "UPDATE":
                update_scene_push(rna.name)
            elif push_method == "MESH_EDIT":
                object_mode_set("OBJECT")
                object_mode_set("EDIT")
                ed_undo_push(message=f'{rna.name}')

    return newfn
    #|

#_c4#_c4#_c4#_c4

def dialog_override_create(self, ob):
    if hasattr(ob, "override_create"): pass
    else: return

    def button_fn_cancel(button=None):
        ddw.fin_from_area()
    def button_fn_confirm(button=None):
        ddw.fin_from_area()
        try:
            if pp.remap_local_usages:
                ob.override_create(remap_local_usages=True)
            else:
                self.set(ob.override_create(remap_local_usages=False), refresh=False, undo_push=False)

            update_scene_push("Override Create")
        except: pass

    gap = SIZE_button[1]
    area_items = []
    button_confirm = ButtonFn(None, RNA_confirm, button_fn_confirm)
    button_cancel = ButtonFn(None, RNA_cancel, button_fn_cancel)
    rna = PpOverrideCreate.bl_rna.properties["remap_local_usages"]

    ddw = DropDownInfoUtil(self, MOUSE,
        [ButtonSplit(None, button_confirm, button_cancel, gap)],
        area_items = area_items,
        title = "Override Create",
        input_text = f"{rna.name}\n    {rna.description}.",
        row_count = 4,
        width_fac = 2.0,
        block_size = 2,
        wrap_input = True)

    area_tab = ddw.r_area_tab()
    pp = PpOverrideCreate(area_tab)

    ui = Ui(area_tab)
    ui_anim_data = ui.set_pp(lambda: pp, PpOverrideCreate, NS)

    b0 = ui.new_block()
    b0.w.no_background()
    b0.prop("remap_local_usages")
    for e in ui_anim_data.props.values():
        allot_callback_unpush(e)
        e.upd_data()

    area_tab.init_items_tab()
    #|
def dialog_override_clear(self, ob):
    if hasattr(ob, "override_create"): pass
    else: return
    if hasattr(ob, "override_library") and ob.override_library: pass
    else: return

    def button_fn_cancel(button=None):
        ddw.fin_from_area()
    def button_fn_confirm(button=None):
        ddw.fin_from_area()
        reference = ob.override_library.reference
        if pp.remap_local_usages:
            ob.user_remap(reference)
        else:
            self.set(reference, refresh=False, undo_push=False)

        if pp.delete_unused:


            if ob.users == 0:
                ob.override_library.destroy()

        update_scene_push("Override Clear")

    gap = SIZE_button[1]
    area_items = []
    button_confirm = ButtonFn(None, RNA_confirm, button_fn_confirm)
    button_cancel = ButtonFn(None, RNA_cancel, button_fn_cancel)
    rna = PpOverrideClear.bl_rna.properties["remap_local_usages"]
    rna1 = PpOverrideClear.bl_rna.properties["delete_unused"]

    ddw = DropDownInfoUtil(self, MOUSE,
        [ButtonSplit(None, button_confirm, button_cancel, gap)],
        area_items = area_items,
        title = "Override Clear",
        input_text = f"{rna.name}\n    {rna.description}.\n{rna1.name}\n    {rna1.description}.",
        row_count = 5,
        width_fac = 2.2,
        block_size = 3,
        wrap_input = True)

    area_tab = ddw.r_area_tab()
    pp = PpOverrideClear(area_tab)

    ui = Ui(area_tab)
    ui_anim_data = ui.set_pp(lambda: pp, PpOverrideClear, NS)

    b0 = ui.new_block()
    b0.w.no_background()
    b0.prop("remap_local_usages")
    b0.prop("delete_unused")
    for e in ui_anim_data.props.values():
        allot_callback_unpush(e)
        e.upd_data()

    area_tab.init_items_tab()
    #|


## _file_ ##
def late_import():
    #|
    import bpy, blf, gpu, math, mathutils

    timer_reg = bpy.app.timers.register
    timer_unreg = bpy.app.timers.unregister
    timer_isreg = bpy.app.timers.is_registered

    blfSize = blf.size
    blfColor = blf.color
    blfPos = blf.position
    blfDraw = blf.draw
    blfDimen = blf.dimensions

    # <<< 1mp (gpu.state
    state = gpu.state
    blend_set = state.blend_set
    scissor_get = state.scissor_get
    scissor_set = state.scissor_set
    # >>>

    # <<< 1mp (math
    floor = math.floor
    ceil = math.ceil
    # >>>

    # <<< 1mp (mathutils
    Vector = mathutils.Vector
    # >>>

    from types import SimpleNamespace

    from .  import VMD

    # <<< 1mp (VMD
    m = VMD.m
    util = VMD.util
    utilbl = VMD.utilbl
    # >>>

    # <<< 1mp (VMD.api
    api = VMD.api
    D_cls_id = api.D_cls_id
    D_id_blendData = api.D_id_blendData
    D_cls_blendData = api.D_cls_blendData
    S_ALLOW_ASSET = api.S_ALLOW_ASSET
    S_ALLOW_PREVIEW = api.S_ALLOW_PREVIEW
    # >>>

    # <<< 1mp (VMD.area
    area = VMD.area
    preview_datablock = area.preview_datablock
    AreaStringPre = area.AreaStringPre
    # >>>

    # <<< 1mp (VMD.colorlist
    colorlist = VMD.colorlist
    L_rgb_to_glc = colorlist.L_rgb_to_glc
    L_rgb_to_scene_linear = colorlist.L_rgb_to_scene_linear
    scene_linear_to_hex = colorlist.scene_linear_to_hex
    # >>>

    # <<< 1mp (VMD.dd
    dd = VMD.dd
    DropDownVal = dd.DropDownVal
    DropDownRMKeymap = dd.DropDownRMKeymap
    DropDownRM = dd.DropDownRM
    DropDownString = dd.DropDownString
    DropDownStringMatch = dd.DropDownStringMatch
    DropDownStringXY = dd.DropDownStringXY
    DropDownEnum = dd.DropDownEnum
    DropDownEnumRename = dd.DropDownEnumRename
    DropDownEnumPointer = dd.DropDownEnumPointer
    DropDownEnumTexture = dd.DropDownEnumTexture
    DropDownEnumImage = dd.DropDownEnumImage
    DropDownEnumMaterial = dd.DropDownEnumMaterial
    DropDownOk = dd.DropDownOk
    DropDownYesNo = dd.DropDownYesNo
    DropDownInfoUtil = dd.DropDownInfoUtil
    DropDownNewModifier = dd.DropDownNewModifier
    DropDownAddOpsShortcut = dd.DropDownAddOpsShortcut
    DropDownEditOpsShortcut = dd.DropDownEditOpsShortcut
    DropDownBuColor = dd.DropDownBuColor
    DDKeyframes = dd.DDKeyframes
    DDKeyframeGroup = dd.DDKeyframeGroup
    get_info_users = dd.get_info_users
    call_dd_index_dialog = dd.call_dd_index_dialog
    # >>>

    # <<< 1mp (VMD.handle
    handle = VMD.handle
    upd_link_data = handle.upd_link_data
    # >>>

    # <<< 1mp (VMD.keysys
    keysys = VMD.keysys
    kill_evt_except = keysys.kill_evt_except
    MOUSE = keysys.MOUSE
    EVT_TYPE = keysys.EVT_TYPE
    TRIGGER = keysys.TRIGGER
    r_end_trigger = keysys.r_end_trigger
    CALC_EXP = keysys.CALC_EXP
    is_first_press = keysys.is_first_press
    # >>>

    # <<< 1mp (m
    P = m.P
    Admin = m.Admin
    W_HEAD = m.W_HEAD
    update_data = m.update_data
    UnitSystem = m.UnitSystem
    r_unit_factor = m.r_unit_factor
    r_mouseloop = m.r_mouseloop
    modal_object_picker_init = m.modal_object_picker_init
    object_select = m.object_select
    disable_auto_upd = m.disable_auto_upd
    enable_auto_upd = m.enable_auto_upd
    object_mode_set = m.object_mode_set
    draw_view_append = m.draw_view_append
    draw_view_remove = m.draw_view_remove
    # >>>

    # <<< 1mp (VMD.rna
    rna = VMD.rna
    RNA_active_object = rna.RNA_active_object
    RNA_active_object_sync = rna.RNA_active_object_sync
    RNA_active_modifier = rna.RNA_active_modifier
    RNA_active_modifier_sync = rna.RNA_active_modifier_sync
    RNA_new_modifier = rna.RNA_new_modifier
    RNA_remove_modifier = rna.RNA_remove_modifier
    RNA_active_item = rna.RNA_active_item
    RNA_new_item = rna.RNA_new_item
    RNA_remove_item = rna.RNA_remove_item
    RNA_button_keyframe = rna.RNA_button_keyframe
    RNA_run = rna.RNA_run
    RNA_cancel = rna.RNA_cancel
    RNA_confirm = rna.RNA_confirm
    # >>>

    # <<< 1mp (VMD.win
    win = VMD.win
    Head = win.Head
    Detail = win.Detail
    # >>>

    # <<< 1mp (VMD.evals.evalbatchoperation
    evalbatchoperation = VMD.evals.evalbatchoperation
    eval_batch_operation = evalbatchoperation.eval_batch_operation
    r_code_batch_operation = evalbatchoperation.r_code_batch_operation
    # >>>

    # <<< 1mp (VMD.evals.evalutil
    evalutil = VMD.evals.evalutil
    bpyeval = evalutil.bpyeval
    # >>>

    # <<< 1mp (utilbl
    blg = utilbl.blg
    # >>>

    # <<< 1mp (blg
    D_SIZE = blg.D_SIZE
    FONT0 = blg.FONT0
    FONT1 = blg.FONT1
    SIZE_widget = blg.SIZE_widget
    SIZE_border = blg.SIZE_border
    SIZE_block = blg.SIZE_block
    SIZE_foreground_height = blg.SIZE_foreground_height
    SIZE_button = blg.SIZE_button
    SIZE_setting_list_border = blg.SIZE_setting_list_border
    SIZE_title = blg.SIZE_title
    COL_block = blg.COL_block
    COL_block_even = blg.COL_block_even
    COL_block_fo = blg.COL_block_fo
    COL_block_fg = blg.COL_block_fg
    COL_block_fg_ignore = blg.COL_block_fg_ignore
    COL_block_fg_info = blg.COL_block_fg_info
    COL_block_calc_display = blg.COL_block_calc_display
    COL_block_calc_button_bg = blg.COL_block_calc_button_bg
    COL_block_guideline0 = blg.COL_block_guideline0
    COL_block_guideline1 = blg.COL_block_guideline1
    COL_block_title = blg.COL_block_title
    COL_block_title_even = blg.COL_block_title_even
    COL_box_val = blg.COL_box_val
    COL_box_val_rim = blg.COL_box_val_rim
    COL_box_val_ignore = blg.COL_box_val_ignore
    COL_box_val_rim_ignore = blg.COL_box_val_rim_ignore
    COL_box_val_fo = blg.COL_box_val_fo
    COL_box_val_active = blg.COL_box_val_active
    COL_box_val_bool = blg.COL_box_val_bool
    COL_box_val_bool_fo = blg.COL_box_val_bool_fo
    COL_box_val_fg = blg.COL_box_val_fg
    COL_box_val_fg_ignore = blg.COL_box_val_fg_ignore
    COL_box_val_fg_error = blg.COL_box_val_fg_error
    COL_box_button_fg = blg.COL_box_button_fg
    COL_box_button_fg_info = blg.COL_box_button_fg_info
    COL_box_button_fg_ignore = blg.COL_box_button_fg_ignore
    COL_box_text = blg.COL_box_text
    COL_box_text_rim = blg.COL_box_text_rim
    COL_box_text_ignore = blg.COL_box_text_ignore
    COL_box_text_rim_ignore = blg.COL_box_text_rim_ignore
    COL_box_text_active = blg.COL_box_text_active
    COL_box_text_fo = blg.COL_box_text_fo
    COL_box_text_fg = blg.COL_box_text_fg
    COL_box_text_fg_ignore = blg.COL_box_text_fg_ignore
    COL_box_text_read = blg.COL_box_text_read
    COL_box_text_read_rim = blg.COL_box_text_read_rim
    COL_box_text_read_fg = blg.COL_box_text_read_fg
    COL_box_text_selection = blg.COL_box_text_selection
    COL_box_color_rim = blg.COL_box_color_rim
    COL_box_color_rim_fo = blg.COL_box_color_rim_fo
    COL_box_filter = blg.COL_box_filter
    COL_box_filter_rim = blg.COL_box_filter_rim
    Blf = blg.Blf
    BlfClip = blg.BlfClip
    BlfColor = blg.BlfColor
    BlfClipColor = blg.BlfClipColor
    r_blf_clipping_end = blg.r_blf_clipping_end
    r_blf_clipping_end_with = blg.r_blf_clipping_end_with
    rl_blf_wrap_LR = blg.rl_blf_wrap_LR
    r_widget_font_dx_dy_dT = blg.r_widget_font_dx_dy_dT
    BoxFake = blg.BoxFake
    GpuBox = blg.GpuBox
    GpuBox_block = blg.GpuBox_block
    GpuRim = blg.GpuRim
    GpuButton = blg.GpuButton
    GpuButtonBool = blg.GpuButtonBool
    GpuCheckbox = blg.GpuCheckbox
    GpuGrid = blg.GpuGrid
    GpuBox_box_filter_active_bg = blg.GpuBox_box_filter_active_bg
    GpuImgNull = blg.GpuImgNull
    GpuImg_valuebox_left = blg.GpuImg_valuebox_left
    GpuImg_valuebox_right = blg.GpuImg_valuebox_right
    GpuImg_fold = blg.GpuImg_fold
    GpuImg_fold_focus = blg.GpuImg_fold_focus
    GpuImg_unfold = blg.GpuImg_unfold
    GpuImg_unfold_focus = blg.GpuImg_unfold_focus
    GpuImg_ADD = blg.GpuImg_ADD
    GpuImg_ADD_focus = blg.GpuImg_ADD_focus
    GpuImg_REMOVE = blg.GpuImg_REMOVE
    GpuImg_REMOVE_focus = blg.GpuImg_REMOVE_focus
    GpuImg_TRIA_UP = blg.GpuImg_TRIA_UP
    GpuImg_TRIA_UP_focus = blg.GpuImg_TRIA_UP_focus
    GpuImg_TRIA_DOWN = blg.GpuImg_TRIA_DOWN
    GpuImg_TRIA_DOWN_focus = blg.GpuImg_TRIA_DOWN_focus
    GpuImg_FAKE_USER_OFF = blg.GpuImg_FAKE_USER_OFF
    GpuImg_FAKE_USER_OFF_focus = blg.GpuImg_FAKE_USER_OFF_focus
    GpuImg_FAKE_USER_ON = blg.GpuImg_FAKE_USER_ON
    GpuImg_FAKE_USER_ON_focus = blg.GpuImg_FAKE_USER_ON_focus
    GpuImg_FAKE_USER_LIB = blg.GpuImg_FAKE_USER_LIB
    GpuImg_FAKE_USER_LIB_focus = blg.GpuImg_FAKE_USER_LIB_focus
    GpuImg_FAKE_USER_LINK = blg.GpuImg_FAKE_USER_LINK
    GpuImg_FAKE_USER_LINK_focus = blg.GpuImg_FAKE_USER_LINK_focus
    GpuImg_FAKE_USER_OVERRIDE = blg.GpuImg_FAKE_USER_OVERRIDE
    GpuImg_FAKE_USER_OVERRIDE_focus = blg.GpuImg_FAKE_USER_OVERRIDE_focus
    GpuImg_area_icon_hover = blg.GpuImg_area_icon_hover
    GpuImg_filter_match_case = blg.GpuImg_filter_match_case
    GpuImg_filter_match_whole_word = blg.GpuImg_filter_match_whole_word
    GpuImg_filter_match_end_left = blg.GpuImg_filter_match_end_left
    GpuImg_filter_match_end_right = blg.GpuImg_filter_match_end_right
    GpuImg_filter_match_active = blg.GpuImg_filter_match_active
    GpuImg_filter_match_hover = blg.GpuImg_filter_match_hover
    GpuImg_keyframe_false = blg.GpuImg_keyframe_false
    GpuImg_keyframe_current_true_even = blg.GpuImg_keyframe_current_true_even
    GpuImg_keyframe_current_true_odd = blg.GpuImg_keyframe_current_true_odd
    GpuImg_keyframe_next_false_even = blg.GpuImg_keyframe_next_false_even
    GpuImg_keyframe_next_false_odd = blg.GpuImg_keyframe_next_false_odd
    GpuImg_driver_true = blg.GpuImg_driver_true
    GpuImg_driver_ref = blg.GpuImg_driver_ref
    GpuImg_keyframe_false_dark = blg.GpuImg_keyframe_false_dark
    GpuImg_keyframe_current_true_even_dark = blg.GpuImg_keyframe_current_true_even_dark
    GpuImg_keyframe_current_true_odd_dark = blg.GpuImg_keyframe_current_true_odd_dark
    GpuImg_keyframe_next_false_even_dark = blg.GpuImg_keyframe_next_false_even_dark
    GpuImg_keyframe_next_false_odd_dark = blg.GpuImg_keyframe_next_false_odd_dark
    GpuImg_driver_true_dark = blg.GpuImg_driver_true_dark
    GpuImg_driver_ref_dark = blg.GpuImg_driver_ref_dark
    GpuImg_OBJECT_DATA = blg.GpuImg_OBJECT_DATA
    GpuImg_ID_OBJECT = blg.GpuImg_ID_OBJECT
    GpuImg_ID_COLLECTION = blg.GpuImg_ID_COLLECTION
    GpuImg_ID_TEXTURE = blg.GpuImg_ID_TEXTURE
    GpuImg_ID_MATERIAL = blg.GpuImg_ID_MATERIAL
    GpuImg_ID_IMAGE = blg.GpuImg_ID_IMAGE
    GpuImg_ID_CACHEFILE = blg.GpuImg_ID_CACHEFILE
    GpuImg_ID_NODETREE = blg.GpuImg_ID_NODETREE
    GpuImg_ID_KEY = blg.GpuImg_ID_KEY
    GpuImg_ID_PARTICLE = blg.GpuImg_ID_PARTICLE
    GpuImg_GROUP_VERTEX = blg.GpuImg_GROUP_VERTEX
    GpuImg_BONE_DATA = blg.GpuImg_BONE_DATA
    GpuImg_GREASEPENCIL = blg.GpuImg_GREASEPENCIL
    GpuImg_GROUP_UVS = blg.GpuImg_GROUP_UVS
    GpuImg_object_picker = blg.GpuImg_object_picker
    GpuImg_object_picker_focus = blg.GpuImg_object_picker_focus
    GpuImg_object_picker_dark = blg.GpuImg_object_picker_dark
    GpuImg_delete = blg.GpuImg_delete
    GpuImg_delete_focus = blg.GpuImg_delete_focus
    GpuImg_delete_dark = blg.GpuImg_delete_dark
    GpuImg_rename = blg.GpuImg_rename
    GpuImg_rename_focus = blg.GpuImg_rename_focus
    GpuImg_rna = blg.GpuImg_rna
    GpuImg_DUPLICATE = blg.GpuImg_DUPLICATE
    GpuImg_DUPLICATE_focus = blg.GpuImg_DUPLICATE_focus
    GpuImg_HIDE_OFF = blg.GpuImg_HIDE_OFF
    GpuImg_HIDE_OFF_focus = blg.GpuImg_HIDE_OFF_focus
    GpuImg_HIDE_ON = blg.GpuImg_HIDE_ON
    GpuImg_HIDE_ON_focus = blg.GpuImg_HIDE_ON_focus
    GpuImg_FILE_FOLDER = blg.GpuImg_FILE_FOLDER
    GpuImg_FILE_FOLDER_focus = blg.GpuImg_FILE_FOLDER_focus
    GpuImg_GROUP_VCOL = blg.GpuImg_GROUP_VCOL
    GpuImg_PARTICLE_SYSTEM = blg.GpuImg_PARTICLE_SYSTEM
    GpuImg_SHAPEKEY = blg.GpuImg_SHAPEKEY
    GpuImg_stop_dark = blg.GpuImg_stop_dark
    GpuImg_copy_array = blg.GpuImg_copy_array
    GpuImg_reset_override = blg.GpuImg_reset_override
    GpuImg_ASSET_MANAGER = blg.GpuImg_ASSET_MANAGER
    GpuImg_SPREADSHEET = blg.GpuImg_SPREADSHEET
    GpuImg_POINT = blg.GpuImg_POINT
    GpuImg_invert = blg.GpuImg_invert
    Scissor = blg.Scissor
    report = blg.report
    is_LRBT_match = blg.is_LRBT_match
    geticon_Object = blg.geticon_Object
    getinfo_Object = blg.getinfo_Object
    geticon_Modifier = blg.geticon_Modifier
    geticon_DriverVar = blg.geticon_DriverVar
    D_geticon_domain = blg.D_geticon_domain
    S_icon_keyframe_true = blg.S_icon_keyframe_true
    # >>>

    # <<< 1mp (utilbl.calc
    calc = utilbl.calc
    calc_vec = calc.calc_vec
    round_dec = calc.round_dec
    # >>>

    # <<< 1mp (utilbl.general
    general = utilbl.general
    r_obj_path_by_full_path = general.r_obj_path_by_full_path
    r_add_to_keying_set = general.r_add_to_keying_set
    r_remove_from_keying_set = general.r_remove_from_keying_set
    r_library_or_override_message = general.r_library_or_override_message
    r_library_editable = general.r_library_editable
    r_fcurve_name = general.r_fcurve_name
    r_override_value = general.r_override_value
    update_scene = general.update_scene
    update_scene_push = general.update_scene_push
    is_array_fcurve = general.is_array_fcurve
    r_ID_dp = general.r_ID_dp
    r_id_type = general.r_id_type
    dp_repr = general.dp_repr
    dpf_repr = general.dpf_repr
    r_dp_with = general.r_dp_with
    r_dpf_with = general.r_dpf_with
    r_driver_fc = general.r_driver_fc
    r_action_fc = general.r_action_fc
    is_vec = general.is_vec
    is_value_overridden = general.is_value_overridden
    # >>>

    # <<< 1mp (utilbl.md
    md = utilbl.md
    r_md_driver_add = md.r_md_driver_add
    r_md_driver_remove = md.r_md_driver_remove
    r_md_keyframe = md.r_md_keyframe
    r_md_driver = md.r_md_driver
    r_md_refdriver = md.r_md_refdriver
    add_empty_geometry_node_group = md.add_empty_geometry_node_group
    ModAttr = md.ModAttr
    ModArrayAttr = md.ModArrayAttr
    # >>>

    # <<< 1mp (utilbl.ops
    ops = utilbl.ops
    OpScanFile = ops.OpScanFile
    OpScanFolder = ops.OpScanFolder
    # >>>

    # <<< 1mp (utilbl.pymath
    pymath = utilbl.pymath
    calc_py_exp = pymath.calc_py_exp
    # >>>


    r_intersect_scissor = Scissor.r_intersect_scissor
    ed_undo_push = bpy.ops.ed.undo_push

    _xy = [0, 0]
    _valboxdata = [None]
    _time = [0]
    _timer_button_fn = None
    _last_bool_state = [False]

    D_format = UnitSystem.D_format
    P_SettingEditor = P.SettingEditor

    r_all_objects = m.BlendDataTemp.r_all_objects
    tag_obj_rename = m.tag_obj_rename

    D_subtype_display = {
        'PIXEL': ('px', ),
        'DISTANCE': TUP_XYZ,
        'ANGLE': ('X', 'Y', 'Z', 'W'),
        'TRANSLATION': TUP_XYZ,
        'XYZ_LENGTH': TUP_XYZ,
        'XYZ': TUP_XYZ,
        'EULER': TUP_XYZ,
        'DIRECTION': TUP_XYZ,
        'VELOCITY': TUP_XYZ,
        'ACCELERATION': TUP_XYZ,
        'COORDINATES': TUP_XYZ}

    PREF_HISTORY = LocalHistory(None, 1)
    MODAL_DRAG_STATE = [-1]

    globals().update(locals())
    #|
